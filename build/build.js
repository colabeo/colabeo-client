

/*eslint no-underscore-dangle: 1, eqeqeq:1*/
// This is a modified version of component-require.
// https://github.com/component/require
//
// This will likely be completely rewritten in the future to handle requires
// across all package ecosystems (famous, npm, component, bower, etc.);
/**
 * Require the given path.
 *
 * @param {String} path
 * @return {Object} exports
 * @api public
 */
function require(path, parent, orig) {
    var resolved = require.resolve(path);
    // lookup failed
    if (null == resolved) {
        orig = orig || path;
        parent = parent || "root";
        var err = new Error("Failed to require '" + orig + "' from '" + parent + "'");
        err.path = orig;
        err.parent = parent;
        err.require = true;
        throw err;
    }
    var module = require.modules[resolved];
    // perform real require()
    // by invoking the module's
    // registered function
    if (!module._resolving && !module.exports) {
        var mod = {};
        mod.exports = {};
        mod.client = mod.component = true;
        module._resolving = true;
        module.call(this, mod.exports, require.relative(resolved), mod);
        delete module._resolving;
        module.exports = mod.exports;
    }
    return module.exports;
}

/**
 * Registered modules.
 */
require.modules = {};

/**
 * Registered aliases.
 */
require.aliases = {};

/**
 * Resolve `path`.
 *
 * Lookup:
 *
 *   - PATH/index.js
 *   - PATH.js
 *   - PATH
 *
 * @param {String} path
 * @return {String} path or null
 * @api private
 */
require.resolve = function(path) {
    if (require.modules.hasOwnProperty(path)) {
        return path;
    }
    if (require.aliases.hasOwnProperty(path)) {
        return require.aliases[path];
    }
};

/**
 * Register module at `path` with callback `definition`.
 *
 * @param {String} path
 * @param {Function} definition
 * @api private
 */
require.register = function(path, definition) {
    require.modules[path] = definition;
};

/**
 * Alias a module definition.
 *
 * @param {String} from
 * @param {String} to
 * @api private
 */
require.alias = function(from, to) {
    if (!require.modules.hasOwnProperty(from)) {
        throw new Error("Failed to alias '" + from + "', it does not exist");
    }
    require.aliases[to] = from;
};

/**
 * This is meant to mimic the "map" property of the requirejs.config object
 * ref: http://requirejs.org/docs/api.html#config-map
 *
 * @param  {[type]} config [description]
 * @return {[type]}        [description]
 */
require.config = function(config) {
    config = config || {};
    if (config.map) {
        var DAG = config.map;
        for (var key in DAG) {
            if (DAG.hasOwnProperty(key)) {
                var depMap = DAG[key];
                for (var dep in depMap) {
                    if (depMap.hasOwnProperty(dep)) {
                        var from = depMap[dep];
                        var to = [ key, dep ].join(":");
                        require.alias(from, to);
                    }
                }
            }
        }
    }
};

/**
 * Return a require function relative to the `parent` path.
 *
 * @param {String} parent
 * @return {Function}
 * @api private
 */
require.relative = function(parent) {
    // this lambda is localRequire
    return function(path) {
        var resolved = [ parent, path ].join(":");
        return require(resolved, parent, path);
    };
};

require.register("famous_modules/famous/polyfills/_git_master/index.js", function(exports, require, module) {
    require("./classList.js");
    require("./functionPrototypeBind.js");
    require("./requestAnimationFrame.js");
}.bind(this));

require.register("famous_modules/famous/polyfills/_git_master/classList.js", function(exports, require, module) {
    /*
     * classList.js: Cross-browser full element.classList implementation.
     * 2011-06-15
     *
     * By Eli Grey, http://eligrey.com
     * Public Domain.
     * NO WARRANTY EXPRESSED OR IMPLIED. USE AT YOUR OWN RISK.
     */
    /*global self, document, DOMException */
    /*! @source http://purl.eligrey.com/github/classList.js/blob/master/classList.js*/
    if (typeof document !== "undefined" && !("classList" in document.createElement("a"))) {
        (function(view) {
            "use strict";
            var classListProp = "classList", protoProp = "prototype", elemCtrProto = (view.HTMLElement || view.Element)[protoProp], objCtr = Object, strTrim = String[protoProp].trim || function() {
                return this.replace(/^\s+|\s+$/g, "");
            }, arrIndexOf = Array[protoProp].indexOf || function(item) {
                var i = 0, len = this.length;
                for (;i < len; i++) {
                    if (i in this && this[i] === item) {
                        return i;
                    }
                }
                return -1;
            }, DOMEx = function(type, message) {
                this.name = type;
                this.code = DOMException[type];
                this.message = message;
            }, checkTokenAndGetIndex = function(classList, token) {
                if (token === "") {
                    throw new DOMEx("SYNTAX_ERR", "An invalid or illegal string was specified");
                }
                if (/\s/.test(token)) {
                    throw new DOMEx("INVALID_CHARACTER_ERR", "String contains an invalid character");
                }
                return arrIndexOf.call(classList, token);
            }, ClassList = function(elem) {
                var trimmedClasses = strTrim.call(elem.className), classes = trimmedClasses ? trimmedClasses.split(/\s+/) : [], i = 0, len = classes.length;
                for (;i < len; i++) {
                    this.push(classes[i]);
                }
                this._updateClassName = function() {
                    elem.className = this.toString();
                };
            }, classListProto = ClassList[protoProp] = [], classListGetter = function() {
                return new ClassList(this);
            };
            // Most DOMException implementations don't allow calling DOMException's toString()
            // on non-DOMExceptions. Error's toString() is sufficient here.
            DOMEx[protoProp] = Error[protoProp];
            classListProto.item = function(i) {
                return this[i] || null;
            };
            classListProto.contains = function(token) {
                token += "";
                return checkTokenAndGetIndex(this, token) !== -1;
            };
            classListProto.add = function(token) {
                token += "";
                if (checkTokenAndGetIndex(this, token) === -1) {
                    this.push(token);
                    this._updateClassName();
                }
            };
            classListProto.remove = function(token) {
                token += "";
                var index = checkTokenAndGetIndex(this, token);
                if (index !== -1) {
                    this.splice(index, 1);
                    this._updateClassName();
                }
            };
            classListProto.toggle = function(token) {
                token += "";
                if (checkTokenAndGetIndex(this, token) === -1) {
                    this.add(token);
                } else {
                    this.remove(token);
                }
            };
            classListProto.toString = function() {
                return this.join(" ");
            };
            if (objCtr.defineProperty) {
                var classListPropDesc = {
                    get: classListGetter,
                    enumerable: true,
                    configurable: true
                };
                try {
                    objCtr.defineProperty(elemCtrProto, classListProp, classListPropDesc);
                } catch (ex) {
                    // IE 8 doesn't support enumerable:true
                    if (ex.number === -2146823252) {
                        classListPropDesc.enumerable = false;
                        objCtr.defineProperty(elemCtrProto, classListProp, classListPropDesc);
                    }
                }
            } else if (objCtr[protoProp].__defineGetter__) {
                elemCtrProto.__defineGetter__(classListProp, classListGetter);
            }
        })(self);
    }
}.bind(this));

require.register("famous_modules/famous/polyfills/_git_master/functionPrototypeBind.js", function(exports, require, module) {
    if (!Function.prototype.bind) {
        Function.prototype.bind = function(oThis) {
            if (typeof this !== "function") {
                // closest thing possible to the ECMAScript 5 internal IsCallable function
                throw new TypeError("Function.prototype.bind - what is trying to be bound is not callable");
            }
            var aArgs = Array.prototype.slice.call(arguments, 1), fToBind = this, fNOP = function() {}, fBound = function() {
                return fToBind.apply(this instanceof fNOP && oThis ? this : oThis, aArgs.concat(Array.prototype.slice.call(arguments)));
            };
            fNOP.prototype = this.prototype;
            fBound.prototype = new fNOP();
            return fBound;
        };
    }
}.bind(this));

require.register("famous_modules/famous/polyfills/_git_master/requestAnimationFrame.js", function(exports, require, module) {
    // adds requestAnimationFrame functionality
    // Source: http://strd6.com/2011/05/better-window-requestanimationframe-shim/
    window.requestAnimationFrame || (window.requestAnimationFrame = window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || function(callback, element) {
        return window.setTimeout(function() {
            callback(+new Date());
        }, 1e3 / 60);
    });
}.bind(this));

require.register("famous_modules/famous/transitions/easing/_git_master/index.js", function(exports, require, module) {
    /*
     *  EasingName: 
     *  @param {float} t: (time) expects a number between 0 and 1.
     *  @returns {float}: between 0 and 1, based on the curve.
     *  NOTE: Can only use  functions with FamousTransforms, passed in as a curve.
     *
     *  @example:
     *  var curve = { 
     *      curve: Easing.inOutBack,
     *      duration: 500
     *  }
     *  yourTransform.setTransform(FM.identity, curve);
     *
     *  This would animate over 500 milliseconds back to [0, 0, 0]
     *
     *      
     *  EasingName: 
     *  @param {float} t: current normalized time: expects a number between 0 and 1.
     *
     *  @returns {float}: number between 0 and 1;
     *
     *  Most often used with the Animation engine:
     *  @example:
     *  animation.update = function() {
     *      someFunction.set(Easing.inOutCubic(this.getTime(), 0, 1000, 1.0)); 
     *  }
     *
     *  this would output numbers between 0 and 1000.
     *
     */
    var Easing = {
        inQuad: function(t) {
            return t * t;
        },
        outQuad: function(t) {
            return -(t -= 1) * t + 1;
        },
        inOutQuad: function(t) {
            if ((t /= .5) < 1) return .5 * t * t;
            return -.5 * (--t * (t - 2) - 1);
        },
        inCubic: function(t) {
            return t * t * t;
        },
        outCubic: function(t) {
            return --t * t * t + 1;
        },
        inOutCubic: function(t) {
            if ((t /= .5) < 1) return .5 * t * t * t;
            return .5 * ((t -= 2) * t * t + 2);
        },
        inQuart: function(t) {
            return t * t * t * t;
        },
        outQuart: function(t) {
            return -(--t * t * t * t - 1);
        },
        inOutQuart: function(t) {
            if ((t /= .5) < 1) return .5 * t * t * t * t;
            return -.5 * ((t -= 2) * t * t * t - 2);
        },
        inQuint: function(t) {
            return t * t * t * t * t;
        },
        outQuint: function(t) {
            return --t * t * t * t * t + 1;
        },
        inOutQuint: function(t) {
            if ((t /= .5) < 1) return .5 * t * t * t * t * t;
            return .5 * ((t -= 2) * t * t * t * t + 2);
        },
        inSine: function(t) {
            return -1 * Math.cos(t * (Math.PI / 2)) + 1;
        },
        outSine: function(t) {
            return Math.sin(t * (Math.PI / 2));
        },
        inOutSine: function(t) {
            return -.5 * (Math.cos(Math.PI * t) - 1);
        },
        inExpo: function(t) {
            return t == 0 ? 0 : Math.pow(2, 10 * (t - 1));
        },
        outExpo: function(t) {
            return t == 1 ? 1 : -Math.pow(2, -10 * t) + 1;
        },
        inOutExpo: function(t) {
            if (t == 0) return 0;
            if (t == 1) return 1;
            if ((t /= .5) < 1) return .5 * Math.pow(2, 10 * (t - 1));
            return .5 * (-Math.pow(2, -10 * --t) + 2);
        },
        inCirc: function(t) {
            return -(Math.sqrt(1 - t * t) - 1);
        },
        outCirc: function(t) {
            return Math.sqrt(1 - --t * t);
        },
        inOutCirc: function(t) {
            if ((t /= .5) < 1) return -.5 * (Math.sqrt(1 - t * t) - 1);
            return .5 * (Math.sqrt(1 - (t -= 2) * t) + 1);
        },
        inElastic: function(t) {
            var s = 1.70158;
            var p = 0;
            var a = 1;
            if (t == 0) return 0;
            if (t == 1) return 1;
            if (!p) p = .3;
            s = p / (2 * Math.PI) * Math.asin(1 / a);
            return -(a * Math.pow(2, 10 * (t -= 1)) * Math.sin((t - s) * (2 * Math.PI) / p));
        },
        outElastic: function(t) {
            var s = 1.70158;
            var p = 0;
            var a = 1;
            if (t == 0) return 0;
            if (t == 1) return 1;
            if (!p) p = .3;
            s = p / (2 * Math.PI) * Math.asin(1 / a);
            return a * Math.pow(2, -10 * t) * Math.sin((t - s) * (2 * Math.PI) / p) + 1;
        },
        inOutElastic: function(t) {
            var s = 1.70158;
            var p = 0;
            var a = 1;
            if (t == 0) return 0;
            if ((t /= .5) == 2) return 1;
            if (!p) p = .3 * 1.5;
            s = p / (2 * Math.PI) * Math.asin(1 / a);
            if (t < 1) return -.5 * (a * Math.pow(2, 10 * (t -= 1)) * Math.sin((t - s) * (2 * Math.PI) / p));
            return a * Math.pow(2, -10 * (t -= 1)) * Math.sin((t - s) * (2 * Math.PI) / p) * .5 + 1;
        },
        inBack: function(t, s) {
            if (s == undefined) s = 1.70158;
            return t * t * ((s + 1) * t - s);
        },
        outBack: function(t, s) {
            if (s == undefined) s = 1.70158;
            return --t * t * ((s + 1) * t + s) + 1;
        },
        inOutBack: function(t, s) {
            if (s == undefined) s = 1.70158;
            if ((t /= .5) < 1) return .5 * (t * t * (((s *= 1.525) + 1) * t - s));
            return .5 * ((t -= 2) * t * (((s *= 1.525) + 1) * t + s) + 2);
        },
        inBounce: function(t) {
            return 1 - Easing.outBounce(1 - t);
        },
        outBounce: function(t) {
            if (t < 1 / 2.75) {
                return 7.5625 * t * t;
            } else if (t < 2 / 2.75) {
                return 7.5625 * (t -= 1.5 / 2.75) * t + .75;
            } else if (t < 2.5 / 2.75) {
                return 7.5625 * (t -= 2.25 / 2.75) * t + .9375;
            } else {
                return 7.5625 * (t -= 2.625 / 2.75) * t + .984375;
            }
        },
        inOutBounce: function(t) {
            if (t < .5) return Easing.inBounce(t * 2) * .5;
            return Easing.outBounce(t * 2 - 1) * .5 + .5;
        }
    };
    module.exports = Easing;
}.bind(this));

require.register("famous_modules/famous/event-handler/_git_master/index.js", function(exports, require, module) {
    /**
     * @class EventHandler 
     * @description This object gives the user the opportunity to explicitly 
     *   control event propagation in their application. EventHandler forwards received events to a set of 
     *   provided callback functions. It allows events to be captured, processed,
     *   and optionally piped through to other event handlers.
     *
     * @name EventHandler
     * @constructor
     * 
     * @example
     *   var Engine = require('famous/Engine');
     *   var Surface = require('famous/Surface');
     *   var EventHandler = require('famous/EventHandler');
     *
     *   var Context = Engine.createContext();
     *
     *   var surface = new Surface({
     *       size: [200,200],
     *       properties: {
     *           backgroundColor: '#3cf'
     *       },
     *       content: 'test'
     *   });
     *
     *   eventListener = new EventHandler();
     *   surface.pipe(eventListener);
     *
     *   Context.add(surface);
     *
     *   eventInput.on('click', function(){
     *     alert('received click');
     *   });
     * 
     */
    function EventHandler() {
        this.listeners = {};
        this.downstream = [];
        // downstream event handlers
        this.downstreamFn = [];
        // downstream functions
        this.upstream = [];
        // upstream event handlers
        this.upstreamListeners = {};
        // upstream listeners
        this.owner = this;
    }
    /**
     * Send event data to all handlers matching provided 'type' key. If handler 
     *    is not set to "capture", pass on to any next handlers also. Event's 
     *    "origin" field is set to this object if not yet set.
     *
     * @name EventHandler#emit
     * @function
     * @param {string} type event type key (for example, 'click')
     * @param {Object} event received event data
     * @returns {boolean} true if this event has been handled by any handler
     */
    EventHandler.prototype.emit = function(type, event) {
        if (!event) event = {};
        var handlers = this.listeners[type];
        var handled = false;
        if (handlers) {
            for (var i = 0; i < handlers.length; i++) {
                if (handlers[i].call(this.owner, event)) handled = true;
            }
        }
        return _emitNext.call(this, type, event) || handled;
    };
    /**
     * Send event data to downstream handlers responding to this event type.
     *
     * @name _emitNext
     * @function
     * @private
     * @param {string} type event type key (for example, 'click')
     * @param {Object} event received event data
     * @returns {boolean} true if this event has been handled by any 
     *   downstream handler
     */
    function _emitNext(type, event) {
        var handled = false;
        for (var i = 0; i < this.downstream.length; i++) {
            handled = this.downstream[i].emit(type, event) || handled;
        }
        for (var i = 0; i < this.downstreamFn.length; i++) {
            handled = this.downstreamFn[i](type, event) || handled;
        }
        return handled;
    }
    /**
     * Add handler function to set of callback functions for the provided 
     *   event type.  
     *   The handler will receive the original emitted event data object
     *   as its sole argument.
     * 
     * @name EventHandler#on
     * @function
     * @param  {string} type event type key (for example, 'click')
     * @param  {function(string, Object)} handler handler function
     * @returns {EventHandler} this
     */
    EventHandler.prototype.on = function(type, handler) {
        if (!(type in this.listeners)) {
            this.listeners[type] = [];
            var upstreamListener = this.emit.bind(this, type);
            this.upstreamListeners[type] = upstreamListener;
            for (var i = 0; i < this.upstream.length; i++) {
                this.upstream[i].on(type, upstreamListener);
            }
        }
        var index = this.listeners[type].indexOf(handler);
        if (index < 0) this.listeners[type].push(handler);
        return this;
    };
    /**
     * Remove handler function from set of callback functions for the provided 
     *   event type. 
     * Undoes work of {@link EventHandler#on}
     * 
     * @name EventHandler#unbind
     * @function
     * @param  {string} type event type key (for example, 'click')
     * @param  {function(string, Object)} handler
     */
    EventHandler.prototype.unbind = function(type, handler) {
        var index = this.listeners[type].indexOf(handler);
        if (index >= 0) this.listeners[type].splice(index, 1);
    };
    /** 
     * Add handler object to set of DOWNSTREAM handlers.
     * 
     * @name EventHandler#pipe
     * @function
     * @param {emitterObject} target target emitter object
     */
    EventHandler.prototype.pipe = function(target) {
        if (target.subscribe instanceof Function) return target.subscribe(this);
        var downstreamCtx = target instanceof Function ? this.downstreamFn : this.downstream;
        var index = downstreamCtx.indexOf(target);
        if (index < 0) downstreamCtx.push(target);
        if (target instanceof Function) target("pipe"); else target.emit && target.emit("pipe");
        return target;
    };
    /**
     * Remove handler object from set of DOWNSTREAM handlers.
     * Undoes work of {@link EventHandler#pipe}
     * 
     * @name EventHandler#unpipe
     * @function
     * @param {emitterObject} target target emitter object
     */
    EventHandler.prototype.unpipe = function(target) {
        if (target.unsubscribe instanceof Function) return target.unsubscribe(this);
        var downstreamCtx = target instanceof Function ? this.downstreamFn : this.downstream;
        var index = downstreamCtx.indexOf(target);
        if (index >= 0) {
            downstreamCtx.splice(index, 1);
            if (target instanceof Function) target("unpipe"); else target.emit && target.emit("unpipe");
            return target;
        } else return false;
    };
    /**
     * Automatically listen to events from an UPSTREAM event handler
     *
     * @name EventHandler#subscribe
     * @function
     * @param {emitterObject} source source emitter object
     */
    EventHandler.prototype.subscribe = function(source) {
        var index = this.upstream.indexOf(source);
        if (index < 0) {
            this.upstream.push(source);
            for (var type in this.upstreamListeners) {
                source.on(type, this.upstreamListeners[type]);
            }
        }
        return this;
    };
    /**
     * Stop listening to events from an UPSTREAM event handler
     *
     * @name EventHandler#unsubscribe
     * @function
     * @param {emitterObject} source source emitter object
     */
    EventHandler.prototype.unsubscribe = function(source) {
        var index = this.upstream.indexOf(source);
        if (index >= 0) {
            this.upstream.splice(index, 1);
            for (var type in this.upstreamListeners) {
                source.unbind(type, this.upstreamListeners[type]);
            }
        }
        return this;
    };
    /**
     * Call event handlers with this set to owner
     *
     * @name EventHandler#bindThis
     * @function
     * @param {Object} owner object this EventHandler belongs to
     */
    EventHandler.prototype.bindThis = function(owner) {
        this.owner = owner;
    };
    /**
     * Assign an event handler to receive an object's events. 
     *
     * @name EventHandler#setInputHandler
     * @static
     * @function
     * @param {Object} object object to mix in emit function
     * @param {emitterObject} handler assigned event handler
     */
    EventHandler.setInputHandler = function(object, handler) {
        object.emit = handler.emit.bind(handler);
        if (handler.subscribe && handler.unsubscribe) {
            object.subscribe = handler.subscribe.bind(handler);
            object.unsubscribe = handler.unsubscribe.bind(handler);
        }
    };
    /**
     * Assign an event handler to emit an object's events
     *
     * @name EventHandler#setOutputHandler
     * @static
     * @function
     * @param {Object} object object to mix in pipe/unpipe/on/unbind functions
     * @param {emitterObject} handler assigned event emitter
     */
    EventHandler.setOutputHandler = function(object, handler) {
        if (handler instanceof EventHandler) handler.bindThis(object);
        object.pipe = handler.pipe.bind(handler);
        object.unpipe = handler.unpipe.bind(handler);
        object.on = handler.on.bind(handler);
        object.unbind = handler.unbind.bind(handler);
    };
    module.exports = EventHandler;
}.bind(this));

require.register("famous_modules/famous/utilities/utility/_git_master/index.js", function(exports, require, module) {
    /**
     * @namespace Utility
     *
     * TODO: combine with Utility.js into single utilities object?
     *
     * @description This namespace holds standalone functionality. 
     *    Currently includes 
     *    name mapping for transition curves, name mapping for origin 
     *    pairs, and the after() function.
     *    
     * @static
     * @name Utility
     */
    var Utility = {};
    /**
     * Transition curves mapping independent variable t from domain [0,1] to a
     *    range within [0,1]. Includes functions 'linear', 'easeIn', 'easeOut',
     *    'easeInOut', 'easeOutBounce', 'spring'.
     *
     *    TODO: move these into famous-transitions
     *    
     * @name Utility#curves
     * @deprecated
     * @field
     */
    Utility.Curve = {
        linear: function(t) {
            return t;
        },
        easeIn: function(t) {
            return t * t;
        },
        easeOut: function(t) {
            return t * (2 - t);
        },
        easeInOut: function(t) {
            if (t <= .5) return 2 * t * t; else return -2 * t * t + 4 * t - 1;
        },
        easeOutBounce: function(t) {
            return t * (3 - 2 * t);
        },
        spring: function(t) {
            return (1 - t) * Math.sin(6 * Math.PI * t) + t;
        }
    };
    Utility.Direction = {
        X: 0,
        Y: 1,
        Z: 2
    };
    /**
     * Table of strings mapping origin string types to origin pairs. Includes
     *    concepts of center and combinations of top, left, bottom, right, as
     *    'tl', 't', 'tr', 'l', 'c', 'r', 'bl', 'b', 'br'.
     *
     *    TODO: move these into famous-transitions
     *
     * @name Utility#Origin
     * @deprecated
     * @field
     */
    Utility.Origin = {
        tl: [ 0, 0 ],
        t: [ .5, 0 ],
        tr: [ 1, 0 ],
        l: [ 0, .5 ],
        c: [ .5, .5 ],
        r: [ 1, .5 ],
        bl: [ 0, 1 ],
        b: [ .5, 1 ],
        br: [ 1, 1 ]
    };
    /** 
     * Return wrapper around callback function. Once the wrapper is called N
     *    times, invoke the callback function. Arguments and scope preserved.
     *    
     * @name Utility#after
     * @function 
     * @param {number} count number of calls before callback function invoked
     * @param {Function} callback wrapped callback function
     */
    Utility.after = function(count, callback) {
        var counter = count;
        return function() {
            counter--;
            if (counter === 0) callback.apply(this, arguments);
        };
    };
    /**
     * Load a URL and return its contents in a callback
     * 
     * @name Utility#loadURL
     * @function
     * @param {string} url URL of object
     * @param {function} callback callback to dispatch with content
     */
    Utility.loadURL = function(url, callback) {
        var xhr = new XMLHttpRequest();
        xhr.onreadystatechange = function() {
            if (this.readyState == 4) {
                if (callback) callback(this.responseText);
            }
        };
        xhr.open("GET", url);
        xhr.send();
    };
    //TODO: can this be put into transform.js
    /** @const */
    Utility.transformInFrontMatrix = [ 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 1, 1 ];
    Utility.transformInFront = {
        modify: function(input) {
            return {
                transform: Utility.transformInFrontMatrix,
                target: input
            };
        }
    };
    //TODO: can this be put into transform.js
    /** @const */
    Utility.transformBehindMatrix = [ 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, -1, 1 ];
    Utility.transformBehind = {
        modify: function(input) {
            return {
                transform: Utility.transformBehindMatrix,
                target: input
            };
        }
    };
    /**
     * Create a new component based on an existing component configured with custom options
     *
     * @name Utility#customizeComponent
     * @function
     * @param {Object} component Base component class
     * @param {Object} customOptions Options to apply
     * @param {function} initialize Initialization function to run on creation
     * @returns {Object} customized component
     * @deprecated
     */
    Utility.customizeComponent = function(component, customOptions, initialize) {
        var result = function(options) {
            component.call(this, customOptions);
            if (options) this.setOptions(options);
            if (initialize) initialize.call(this);
        };
        result.prototype = Object.create(component.prototype);
        return result;
    };
    /**
     * Create a document fragment from a string of HTML
     *
     * @name Utility#createDocumentFragmentFromHTML
     * @function
     * @param {string} html HTML to convert to DocumentFragment
     * @returns {DocumentFragment} DocumentFragment representing input HTML
     */
    Utility.createDocumentFragmentFromHTML = function(html) {
        var element = document.createElement("div");
        element.innerHTML = html;
        var result = document.createDocumentFragment();
        while (element.hasChildNodes()) result.appendChild(element.firstChild);
        return result;
    };
    /**
     * @deprecated
     */
    Utility.rad2deg = function(rad) {
        return rad * 57.2957795;
    };
    /**
     * @deprecated
     */
    Utility.deg2rad = function(deg) {
        return deg * .0174532925;
    };
    /**
     * @deprecated
     */
    Utility.distance = function(x1, y1, x2, y2) {
        var deltaX = x2 - x1;
        var deltaY = y2 - y1;
        return Math.sqrt(deltaX * deltaX + deltaY * deltaY);
    };
    /**
     * @deprecated
     */
    Utility.distance3D = function(x1, y1, z1, x2, y2, z2) {
        var deltaX = x2 - x1;
        var deltaY = y2 - y1;
        var deltaZ = z2 - z1;
        return Math.sqrt(deltaX * deltaX + deltaY * deltaY + deltaZ * deltaZ);
    };
    //TODO: can this use inRange, outRange arrays instead
    Utility.map = function(value, inputMin, inputMax, outputMin, outputMax, clamp) {
        var outValue = (value - inputMin) / (inputMax - inputMin) * (outputMax - outputMin) + outputMin;
        if (clamp) {
            if (outputMax > outputMin) {
                if (outValue > outputMax) {
                    outValue = outputMax;
                } else if (outValue < outputMin) {
                    outValue = outputMin;
                }
            } else {
                if (outValue < outputMax) {
                    outValue = outputMax;
                } else if (outValue > outputMin) {
                    outValue = outputMin;
                }
            }
        }
        return outValue;
    };
    //TODO: can this be put into the matrix library?
    /**
     * @deprecated
     */
    Utility.perspective = function(fovy, aspect, near, far) {
        var f = 1 / Math.tan(fovy / 2), nf = 1 / (near - far);
        return [ f / aspect, 0, 0, 0, 0, f, 0, 0, 0, 0, (far + near) * nf, -1, 0, 0, 2 * far * near * nf, 0 ];
    };
    //TODO: can this be put into the matrix library?
    /**
     * @deprecated
     */
    Utility.ortho = function(left, right, bottom, top, near, far) {
        var tx = -(right + left) / (right - left);
        var ty = -(top + bottom) / (top - bottom);
        var tz = -(far + near) / (far - near);
        return [ 2 / (right - left), 0, 0, 0, 0, 2 / (top - bottom), 0, 0, 0, 0, -2 / (far - near), -1, tx, ty, tz, 1 ];
    };
    //TODO: can this be put into the matrix library?
    /**
     * @deprecated
     */
    Utility.normalFromFM = function(out, a) {
        var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3], a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7], a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11], a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15], b00 = a00 * a11 - a01 * a10, b01 = a00 * a12 - a02 * a10, b02 = a00 * a13 - a03 * a10, b03 = a01 * a12 - a02 * a11, b04 = a01 * a13 - a03 * a11, b05 = a02 * a13 - a03 * a12, b06 = a20 * a31 - a21 * a30, b07 = a20 * a32 - a22 * a30, b08 = a20 * a33 - a23 * a30, b09 = a21 * a32 - a22 * a31, b10 = a21 * a33 - a23 * a31, b11 = a22 * a33 - a23 * a32, // Calculate the determinant
        det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
        if (!det) {
            return null;
        }
        det = 1 / det;
        out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
        out[1] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
        out[2] = (a10 * b10 - a11 * b08 + a13 * b06) * det;
        out[3] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
        out[4] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
        out[5] = (a01 * b08 - a00 * b10 - a03 * b06) * det;
        out[6] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
        out[7] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
        out[8] = (a30 * b04 - a31 * b02 + a33 * b00) * det;
        return out;
    };
    //TODO: convert to min/max array
    Utility.clamp = function(v, min, max) {
        return Math.max(Math.min(v, max), min);
    };
    /**
     * @deprecated
     */
    Utility.isMobile = function() {
        return /Android|webOS|iPhone|iPad|iPod|BlackBerry/i.test(navigator.userAgent);
    };
    /**
     * @deprecated
     */
    Utility.extend = function(a, b) {
        for (var key in b) {
            a[key] = b[key];
        }
        return a;
    };
    Utility.getDevicePixelRatio = function() {
        return window.devicePixelRatio ? window.devicePixelRatio : 1;
    };
    /**
     * @deprecated
     */
    Utility.supportsWebGL = function() {
        return /Android|Chrome|Mozilla/i.test(navigator.appCodeName) && !!window.WebGLRenderingContext && !/iPhone|iPad|iPod/i.test(navigator.userAgent);
    };
    /**
     * @deprecated
     */
    Utility.getSurfacePosition = function getSurfacePosition(surface) {
        var currTarget = surface._currTarget;
        var totalDist = [ 0, 0, 0 ];
        function getAllTransforms(elem) {
            var transform = getTransform(elem);
            if (transform !== "" && transform !== undefined) {
                var offset = parseTransform(transform);
                totalDist[0] += offset[0];
                totalDist[1] += offset[1];
                totalDist[2] += offset[2];
            }
            if (elem.parentElement !== document.body) {
                getAllTransforms(elem.parentNode);
            }
        }
        function parseTransform(transform) {
            var translate = [];
            transform = removeMatrix3d(transform);
            translate[0] = parseInt(transform[12].replace(" ", ""));
            translate[1] = parseInt(transform[13].replace(" ", ""));
            translate[2] = parseInt(transform[14].replace(" ", ""));
            for (var i = 0; i < translate.length; i++) {
                if (typeof translate[i] == "undefined") {
                    translate[i] = 0;
                }
            }
            return translate;
        }
        function removeMatrix3d(mtxString) {
            mtxString = mtxString.replace("matrix3d(", "");
            mtxString = mtxString.replace(")", "");
            return mtxString.split(",");
        }
        function getTransform(elem) {
            var transform = elem["style"]["webkitTransform"] || elem["style"]["transform"];
            return transform;
        }
        if (currTarget) {
            getAllTransforms(currTarget);
        } else {
            return undefined;
        }
        return totalDist;
    };
    /**
     * @deprecated
     */
    Utility.hasUserMedia = function() {
        return !!(navigator.getUserMedia || navigator.webkitGetUserMedia || navigator.mozGetUserMedia || navigator.msGetUserMedia);
    };
    /**
     * @deprecated
     */
    Utility.getUserMedia = function() {
        return navigator.getUserMedia || navigator.webkitGetUserMedia || navigator.mozGetUserMedia || navigator.msGetUserMedia;
    };
    /**
     * @deprecated
     */
    Utility.isWebkit = function() {
        return !!window.webkitURL;
    };
    /**
     * @deprecated
     */
    Utility.isAndroid = function() {
        var userAgent = navigator.userAgent.toLowerCase();
        return userAgent.indexOf("android") > -1;
    };
    /**
     * @deprecated
     */
    Utility.hasLocalStorage = function() {
        return !!window.localStorage;
    };
    /**
     * TODO: move to time utilities library
     * @deprecated
     */
    Utility.timeSince = function(time) {
        var now = Date.now();
        var difference = now - time;
        var minute = 6e4;
        var hour = 60 * minute;
        var day = 24 * hour;
        if (difference < minute) {
            return "Just Now";
        } else if (difference < hour) {
            var minutes = ~~(difference / minute);
            return minutes + "m";
        } else if (difference < day) {
            var hours = ~~(difference / hour);
            return hours + "h";
        } else {
            var days = ~~(difference / day);
            return days + "d";
        }
    };
    module.exports = Utility;
}.bind(this));

require.register("famous_modules/famous/options-manager/_git_master/index.js", function(exports, require, module) {
    var EventHandler = require("famous/event-handler");
    /**
     * @class OptionsManager
     * @description 
     *   A collection of methods for setting options which can be extended
     *   onto other classes
     *
     * @name OptionsManager
     * @constructor
     *
     *  **** WARNING **** 
     *  You can only pass through objects that will compile into valid JSON. 
     *
     *  Valid options: 
     *      Strings,
     *      Arrays,
     *      Objects,
     *      Numbers,
     *      Nested Objects,
     *      Nested Arrays
     *
     *  This excludes: 
     *      Document Fragments,
     *      Functions
     */
    function OptionsManager(value) {
        this._value = value;
        this.eventOutput = null;
    }
    OptionsManager.patch = function(source, patch) {
        var manager = new OptionsManager(source);
        for (var i = 1; i < arguments.length; i++) manager.patch(arguments[i]);
        return source;
    };
    function _createEventOutput() {
        this.eventOutput = new EventHandler();
        this.eventOutput.bindThis(this);
        EventHandler.setOutputHandler(this, this.eventOutput);
    }
    OptionsManager.prototype.patch = function() {
        var myState = this._value;
        for (var i = 0; i < arguments.length; i++) {
            var patch = arguments[i];
            for (var k in patch) {
                if (k in myState && patch[k] && patch[k].constructor === Object && myState[k] && myState[k].constructor === Object) {
                    if (!myState.hasOwnProperty(k)) myState[k] = Object.create(myState[k]);
                    this.key(k).patch(patch[k]);
                    if (this.eventOutput) this.eventOutput.emit("change", {
                        id: k,
                        value: this.key(k).value()
                    });
                } else this.set(k, patch[k]);
            }
        }
        return this;
    };
    OptionsManager.prototype.setOptions = OptionsManager.prototype.patch;
    OptionsManager.prototype.key = function(key) {
        var result = new OptionsManager(this._value[key]);
        if (!(result._value instanceof Object) || result._value instanceof Array) result._value = {};
        return result;
    };
    OptionsManager.prototype.get = function(key) {
        return this._value[key];
    };
    OptionsManager.prototype.getOptions = OptionsManager.prototype.get;
    OptionsManager.prototype.set = function(key, value) {
        var originalValue = this.get(key);
        this._value[key] = value;
        if (this.eventOutput && value !== originalValue) this.eventOutput.emit("change", {
            id: key,
            value: value
        });
        return this;
    };
    OptionsManager.prototype.value = function() {
        return this._value;
    };
    /* These will be overridden once this.eventOutput is created */
    OptionsManager.prototype.on = function() {
        _createEventOutput.call(this);
        return this.on.apply(this, arguments);
    };
    OptionsManager.prototype.unbind = function() {
        _createEventOutput.call(this);
        return this.unbind.apply(this, arguments);
    };
    OptionsManager.prototype.pipe = function() {
        _createEventOutput.call(this);
        return this.pipe.apply(this, arguments);
    };
    OptionsManager.prototype.unpipe = function() {
        _createEventOutput.call(this);
        return this.unpipe.apply(this, arguments);
    };
    module.exports = OptionsManager;
}.bind(this));

require.register("famous_modules/famous/transform/_git_master/index.js", function(exports, require, module) {
    /**
     * @namespace Matrix
     * 
     * @description 
     *  * A high-performance matrix math library used to calculate 
     *   affine transforms on surfaces and other renderables.
     *   Famous uses 4x4 matrices corresponding directly to
     *   WebKit matrices (column-major order)
     *    
     *    The internal "type" of a Matrix is a 16-long float array in 
     *    row-major order, with:
     *      * elements [0],[1],[2],[4],[5],[6],[8],[9],[10] forming the 3x3
     *          transformation matrix
     *      * elements [12], [13], [14] corresponding to the t_x, t_y, t_z 
     *          affine translation.
     *      * element [15] always set to 1.
     * 
     * Scope: Ideally, none of these functions should be visible below the 
     * component developer level.
     *
     * @static
     * 
     * @name Matrix
     */
    var Transform = {};
    // WARNING: these matrices correspond to WebKit matrices, which are
    //    transposed from their math counterparts
    Transform.precision = 1e-6;
    Transform.identity = [ 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1 ];
    /**
     * Multiply two or more Matrix types to return a Matrix.
     *
     * @name Matrix#multiply4x4
     * @function
     * @param {Transform} a left matrix
     * @param {Transform} b right matrix
     * @returns {Transform} the resulting matrix
     */
    Transform.multiply4x4 = function multiply4x4(a, b) {
        var result = [ a[0] * b[0] + a[4] * b[1] + a[8] * b[2] + a[12] * b[3], a[1] * b[0] + a[5] * b[1] + a[9] * b[2] + a[13] * b[3], a[2] * b[0] + a[6] * b[1] + a[10] * b[2] + a[14] * b[3], a[3] * b[0] + a[7] * b[1] + a[11] * b[2] + a[15] * b[3], a[0] * b[4] + a[4] * b[5] + a[8] * b[6] + a[12] * b[7], a[1] * b[4] + a[5] * b[5] + a[9] * b[6] + a[13] * b[7], a[2] * b[4] + a[6] * b[5] + a[10] * b[6] + a[14] * b[7], a[3] * b[4] + a[7] * b[5] + a[11] * b[6] + a[15] * b[7], a[0] * b[8] + a[4] * b[9] + a[8] * b[10] + a[12] * b[11], a[1] * b[8] + a[5] * b[9] + a[9] * b[10] + a[13] * b[11], a[2] * b[8] + a[6] * b[9] + a[10] * b[10] + a[14] * b[11], a[3] * b[8] + a[7] * b[9] + a[11] * b[10] + a[15] * b[11], a[0] * b[12] + a[4] * b[13] + a[8] * b[14] + a[12] * b[15], a[1] * b[12] + a[5] * b[13] + a[9] * b[14] + a[13] * b[15], a[2] * b[12] + a[6] * b[13] + a[10] * b[14] + a[14] * b[15], a[3] * b[12] + a[7] * b[13] + a[11] * b[14] + a[15] * b[15] ];
        if (arguments.length <= 2) return result; else return multiply4x4.apply(null, [ result ].concat(Array.prototype.slice.call(arguments, 2)));
    };
    /**
     * Fast-multiply two or more Matrix types to return a
     *    Matrix, assuming bottom row on each is [0 0 0 1].
     *    
     * @name Matrix#multiply
     * @function
     * @param {Transform} a left matrix
     * @param {Transform} b right matrix
     * @returns {Transform} the resulting matrix
     */
    Transform.multiply = function multiply(a, b) {
        if (!a || !b) return a || b;
        var result = [ a[0] * b[0] + a[4] * b[1] + a[8] * b[2], a[1] * b[0] + a[5] * b[1] + a[9] * b[2], a[2] * b[0] + a[6] * b[1] + a[10] * b[2], 0, a[0] * b[4] + a[4] * b[5] + a[8] * b[6], a[1] * b[4] + a[5] * b[5] + a[9] * b[6], a[2] * b[4] + a[6] * b[5] + a[10] * b[6], 0, a[0] * b[8] + a[4] * b[9] + a[8] * b[10], a[1] * b[8] + a[5] * b[9] + a[9] * b[10], a[2] * b[8] + a[6] * b[9] + a[10] * b[10], 0, a[0] * b[12] + a[4] * b[13] + a[8] * b[14] + a[12], a[1] * b[12] + a[5] * b[13] + a[9] * b[14] + a[13], a[2] * b[12] + a[6] * b[13] + a[10] * b[14] + a[14], 1 ];
        if (arguments.length <= 2) return result; else return multiply.apply(null, [ result ].concat(Array.prototype.slice.call(arguments, 2)));
    };
    /**
     * Return a Matrix translated by additional amounts in each
     *    dimension. This is equivalent to the result of
     *   
     *    Matrix.multiply(Matrix.translate(t[0], t[1], t[2]), m)
     *    
     * @name Matrix#move
     * @function
     * @param {Transform} m a matrix
     * @param {Array.<number>} t delta vector (array of floats && 
     *    array.length == 2 || 3)
     * @returns {Transform} the resulting translated matrix
     */
    Transform.move = function(m, t) {
        if (!t[2]) t[2] = 0;
        return [ m[0], m[1], m[2], 0, m[4], m[5], m[6], 0, m[8], m[9], m[10], 0, m[12] + t[0], m[13] + t[1], m[14] + t[2], 1 ];
    };
    /**
     * Return a Matrix which represents the result of a transform matrix
     *    applied after a move. This is faster than the equivalent multiply.
     *    This is equivalent to the result of
     *
     *    Matrix.multiply(m, Matrix.translate(t[0], t[1], t[2]))
     * 
     * @name Matrix#moveThen
     * @function
     *
     * @param {Array.number} v vector representing initial movement
     * @param {Transform} m matrix to apply afterwards
     * @returns {Transform} the resulting matrix
     */
    Transform.moveThen = function(v, m) {
        if (!v[2]) v[2] = 0;
        var t0 = v[0] * m[0] + v[1] * m[4] + v[2] * m[8];
        var t1 = v[0] * m[1] + v[1] * m[5] + v[2] * m[9];
        var t2 = v[0] * m[2] + v[1] * m[6] + v[2] * m[10];
        return Transform.move(m, [ t0, t1, t2 ]);
    };
    /**
     * Return a Matrix which represents a translation by specified
     *    amounts in each dimension.
     *    
     * @name Matrix#translate
     * @function
     * @param {number} x x translation (delta_x)
     * @param {number} y y translation (delta_y)
     * @param {number} z z translation (delta_z)
     * @returns {Transform} the resulting matrix
     */
    Transform.translate = function(x, y, z) {
        if (z === undefined) z = 0;
        return [ 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, x, y, z, 1 ];
    };
    /**
     * Return a Matrix which represents a scale by specified amounts
     *    in each dimension.
     *    
     * @name Matrix#scale
     * @function  
     *
     * @param {number} x x scale factor
     * @param {number} y y scale factor
     * @param {number} z z scale factor
     * @returns {Transform} the resulting matrix
     */
    Transform.scale = function(x, y, z) {
        if (z === undefined) z = 1;
        return [ x, 0, 0, 0, 0, y, 0, 0, 0, 0, z, 0, 0, 0, 0, 1 ];
    };
    /**
     * Return a Matrix which represents a specified clockwise
     *    rotation around the x axis.
     *    
     * @name Matrix#rotateX
     * @function
     *
     * @param {number} theta radians
     * @returns {Transform} the resulting matrix
     */
    Transform.rotateX = function(theta) {
        var cosTheta = Math.cos(theta);
        var sinTheta = Math.sin(theta);
        return [ 1, 0, 0, 0, 0, cosTheta, sinTheta, 0, 0, -sinTheta, cosTheta, 0, 0, 0, 0, 1 ];
    };
    /**
     * Return a Matrix which represents a specified clockwise
     *    rotation around the y axis.
     *    
     * @name Matrix#rotateY
     * @function
     *
     * @returns {Transform} the resulting matrix
     */
    Transform.rotateY = function(theta) {
        var cosTheta = Math.cos(theta);
        var sinTheta = Math.sin(theta);
        return [ cosTheta, 0, -sinTheta, 0, 0, 1, 0, 0, sinTheta, 0, cosTheta, 0, 0, 0, 0, 1 ];
    };
    /**
     * Return a Matrix which represents a specified clockwise
     *    rotation around the z axis.
     *    
     * @name Matrix#rotateZ
     * @function
     *
     * @param {number} theta radians
     * @returns {Transform} the resulting matrix
     */
    Transform.rotateZ = function(theta) {
        var cosTheta = Math.cos(theta);
        var sinTheta = Math.sin(theta);
        return [ cosTheta, sinTheta, 0, 0, -sinTheta, cosTheta, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1 ];
    };
    /**
     * Return a Matrix which represents composed clockwise
     *    rotations along each of the axes. Equivalent to the result of
     *    multiply(rotateX(phi), rotateY(theta), rotateZ(psi))
     *    
     * @name Matrix#rotate
     * @function
     *
     * @param {number} phi radians to rotate about the positive x axis
     * @param {number} theta radians to rotate about the positive y axis
     * @param {number} psi radians to rotate about the positive z axis
     * @returns {Transform} the resulting matrix
     */
    Transform.rotate = function(phi, theta, psi) {
        var cosPhi = Math.cos(phi);
        var sinPhi = Math.sin(phi);
        var cosTheta = Math.cos(theta);
        var sinTheta = Math.sin(theta);
        var cosPsi = Math.cos(psi);
        var sinPsi = Math.sin(psi);
        var result = [ cosTheta * cosPsi, cosPhi * sinPsi + sinPhi * sinTheta * cosPsi, sinPhi * sinPsi - cosPhi * sinTheta * cosPsi, 0, -cosTheta * sinPsi, cosPhi * cosPsi - sinPhi * sinTheta * sinPsi, sinPhi * cosPsi + cosPhi * sinTheta * sinPsi, 0, sinTheta, -sinPhi * cosTheta, cosPhi * cosTheta, 0, 0, 0, 0, 1 ];
        return result;
    };
    /**
     * Return a Matrix which represents an axis-angle rotation
     *
     * @name Matrix#rotateAxis
     * @function
     *
     * @param {Array.number} v unit vector representing the axis to rotate about
     * @param {number} theta radians to rotate clockwise about the axis
     * @returns {Transform} the resulting matrix
     */
    Transform.rotateAxis = function(v, theta) {
        var sinTheta = Math.sin(theta);
        var cosTheta = Math.cos(theta);
        var verTheta = 1 - cosTheta;
        // versine of theta
        var xxV = v[0] * v[0] * verTheta;
        var xyV = v[0] * v[1] * verTheta;
        var xzV = v[0] * v[2] * verTheta;
        var yyV = v[1] * v[1] * verTheta;
        var yzV = v[1] * v[2] * verTheta;
        var zzV = v[2] * v[2] * verTheta;
        var xs = v[0] * sinTheta;
        var ys = v[1] * sinTheta;
        var zs = v[2] * sinTheta;
        var result = [ xxV + cosTheta, xyV + zs, xzV - ys, 0, xyV - zs, yyV + cosTheta, yzV + xs, 0, xzV + ys, yzV - xs, zzV + cosTheta, 0, 0, 0, 0, 1 ];
        return result;
    };
    /**
     * Return a Matrix which represents a transform matrix applied about
     * a separate origin point.
     * 
     * @name Matrix#aboutOrigin
     * @function
     *
     * @param {Array.number} v origin point to apply matrix
     * @param {Transform} m matrix to apply
     * @returns {Transform} the resulting matrix
     */
    Transform.aboutOrigin = function(v, m) {
        var t0 = v[0] - (v[0] * m[0] + v[1] * m[4] + v[2] * m[8]);
        var t1 = v[1] - (v[0] * m[1] + v[1] * m[5] + v[2] * m[9]);
        var t2 = v[2] - (v[0] * m[2] + v[1] * m[6] + v[2] * m[10]);
        return Transform.move(m, [ t0, t1, t2 ]);
    };
    /**
     * Return a Matrix's webkit css representation to be used with the
     *    CSS3 -webkit-transform style. 
     * @example: -webkit-transform: matrix3d(1,0,0,0,0,1,0,0,0,0,1,0,716,243,0,1)
     *
     * @name Matrix#formatCSS
     * @function
     * 
     * @param {Transform} m a Famous matrix
     * @returns {string} matrix3d CSS style representation of the transform
     */
    Transform.formatCSS = function(m) {
        var result = "matrix3d(";
        for (var i = 0; i < 15; i++) {
            result += m[i] < 1e-6 && m[i] > -1e-6 ? "0," : m[i] + ",";
        }
        result += m[15] + ")";
        return result;
    };
    /**
     * Return a Matrix representation of a skew transformation
     *
     * @name Matrix#skew
     * @function
     * 
     * @param {number} psi radians skewed about the yz plane
     * @param {number} theta radians skewed about the xz plane
     * @param {number} phi radians skewed about the xy plane
     * @returns {Transform} the resulting matrix
     */
    Transform.skew = function(phi, theta, psi) {
        return [ 1, 0, 0, 0, Math.tan(psi), 1, 0, 0, Math.tan(theta), Math.tan(phi), 1, 0, 0, 0, 0, 1 ];
    };
    /**
     * Returns a perspective matrix
     *
     * @name Matrix#perspective
     * @function
     *
     * @param {number} focusZ z position of focal point
     * @returns {Transform} the resulting matrix
     */
    Transform.perspective = function(focusZ) {
        return [ 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, -1 / focusZ, 0, 0, 0, 1 ];
    };
    /**
     * Return translation vector component of given Matrix
     * 
     * @name Matrix#getTranslate
     * @function
     *
     * @param {Transform} m matrix
     * @returns {Array.<number>} the translation vector [t_x, t_y, t_z]
     */
    Transform.getTranslate = function(m) {
        return [ m[12], m[13], m[14] ];
    };
    /**
     * Return inverse affine matrix for given Matrix. 
     * Note: This assumes m[3] = m[7] = m[11] = 0, and m[15] = 1. 
     *       Incorrect results if not invertable or preconditions not met.
     *
     * @name Matrix#inverse
     * @function
     * 
     * @param {Transform} m matrix
     * @returns {Transform} the resulting inverted matrix
     */
    Transform.inverse = function(m) {
        var result = [ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1 ];
        // only need to consider 3x3 section for affine
        var c0 = m[5] * m[10] - m[6] * m[9];
        var c1 = m[4] * m[10] - m[6] * m[8];
        var c2 = m[4] * m[9] - m[5] * m[8];
        var c4 = m[1] * m[10] - m[2] * m[9];
        var c5 = m[0] * m[10] - m[2] * m[8];
        var c6 = m[0] * m[9] - m[1] * m[8];
        var c8 = m[1] * m[6] - m[2] * m[5];
        var c9 = m[0] * m[6] - m[2] * m[4];
        var c10 = m[0] * m[5] - m[1] * m[4];
        var detM = m[0] * c0 - m[1] * c1 + m[2] * c2;
        var invD = 1 / detM;
        var result = [ invD * c0, -invD * c4, invD * c8, 0, -invD * c1, invD * c5, -invD * c9, 0, invD * c2, -invD * c6, invD * c10, 0, 0, 0, 0, 1 ];
        result[12] = -m[12] * result[0] - m[13] * result[4] - m[14] * result[8];
        result[13] = -m[12] * result[1] - m[13] * result[5] - m[14] * result[9];
        result[14] = -m[12] * result[2] - m[13] * result[6] - m[14] * result[10];
        return result;
    };
    /**
     * Returns the transpose of a 4x4 matrix
     *
     * @name Matrix#inverse
     * @function
     * 
     * @param {Transform} m matrix
     * @returns {Transform} the resulting transposed matrix
     */
    Transform.transpose = function(m) {
        return [ m[0], m[4], m[8], m[12], m[1], m[5], m[9], m[13], m[2], m[6], m[10], m[14], m[3], m[7], m[11], m[15] ];
    };
    /**
     * Decompose Matrix into separate .translate, .rotate, .scale,
     *    .skew components.
     *    
     * @name Matrix#interpret
     * @function
     *
     * @param {Matrix} M matrix
     * @returns {matrixSpec} object with component matrices .translate,
     *    .rotate, .scale, .skew
     */
    function _normSquared(v) {
        return v.length === 2 ? v[0] * v[0] + v[1] * v[1] : v[0] * v[0] + v[1] * v[1] + v[2] * v[2];
    }
    function _norm(v) {
        return Math.sqrt(_normSquared(v));
    }
    function _sign(n) {
        return n < 0 ? -1 : 1;
    }
    Transform.interpret = function(M) {
        // QR decomposition via Householder reflections
        //FIRST ITERATION
        //default Q1 to the identity matrix;
        var x = [ M[0], M[1], M[2] ];
        // first column vector
        var sgn = _sign(x[0]);
        // sign of first component of x (for stability)
        var xNorm = _norm(x);
        // norm of first column vector
        var v = [ x[0] + sgn * xNorm, x[1], x[2] ];
        // v = x + sign(x[0])|x|e1
        var mult = 2 / _normSquared(v);
        // mult = 2/v'v
        //bail out if our Matrix is singular
        if (mult >= Infinity) {
            return {
                translate: Transform.getTranslate(M),
                rotate: [ 0, 0, 0 ],
                scale: [ 0, 0, 0 ],
                skew: [ 0, 0, 0 ]
            };
        }
        //evaluate Q1 = I - 2vv'/v'v
        var Q1 = [ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1 ];
        //diagonals
        Q1[0] = 1 - mult * v[0] * v[0];
        // 0,0 entry
        Q1[5] = 1 - mult * v[1] * v[1];
        // 1,1 entry
        Q1[10] = 1 - mult * v[2] * v[2];
        // 2,2 entry
        //upper diagonal
        Q1[1] = -mult * v[0] * v[1];
        // 0,1 entry
        Q1[2] = -mult * v[0] * v[2];
        // 0,2 entry
        Q1[6] = -mult * v[1] * v[2];
        // 1,2 entry
        //lower diagonal
        Q1[4] = Q1[1];
        // 1,0 entry
        Q1[8] = Q1[2];
        // 2,0 entry
        Q1[9] = Q1[6];
        // 2,1 entry
        //reduce first column of M
        var MQ1 = Transform.multiply(Q1, M);
        //SECOND ITERATION on (1,1) minor
        var x2 = [ MQ1[5], MQ1[6] ];
        var sgn2 = _sign(x2[0]);
        // sign of first component of x (for stability)
        var x2Norm = _norm(x2);
        // norm of first column vector
        var v2 = [ x2[0] + sgn2 * x2Norm, x2[1] ];
        // v = x + sign(x[0])|x|e1
        var mult2 = 2 / _normSquared(v2);
        // mult = 2/v'v
        //evaluate Q2 = I - 2vv'/v'v
        var Q2 = [ 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1 ];
        //diagonal
        Q2[5] = 1 - mult2 * v2[0] * v2[0];
        // 1,1 entry
        Q2[10] = 1 - mult2 * v2[1] * v2[1];
        // 2,2 entry
        //off diagonals
        Q2[6] = -mult2 * v2[0] * v2[1];
        // 2,1 entry
        Q2[9] = Q2[6];
        // 1,2 entry
        //calc QR decomposition. Q = Q1*Q2, R = Q'*M
        var Q = Transform.multiply(Q2, Q1);
        //note: really Q transpose
        var R = Transform.multiply(Q, M);
        //remove negative scaling
        var remover = Transform.scale(R[0] < 0 ? -1 : 1, R[5] < 0 ? -1 : 1, R[10] < 0 ? -1 : 1);
        R = Transform.multiply(R, remover);
        Q = Transform.multiply(remover, Q);
        //decompose into rotate/scale/skew matrices
        var result = {};
        result.translate = Transform.getTranslate(M);
        result.rotate = [ Math.atan2(-Q[6], Q[10]), Math.asin(Q[2]), Math.atan2(-Q[1], Q[0]) ];
        if (!result.rotate[0]) {
            result.rotate[0] = 0;
            result.rotate[2] = Math.atan2(Q[4], Q[5]);
        }
        result.scale = [ R[0], R[5], R[10] ];
        result.skew = [ Math.atan2(R[9], result.scale[2]), Math.atan2(R[8], result.scale[2]), Math.atan2(R[4], result.scale[0]) ];
        //double rotation workaround
        if (Math.abs(result.rotate[0]) + Math.abs(result.rotate[2]) > 1.5 * Math.PI) {
            result.rotate[1] = Math.PI - result.rotate[1];
            if (result.rotate[1] > Math.PI) result.rotate[1] -= 2 * Math.PI;
            if (result.rotate[1] < -Math.PI) result.rotate[1] += 2 * Math.PI;
            if (result.rotate[0] < 0) result.rotate[0] += Math.PI; else result.rotate[0] -= Math.PI;
            if (result.rotate[2] < 0) result.rotate[2] += Math.PI; else result.rotate[2] -= Math.PI;
        }
        return result;
    };
    /**
     * Weighted average between two matrices by averaging their
     *     translation, rotation, scale, skew components.
     *     f(M1,M2,t) = (1 - t) * M1 + t * M2
     *
     * @name Matrix#average
     * @function
     *
     * @param {Transform} M1 f(M1,M2,0) = M1
     * @param {Transform} M2 f(M1,M2,1) = M2
     * @param {number} t
     * @returns {Transform}
     */
    Transform.average = function(M1, M2, t) {
        t = t === undefined ? .5 : t;
        var specM1 = Transform.interpret(M1);
        var specM2 = Transform.interpret(M2);
        var specAvg = {
            translate: [ 0, 0, 0 ],
            rotate: [ 0, 0, 0 ],
            scale: [ 0, 0, 0 ],
            skew: [ 0, 0, 0 ]
        };
        for (var i = 0; i < 3; i++) {
            specAvg.translate[i] = (1 - t) * specM1.translate[i] + t * specM2.translate[i];
            specAvg.rotate[i] = (1 - t) * specM1.rotate[i] + t * specM2.rotate[i];
            specAvg.scale[i] = (1 - t) * specM1.scale[i] + t * specM2.scale[i];
            specAvg.skew[i] = (1 - t) * specM1.skew[i] + t * specM2.skew[i];
        }
        return Transform.build(specAvg);
    };
    /**
     * Compose .translate, .rotate, .scale, .skew components into into
     *    Matrix
     *    
     * @name Matrix#build
     * @function
     *
     * @param {matrixSpec} spec object with component matrices .translate,
     *    .rotate, .scale, .skew
     * @returns {Transform} composed martix
     */
    Transform.build = function(spec) {
        var scaleMatrix = Transform.scale(spec.scale[0], spec.scale[1], spec.scale[2]);
        var skewMatrix = Transform.skew(spec.skew[0], spec.skew[1], spec.skew[2]);
        var rotateMatrix = Transform.rotate(spec.rotate[0], spec.rotate[1], spec.rotate[2]);
        return Transform.move(Transform.multiply(rotateMatrix, skewMatrix, scaleMatrix), spec.translate);
    };
    /**
     * Determine if two affine Transforms are component-wise equal
     * Warning: breaks on perspective Transforms
     * 
     * @name Transform#equals
     * @function
     * 
     * @param {Transform} a matrix
     * @param {Transform} b matrix
     * @returns {boolean} 
     */
    Transform.equals = function(a, b) {
        return !Transform.notEquals(a, b);
    };
    /**
     * Determine if two affine Transforms are component-wise unequal
     * Warning: breaks on perspective Transforms
     *
     * @name Transform#notEquals
     * @name function
     *
     * @param {Transform} a matrix
     * @param {Transform} b matrix
     * @returns {boolean} 
     */
    Transform.notEquals = function(a, b) {
        if (a === b) return false;
        if (!(a && b)) return true;
        // shortci
        return !(a && b) || a[12] !== b[12] || a[13] !== b[13] || a[14] !== b[14] || a[0] !== b[0] || a[1] !== b[1] || a[2] !== b[2] || a[4] !== b[4] || a[5] !== b[5] || a[6] !== b[6] || a[8] !== b[8] || a[9] !== b[9] || a[10] !== b[10];
    };
    /**
     * Constrain angle-trio components to range of [-pi, pi).
     *
     * @name Matrix#normalizeRotation
     * @function
     * 
     * @param {Array.<number>} rotation phi, theta, psi (array of floats 
     *    && array.length == 3)
     * @returns {Array.<number>} new phi, theta, psi triplet
     *    (array of floats && array.length == 3)
     */
    Transform.normalizeRotation = function(rotation) {
        var result = rotation.slice(0);
        if (result[0] == Math.PI / 2 || result[0] == -Math.PI / 2) {
            result[0] = -result[0];
            result[1] = Math.PI - result[1];
            result[2] -= Math.PI;
        }
        if (result[0] > Math.PI / 2) {
            result[0] = result[0] - Math.PI;
            result[1] = Math.PI - result[1];
            result[2] -= Math.PI;
        }
        if (result[0] < -Math.PI / 2) {
            result[0] = result[0] + Math.PI;
            result[1] = -Math.PI - result[1];
            result[2] -= Math.PI;
        }
        while (result[1] < -Math.PI) result[1] += 2 * Math.PI;
        while (result[1] >= Math.PI) result[1] -= 2 * Math.PI;
        while (result[2] < -Math.PI) result[2] += 2 * Math.PI;
        while (result[2] >= Math.PI) result[2] -= 2 * Math.PI;
        return result;
    };
    module.exports = Transform;
}.bind(this));

require.register("app/models/call-collection.js", function(exports, require, module) {
    // Import app specific dependencies
    var Call = require("call");
    module.exports = Backbone.Collection.extend({
        localStorage: new Backbone.LocalStorage("colabeo-call-collection"),
        model: Call,
        missed: function() {
            return this.filter(function(item) {
                return item.isMissed();
            });
        },
        all: function() {
            return this.filter(function(item) {
                return true;
            });
        },
        comparator: function(model) {
            return -1 * model.get("time");
        }
    });
}.bind(this));

require.register("app/models/call.js", function(exports, require, module) {
    module.exports = Backbone.Model.extend({
        defaults: {
            firstname: "John",
            lastname: "Doe",
            email: "",
            pictureUrl: "",
            cid: "testcid"
        },
        isMissed: function() {
            return !this.get("success") && this.get("type") == "incoming";
        }
    });
}.bind(this));

require.register("app/models/chat-collection.js", function(exports, require, module) {
    // Import app specific dependencies
    var Conversation = require("conversation");
    module.exports = Backbone.Firebase.Collection.extend({
        model: Conversation,
        comparator: function(model) {
            return 1 * model.get("time");
        }
    });
}.bind(this));

require.register("app/models/contact-collection.js", function(exports, require, module) {
    // Import app specific dependencies
    var Contact = require("contact");
    module.exports = Backbone.Firebase.Collection.extend({
        model: Contact,
        favorites: function() {
            return this.filter(function(item) {
                return item.get("favorite");
            });
        },
        searchContact: function(keyword) {
            return this.filter(function(item) {
                if (item.get("firstname").toUpperCase().indexOf(keyword) != -1 || item.get("lastname").toUpperCase().indexOf(keyword) != -1) return item.get("firstname");
            });
        },
        searchContactByEmail: function(keyword) {
            return this.filter(function(item) {
                if (item.get("email").toUpperCase().indexOf(keyword) != -1) {
                    return item.get("email");
                }
            });
        },
        lastnameInitial: function(keyword) {
            return this.filter(function(item) {
                var firstChar;
                if (item.get("lastname")) {
                    firstChar = isEnglish(item.get("lastname")) ? item.get("lastname")[0].toUpperCase() : "#";
                    return firstChar == keyword;
                } else if (item.get("firstname")) {
                    firstChar = isEnglish(item.get("firstname")) ? item.get("firstname")[0].toUpperCase() : "#";
                    return firstChar == keyword;
                } else if (item.get("email")) {
                    firstChar = isEnglish(item.get("email")) ? item.get("email")[0].toUpperCase() : "#";
                    return firstChar == keyword;
                }
            });
            function isEnglish(words) {
                return /^[a-zA-Z]+$/.test(words[0]);
            }
        },
        comparator: function(model) {
            var l = model.get("lastname");
            var f = model.get("firstname");
            if (!/^[a-zA-Z]+$/.test(l[0])) l = "zzzz" + l;
            return (l + " " + f).toUpperCase();
        }
    });
}.bind(this));

require.register("app/models/contact.js", function(exports, require, module) {
    // Generic Backbone Model
    module.exports = Backbone.Model.extend({
        whiteList: [ "email", "firstname", "lastname", "id", "cid", "dcr", "favorite", "phone", "facebook", "google", "linkedin", "github", "twitter" ],
        toJSON: function(options) {
            return _.pick(this.attributes, this.whiteList);
        },
        toggleFavorite: function() {
            this.set({
                favorite: !this.get("favorite")
            });
        }
    });
}.bind(this));

require.register("app/models/conversation-collection.js", function(exports, require, module) {
    //Import app specific dependencies
    var Conversation = require("conversation");
    module.exports = Backbone.Collection.extend({
        localStorage: new Backbone.LocalStorage("colabeo-chat-colection"),
        model: Conversation,
        comparator: function(model) {
            return 1 * model.get("time");
        }
    });
}.bind(this));

require.register("app/models/conversation.js", function(exports, require, module) {
    module.exports = Backbone.Model.extend({
        defaults: {
            content: "",
            type: "text",
            time: "",
            source: "",
            from: ""
        },
        isLocal: function() {
            return this.get("source") == "local" || this.get("from") == window._cola_g.cid;
        }
    });
}.bind(this));

require.register("app/models/index.js", function(exports, require, module) {
    module.exports = {
        Call: require("call"),
        //    CallCollection: require("call-collection"),
        RecentsCollection: require("recents-collection"),
        Contact: require("contact"),
        ContactCollection: require("contact-collection"),
        Conversation: require("conversation"),
        ConversationCollection: require("conversation-collection"),
        ChatCollection: require("chat-collection"),
        Settings: require("settings"),
        SocialContactCollection: require("social-contact-collection")
    };
}.bind(this));

require.register("app/models/recents-collection.js", function(exports, require, module) {
    // Import app specific dependencies
    var Call = require("call");
    module.exports = Backbone.Firebase.Collection.extend({
        model: Call,
        missed: function() {
            return this.filter(function(item) {
                return item.isMissed();
            });
        },
        all: function() {
            return this.filter(function(item) {
                return true;
            });
        },
        comparator: function(model) {
            return -1 * model.get("time");
        },
        getUnreadCount: function() {
            return this.filter(function(item) {
                return !item.get("read");
            }).length;
        }
    });
}.bind(this));

require.register("app/models/settings.js", function(exports, require, module) {
    // Generic Backbone Model
    module.exports = Backbone.Model.extend({
        // if url changed, need new name for the localstorage
        localStorage: new Backbone.LocalStorage("colabeo-settings-1"),
        defaults: {
            cid: "default",
            email: "default@colabeo.com",
            linkAccounts: {
                facebook: false,
                google: false,
                linkedin: false,
                github: false,
                yammer: false
            },
            firstname: "John",
            lastname: "Colabeo",
            notification: false,
            camera: true,
            video: true,
            audio: true,
            blur: undefined,
            firebaseUrl: "https://colabeo.firebaseio.com/",
            pHost: "dashboard.colabeo.com",
            pPort: 9e3,
            pSecure: true
        }
    });
}.bind(this));

require.register("app/models/social-contact-collection.js", function(exports, require, module) {
    var Contact = require("contact");
    module.exports = Backbone.Collection.extend({
        model: Contact,
        parse: function(response) {
            var n = response.map(function(item) {
                if (!item.firstname) {
                    var names = item.name.split(" ");
                    item.lastname = names.pop();
                    item.firstname = names.join(" ");
                }
                return item;
            });
            return n;
        },
        searchContact: function(keyword) {
            return this.filter(function(item) {
                if (item.get("firstname").toUpperCase().indexOf(keyword) != -1 || item.get("lastname").toUpperCase().indexOf(keyword) != -1) return item.get("firstname");
            });
        },
        comparator: function(model) {
            var l = model.get("lastname");
            var f = model.get("firstname");
            if (!/^[a-zA-Z]+$/.test(l[0])) l = "zzzz" + l;
            return (l + " " + f).toUpperCase();
        }
    });
}.bind(this));

require.register("app/vendor/index.js", function(exports, require, module) {
    require("zepto");
    window.$ = Zepto;
    window._ = require("underscore");
    window.Backbone = require("backbone");
    window.Backbone.$ = Zepto;
    require("handlebars");
    require("backbone.localStorage");
    require("firebase");
    require("backbone-firebase");
    require("peer");
    require("notify");
    require("oauthpopup");
}.bind(this));

require.register("app/vendor/att.js", function(exports, require, module) {
    (function() {
        function n() {
            this.callbacks = {};
        }
        function o(o) {
            var e = this, t = o || {}, i = this.config = {
                apiKey: "",
                user: a.uuid(),
                jid: "",
                log: !0,
                ringTone: "",
                ringbackTone: "",
                dependencyBaseUrl: "//js.att.io"
            }, r = {
                onReady: "ready",
                onUnReady: "unready",
                onError: "error",
                onCallBegin: "callBegin",
                onCallEnd: "callEnd",
                onOutgoingCall: "outgoingCall",
                onCalling: "calling"
            }, l = {
                onError: "error",
                onCallBegin: "callBegin",
                onCallEnd: "callEnd"
            }, c = function() {
                return a.isFunc(o.onIncomingCall) ? o.onIncomingCall : o.phone && a.isFunc(o.phone.onIncomingCall) ? o.phone.onIncomingCall : function() {};
            }();
            return n.call(this), a.extend(this.config, t), this.config.incomingCallHandler = c, 
            delete this.config.onIncomingCall, this.config.phone && delete this.config.phone.onIncomingCall, 
            this.phone = this, this.on("incomingCall", c), a.each(r, function(n, o) {
                a.isFunc(e.config[n]) && (e.on(o, e.config[n]), e.config[n] = function(n) {
                    e.emit(o, n);
                });
            }), t.phone && a.each(l, function(n, o) {
                a.isFunc(e.config.phone[n]) && (e.on(o, e.config.phone[n]), e.config.phone[n] = function(n) {
                    e.emit(o, n);
                });
            }), this.config.log && this.on("*", function(n, o) {
                console.log("att.js event:", n, o);
            }), a.getMe(this.config.apiKey, function(n) {
                n.version = i.version || a.getQueryParam("version") || n.version, i.version = n.version, 
                i.myNumber = n.number, console.log("using API version:", i.version), e.emit("user", n), 
                "a1" === i.version || "a2" === i.version ? $.getScript(i.dependencyBaseUrl + "/js/att." + i.version + ".js", function() {
                    e.fetchDependencies(i.version);
                }) : $.getScript(i.dependencyBaseUrl + "/js/phono.06.js", function() {
                    i.token = i.apiKey, i.apiKey = "7826110523f1241fcfd001859a67128d", i.connectionUrl = "http://gw.att.io:8080/http-bind", 
                    e.fetchDependencies();
                });
            }), e;
        }
        function e(o, e) {
            var t = this;
            return this._att = o, this._call = e, this.id = e.id, n.call(this), this.on("*", function(n) {
                t._att.emit(n, t);
            }), this._call.bind({
                onRing: function() {
                    t.emit("ring");
                },
                onAnswer: function() {
                    t.emit("callBegin");
                },
                onHangup: function() {
                    t.emit("callEnd");
                },
                onHold: function() {
                    t.emit("hold");
                },
                onRetrieve: function() {
                    t.emit("retrieve");
                },
                onWaiting: function() {
                    t.emit("waiting");
                },
                onError: function() {
                    t.emit("error");
                }
            }), this;
        }
        var t = this, i = {}, r = {}, a = i.util = {
            _uuidCounter: 0,
            uuid: function() {
                return Math.random().toString(16).substring(2) + (a._uuidCounter++).toString(16);
            },
            slice: Array.prototype.slice,
            isFunc: function(n) {
                return "[object Function]" == Object.prototype.toString.call(n);
            },
            extend: function(n) {
                return this.slice.call(arguments, 1).forEach(function(o) {
                    if (o) for (var e in o) n[e] = o[e];
                }), n;
            },
            each: function(n, o) {
                if (n) if (n instanceof Array) n.forEach(o); else for (var e in n) o(e, n[e]);
            },
            getQueryParam: function(n) {
                var o = n.replace(/[\[]/, "\\[").replace(/[\]]/, "\\]"), e = "[\\?&]" + o + "=([^&#]*)", t = RegExp(e), i = t.exec(window.location.search);
                return i ? decodeURIComponent(i[1].replace(/\+/g, " ")) : void 0;
            },
            h2sSupport: function() {
                return "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_8_2) AppleWebKit/536.4 (KHTML, like Gecko) Chrome/19.0.1077.0 Safari/536.4" == window.navigator.userAgent || "Mozilla/5.0 (iPhone; CPU iPhone OS 6_0_1 like Mac OS X) AppleWebKit/536.26 (KHTML, like Gecko) Mobile/10A523" == window.navigator.userAgent || window.webkitPeerConnection00 && -1 !== window.navigator.userAgent.indexOf("Chrome/24");
            },
            getMe: function(n, o) {
                var e = "https://auth.tfoundry.com", t = {
                    access_token: n
                };
                return r.me ? o(r.me) : (console.log(t), $.ajax({
                    data: t,
                    dataType: "json",
                    url: e + "/me.json",
                    success: function(n) {
                        r.me = n, $.ajax({
                            data: t,
                            dataType: "json",
                            url: e + "/users/" + n.uid + "/api_services/webrtc.json",
                            success: function(e) {
                                var t = e && e.version, i = e && e.options && e.options.phone_number;
                                n.version = t ? "a" + t : "a1", n.number = i || n.phone_number, o(n);
                            }
                        });
                    }
                }), void 0);
            }
        }, l = {};
        l.stringify = function(n) {
            var o, e = l.parse(n), t = e.length, i = "1" === e.charAt(0), r = e.split("");
            return t > (i ? 11 : 10) ? e : !i && 4 > t ? e : (i && r.splice(0, 1), i ? t > 1 && (o = 4 - t, 
            o = o > 0 ? o : 0, r.splice(0, 0, " ("), r.splice(4, 0, Array(o + 1).join(" ") + ") "), 
            t > 7 && r.splice(8, 0, "-")) : t > 7 ? (r.splice(0, 0, "("), r.splice(4, 0, ") "), 
            r.splice(8, 0, "-")) : t > 3 && r.splice(3, 0, "-"), (i ? "1" : "") + r.join(""));
        }, l.parse = function(n) {
            return (n + "").toUpperCase().replace(/[A-Z]/g, function(n) {
                return 0 | (n.charCodeAt(0) - 65) / 3 + 2 - ("SVYZ".indexOf(n) > -1);
            }).replace(/\D/g, "");
        }, l.getCallable = function(n, o) {
            var e = o || "us", t = l.parse(n);
            return 10 !== t.length ? "us" == e && 11 === t.length && "1" === t.charAt(0) ? t : !1 : "us" == e ? "1" + t : void 0;
        }, i.phoneNumber = l, n.prototype.on = function(n) {
            var o = 3 === arguments.length, e = o ? arguments[1] : void 0, t = o ? arguments[2] : arguments[1];
            return t._groupName = e, (this.callbacks[n] = this.callbacks[n] || []).push(t), 
            this;
        }, n.prototype.once = function(n, o) {
            function e() {
                t.off(n, e), o.apply(this, arguments);
            }
            var t = this;
            return this.on(n, e), this;
        }, n.prototype.releaseGroup = function(n) {
            var o, e, t, i;
            for (o in this.callbacks) for (i = this.callbacks[o], e = 0, t = i.length; t > e; e++) i[e]._groupName === n && (i.splice(e, 1), 
            e--, t--);
            return this;
        }, n.prototype.off = function(n, o) {
            var e, t = this.callbacks[n];
            return t ? 1 === arguments.length ? (delete this.callbacks[n], this) : (e = t.indexOf(o), 
            t.splice(e, 1), this) : this;
        }, n.prototype.emit = function(n) {
            var o, e, t = [].slice.call(arguments, 1), i = this.callbacks[n], r = this.getWildcardCallbacks(n);
            if (i) for (o = 0, e = i.length; e > o; ++o) i[o].apply(this, t);
            if (r) for (o = 0, e = r.length; e > o; ++o) r[o].apply(this, [ n ].concat(t));
            return this;
        }, n.prototype.getWildcardCallbacks = function(n) {
            var o, e, t = [];
            for (o in this.callbacks) e = o.split("*"), ("*" === o || 2 === e.length && n.slice(0, e[1].length) === e[1]) && (t = t.concat(this.callbacks[o]));
            return t;
        }, o.prototype = new n(), o.prototype.fetchDependencies = function(n) {
            var o = this, e = this.config;
            "a1" === n ? a.h2sSupport() ? (console.log("setting up wcgphono"), this.phono = $.wcgphono(a.extend(e, {
                phone: {
                    onIncomingCall: o._normalizeNonPhonoCallHandlers.bind(o)
                },
                onReady: function() {
                    o.emit("ready");
                }
            }))) : alert("Please use the special Ericsson build of Chromium. It can be downloaded from: http://js.att.io/browsers") : "a2" === n ? a.h2sSupport() ? (console.log("setting up h2sphono"), 
            this.phono = $.h2sphono(a.extend(e, {
                phone: {
                    onIncomingCall: o._normalizeNonPhonoCallHandlers.bind(o)
                },
                onReady: function() {
                    o.emit("ready");
                }
            }))) : alert("Please use the special Ericsson build of Chromium. It can be downloaded from: http://js.att.io/browsers") : (console.log("setting up phono"), 
            this.phono = $.phono(a.extend(e, {
                phone: {
                    onIncomingCall: o._normalizeNonPhonoCallHandlers.bind(o),
                    ringTone: "",
                    ringbackTone: ""
                },
                onReady: function() {
                    o.sessionId = this.sessionId, a.getMe(e.apiKey, function(n) {
                        o.bindNumberToPhonoSession(n.number, o.sessionId, function() {
                            o.emit("ready");
                        });
                    });
                }
            })));
        }, o.prototype.bindNumberToPhonoSession = function(n, o, e) {
            $.ajax({
                url: "http://binder.api.tfoundry.com/session/" + n + "/" + o,
                type: "POST",
                success: function() {
                    e();
                }
            });
        }, o.prototype.disconnect = function() {
            this.phono.disconnect(), this.phono = null;
        }, o.prototype.connected = function() {
            return !!this.phono;
        }, o.prototype._normalizeNonPhonoCallHandlers = function(n) {
            var o, t, r = n.call;
            r && (o = new e(this, r), t = o.initiator || o._call.recipient || "", t = t.replace("tel:", "").replace("sip:", ""), 
            t = t.split("@")[0], o.call = o, this.emit("incomingCall", o, i.phoneNumber.parse(t)));
        }, o.prototype.dial = function(n, o) {
            var t, r, a = this, l = i.phoneNumber.getCallable(n);
            return this.emit("calling", n), t = "a3" === this.config.version ? this.phono.phone.dial("sip:" + l + "@12.208.176.26", {
                callerId: a.config.myNumber + "@phono06.tfoundry.com"
            }) : this.phono.phone.dial(l, {}), r = new e(this, t), r.bind(o), r.emit("ring"), 
            this.emit("outgoingCall", r), r;
        }, e.prototype = new n(), e.prototype.bind = function(n) {
            var o = this, e = {
                onRing: "ring",
                onAnswer: "callBegin",
                onHangup: "callEnd",
                onHold: "hold",
                onRetrieve: "retrieve",
                onWaiting: "waiting",
                onError: "error"
            }, t = n || {};
            this._att, a.each(e, function(n, e) {
                a.isFunc(t[n]) && o.on(e, t[n]);
            });
        }, e.prototype.answer = function() {
            return this._call.answer();
        }, e.prototype.hangup = function() {
            return this._call.hangup();
        }, e.prototype.digit = function(n) {
            return this._call.digit(n);
        }, e.prototype.pushToTalk = function(n) {
            return this._call.pushToTalk(n);
        }, e.prototype.talking = function(n) {
            return this._call.talking(n);
        }, e.prototype.mute = function(n) {
            return this._call.mute(n);
        }, e.prototype.hold = function(n) {
            return this._call.hold(n);
        }, e.prototype.volume = function(n) {
            return this._call.volume(n);
        }, e.prototype.gain = function(n) {
            return this._call.gain(n);
        }, e.prototype.__defineGetter__("initiator", function() {
            return this._call.initiator;
        }), e.prototype.transferto = function(n) {
            var o = i.phoneNumber.getCallable(n);
            this._call.transferto(o);
        }, i.Phone = o, t.jQuery && (t.jQuery.att = function(n) {
            return new o(n);
        }), "undefined" != typeof exports ? module.exports = i : (t.ATT || (t.ATT = {}), 
        a.extend(t.ATT, i));
    }).call(this);
}.bind(this));

require.register("app/vendor/backbone-firebase.js", function(exports, require, module) {
    /**
     * Backbone Firebase Adapter.
     */
    "use strict";
    (function() {
        var _ = window._;
        var Backbone = window.Backbone;
        Backbone.Firebase = function(ref) {
            this._fbref = ref;
            this._children = [];
            if (typeof ref == "string") {
                this._fbref = new Firebase(ref);
            }
            this._fbref.on("child_added", this._childAdded, this);
            this._fbref.on("child_moved", this._childMoved, this);
            this._fbref.on("child_changed", this._childChanged, this);
            this._fbref.on("child_removed", this._childRemoved, this);
        };
        _.extend(Backbone.Firebase.prototype, {
            _childAdded: function(childSnap, prevChild) {
                var model = childSnap.val();
                model.id = childSnap.name();
                if (prevChild) {
                    var item = _.find(this._children, function(child) {
                        return child.id == prevChild;
                    });
                    this._children.splice(this._children.indexOf(item) + 1, 0, model);
                } else {
                    this._children.unshift(model);
                }
            },
            _childMoved: function(childSnap, prevChild) {
                var model = childSnap.val();
                this._children = _.reject(this._children, function(child) {
                    return child.id == model.id;
                });
                this._childAdded(childSnap, prevChild);
            },
            _childChanged: function(childSnap) {
                var model = childSnap.val();
                model.id = childSnap.name();
                var item = _.find(this._children, function(child) {
                    return child.id == model.id;
                });
                this._children[this._children.indexOf(item)] = model;
            },
            _childRemoved: function(oldChildSnap) {
                var model = oldChildSnap.val();
                this._children = _.reject(this._children, function(child) {
                    return child.id == model.id;
                });
            },
            create: function(model, cb) {
                if (!model.id) {
                    model.id = this._fbref.ref().push().name();
                }
                var val = model.toJSON();
                this._fbref.ref().child(model.id).set(val, _.bind(function(err) {
                    if (!err) {
                        cb(null, val);
                    } else {
                        cb("Could not create model " + model.id);
                    }
                }, this));
            },
            read: function(model, cb) {
                if (!model.id) {
                    _.defer(cb, "Invalid model ID provided to read");
                    return;
                }
                var index = _.find(this._children, function(child) {
                    return child.id == model.id;
                });
                _.defer(cb, null, this._children[index]);
            },
            readAll: function(model, cb) {
                _.defer(cb, null, this._children);
            },
            update: function(model, cb) {
                var val = model.toJSON();
                this._fbref.ref().child(model.id).update(val, function(err) {
                    if (!err) {
                        cb(null, val);
                    } else {
                        cb("Could not update model " + model.id, null);
                    }
                });
            },
            "delete": function(model, cb) {
                this._fbref.ref().child(model.id).remove(function(err) {
                    if (!err) {
                        cb(null, model);
                    } else {
                        cb("Could not delete model " + model.id);
                    }
                });
            },
            ref: function() {
                return this._fbref;
            }
        });
        Backbone.Firebase.sync = function(method, model, options, error) {
            var store = model.firebase || model.collection.firebase;
            // Backwards compatibility with Backbone <= 0.3.3
            if (typeof options == "function") {
                options = {
                    success: options,
                    error: error
                };
            }
            if (method == "read" && model.id === undefined) {
                method = "readAll";
            }
            store[method].apply(store, [ model, function(err, val) {
                if (err) {
                    model.trigger("error", model, err, options);
                    if (Backbone.VERSION === "0.9.10") {
                        options.error(model, err, options);
                    } else {
                        options.error(err);
                    }
                } else {
                    model.trigger("sync", model, val, options);
                    if (Backbone.VERSION === "0.9.10") {
                        options.success(model, val, options);
                    } else {
                        options.success(val);
                    }
                }
            } ]);
        };
        Backbone.oldSync = Backbone.sync;
        // Override "Backbone.sync" to default to Firebase sync.
        // the original "Backbone.sync" is still available in "Backbone.oldSync"
        Backbone.sync = function(method, model, options, error) {
            var syncMethod = Backbone.oldSync;
            if (model.firebase || model.collection && model.collection.firebase) {
                syncMethod = Backbone.Firebase.sync;
            }
            return syncMethod.apply(this, [ method, model, options, error ]);
        };
        // Custom Firebase Collection.
        Backbone.Firebase.Collection = Backbone.Collection.extend({
            sync: function() {
                this._log("Sync called on a Firebase collection, ignoring.");
            },
            fetch: function() {
                this._log("Fetch called on a Firebase collection, ignoring.");
            },
            constructor: function(models, options) {
                // Apply parent constructor (this will also call initialize).
                Backbone.Collection.apply(this, arguments);
                if (options && options.firebase) {
                    this.firebase = options.firebase;
                }
                switch (typeof this.firebase) {
                  case "object":
                    break;

                  case "string":
                    this.firebase = new Firebase(this.firebase);
                    break;

                  case "function":
                    this.firebase = this.firebase();
                    break;

                  default:
                    throw new Error("Invalid firebase reference created");
                }
                // Add handlers for remote events.
                this.firebase.on("child_added", _.bind(this._childAdded, this));
                this.firebase.on("child_moved", _.bind(this._childMoved, this));
                this.firebase.on("child_changed", _.bind(this._childChanged, this));
                this.firebase.on("child_removed", _.bind(this._childRemoved, this));
                // Once handler to emit "sync" event.
                this.firebase.once("value", _.bind(function() {
                    this.trigger("sync", this, null, null);
                }, this));
                // Handle changes in any local models.
                this.listenTo(this, "change", this._updateModel, this);
                // Listen for destroy event to remove models.
                this.listenTo(this, "destroy", this._removeModel, this);
                // Don't suppress local events by default.
                this._suppressEvent = false;
            },
            comparator: function(model) {
                return model.id;
            },
            add: function(models, options) {
                var parsed = this._parseModels(models);
                options = options ? _.clone(options) : {};
                options.success = _.isFunction(options.success) ? options.success : function() {};
                for (var i = 0; i < parsed.length; i++) {
                    var model = parsed[i];
                    var childRef = this.firebase.ref().child(model.id);
                    if (options.silent === true) {
                        this._suppressEvent = true;
                    }
                    childRef.set(model, _.bind(options.success, model));
                }
                return parsed;
            },
            remove: function(models, options) {
                var parsed = this._parseModels(models);
                options = options ? _.clone(options) : {};
                options.success = _.isFunction(options.success) ? options.success : function() {};
                for (var i = 0; i < parsed.length; i++) {
                    var model = parsed[i];
                    var childRef = this.firebase.ref().child(model.id);
                    if (options.silent === true) {
                        this._suppressEvent = true;
                    }
                    childRef.set(null, _.bind(options.success, model));
                }
                return parsed;
            },
            create: function(model, options) {
                options = options ? _.clone(options) : {};
                if (options.wait) {
                    this._log("Wait option provided to create, ignoring.");
                }
                model = Backbone.Collection.prototype._prepareModel.apply(this, [ model, options ]);
                if (!model) {
                    return false;
                }
                var set = this.add([ model ], options);
                return set[0];
            },
            reset: function(models, options) {
                options = options ? _.clone(options) : {};
                // Remove all models remotely.
                this.remove(this.models, {
                    silent: true
                });
                // Add new models.
                var ret = this.add(models, {
                    silent: true
                });
                // Trigger "reset" event.
                if (!options.silent) {
                    this.trigger("reset", this, options);
                }
                return ret;
            },
            _log: function(msg) {
                if (console && console.log) {
                    console.log(msg);
                }
            },
            // TODO: Options will be ignored for add & remove, document this!
            _parseModels: function(models) {
                var ret = [];
                models = _.isArray(models) ? models.slice() : [ models ];
                for (var i = 0; i < models.length; i++) {
                    var model = models[i];
                    if (model.toJSON && typeof model.toJSON == "function") {
                        model = model.toJSON();
                    }
                    if (!model.id) {
                        model.id = this.firebase.ref().push().name();
                    }
                    ret.push(model);
                }
                return ret;
            },
            _childAdded: function(snap) {
                var model = snap.val();
                if (!model.id) {
                    if (!_.isObject(model)) {
                        model = {};
                    }
                    model.id = snap.name();
                }
                if (this._suppressEvent === true) {
                    this._suppressEvent = false;
                    Backbone.Collection.prototype.add.apply(this, [ model ], {
                        silent: true
                    });
                } else {
                    Backbone.Collection.prototype.add.apply(this, [ model ]);
                }
                this.get(model.id)._remoteAttributes = model;
            },
            _childMoved: function(snap) {
                // TODO: Investigate: can this occur without the ID changing?
                this._log("_childMoved called with " + snap.val());
            },
            _childChanged: function(snap) {
                var model = snap.val();
                if (!model.id) {
                    model.id = snap.name();
                }
                var item = _.find(this.models, function(child) {
                    return child.id == model.id;
                });
                if (!item) {
                    // TODO: Investigate: what is the right way to handle this case?
                    throw new Error("Could not find model with ID " + model.id);
                }
                this._preventSync(item, true);
                item._remoteAttributes = model;
                var diff = _.difference(_.keys(item.attributes), _.keys(model));
                _.each(diff, function(key) {
                    item.unset(key);
                });
                item.set(model);
                this._preventSync(item, false);
            },
            _childRemoved: function(snap) {
                var model = snap.val();
                if (!model.id) {
                    model.id = snap.name();
                }
                if (this._suppressEvent === true) {
                    this._suppressEvent = false;
                    Backbone.Collection.prototype.remove.apply(this, [ model ], {
                        silent: true
                    });
                } else {
                    Backbone.Collection.prototype.remove.apply(this, [ model ]);
                }
            },
            // Add handlers for all models in this collection, and any future ones
            // that may be added.
            _updateModel: function(model) {
                if (model._remoteChanging) {
                    return;
                }
                var remoteAttributes = model._remoteAttributes || {};
                var localAttributes = model.toJSON();
                var updateAttributes = {};
                var union = _.union(_.keys(remoteAttributes), _.keys(localAttributes));
                _.each(union, function(key) {
                    if (!_.has(localAttributes, key)) {
                        updateAttributes[key] = null;
                    } else if (localAttributes[key] != remoteAttributes[key]) {
                        updateAttributes[key] = localAttributes[key];
                    }
                });
                if (_.size(updateAttributes)) {
                    // Special case if ".priority" was updated - a merge is not
                    // allowed so we'll have to do a full setWithPriority.
                    if (_.has(updateAttributes, ".priority")) {
                        var ref = this.firebase.ref().child(model.id);
                        var priority = localAttributes[".priority"];
                        delete localAttributes[".priority"];
                        ref.setWithPriority(localAttributes, priority);
                    } else {
                        this.firebase.ref().child(model.id).update(updateAttributes);
                    }
                }
            },
            // Triggered when model.destroy() is called on one of the children.
            _removeModel: function(model, collection, options) {
                options = options ? _.clone(options) : {};
                options.success = _.isFunction(options.success) ? options.success : function() {};
                var childRef = this.firebase.ref().child(model.id);
                childRef.set(null, _.bind(options.success, model));
            },
            _preventSync: function(model, state) {
                model._remoteChanging = state;
            }
        });
        // Custom Firebase Model.
        Backbone.Firebase.Model = Backbone.Model.extend({
            save: function() {
                this._log("Save called on a Firebase model, ignoring.");
            },
            destroy: function(options) {
                // TODO: Fix naive success callback. Add error callback.
                this.firebase.ref().set(null, this._log);
                this.trigger("destroy", this, this.collection, options);
                if (options.success) {
                    options.success(this, null, options);
                }
            },
            constructor: function(model, options) {
                // Store defaults so they don't get applied immediately.
                var defaults = _.result(this, "defaults");
                // Apply defaults only after first sync.
                this.once("sync", function() {
                    this.set(_.defaults(this.toJSON(), defaults));
                });
                // Apply parent constructor (this will also call initialize).
                Backbone.Model.apply(this, arguments);
                if (options && options.firebase) {
                    this.firebase = options.firebase;
                }
                switch (typeof this.firebase) {
                  case "object":
                    break;

                  case "string":
                    this.firebase = new Firebase(this.firebase);
                    break;

                  case "function":
                    this.firebase = this.firebase();
                    break;

                  default:
                    throw new Error("Invalid firebase reference created");
                }
                // Add handlers for remote events.
                this.firebase.on("value", _.bind(this._modelChanged, this));
                this._listenLocalChange(true);
            },
            _listenLocalChange: function(state) {
                if (state) {
                    this.on("change", this._updateModel, this);
                } else {
                    this.off("change", this._updateModel, this);
                }
            },
            _updateModel: function(model) {
                // Find the deleted keys and set their values to null
                // so Firebase properly deletes them.
                var modelObj = model.changedAttributes();
                _.each(model.changed, function(value, key) {
                    if (typeof value === "undefined" || value === null) {
                        if (key == "id") {
                            delete modelObj[key];
                        } else {
                            modelObj[key] = null;
                        }
                    }
                });
                if (_.size(modelObj)) {
                    this.firebase.ref().update(modelObj, this._log);
                }
            },
            _modelChanged: function(snap) {
                // Unset attributes that have been deleted from the server
                // by comparing the keys that have been removed.
                var newModel = snap.val();
                if (typeof newModel === "object" && newModel !== null) {
                    var diff = _.difference(_.keys(this.attributes), _.keys(newModel));
                    var self = this;
                    _.each(diff, function(key) {
                        self.unset(key);
                    });
                }
                this._listenLocalChange(false);
                this.set(newModel);
                this._listenLocalChange(true);
                this.trigger("sync", this, null, null);
            },
            _log: function(msg) {
                if (typeof msg === "undefined" || msg === null) {
                    return;
                }
                if (console && console.log) {
                    console.log(msg);
                }
            }
        });
    })();
}.bind(this));

require.register("app/vendor/backbone.js", function(exports, require, module) {
    //     Backbone.js 1.1.1
    //     (c) 2010-2014 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
    //     Backbone may be freely distributed under the MIT license.
    //     For all details and documentation:
    //     http://backbonejs.org
    (function(root, factory) {
        // Set up Backbone appropriately for the environment. Start with AMD.
        if (typeof define === "function" && define.amd) {
            define([ "underscore", "jquery", "exports" ], function(_, $, exports) {
                // Export global even in AMD case in case this script is loaded with
                // others that may still expect a global Backbone.
                root.Backbone = factory(root, exports, _, $);
            });
        } else if (typeof exports !== "undefined") {
            var _ = require("underscore"), $;
            //try { $ = require('jquery'); } catch(e) {}
            factory(root, exports, _, $);
        } else {
            root.Backbone = factory(root, {}, root._, root.jQuery || root.Zepto || root.ender || root.$);
        }
    })(this, function(root, Backbone, _, $) {
        // Initial Setup
        // -------------
        // Save the previous value of the `Backbone` variable, so that it can be
        // restored later on, if `noConflict` is used.
        var previousBackbone = root.Backbone;
        // Create local references to array methods we'll want to use later.
        var array = [];
        var push = array.push;
        var slice = array.slice;
        var splice = array.splice;
        // Current version of the library. Keep in sync with `package.json`.
        Backbone.VERSION = "1.1.1";
        // For Backbone's purposes, jQuery, Zepto, Ender, or My Library (kidding) owns
        // the `$` variable.
        Backbone.$ = $;
        // Runs Backbone.js in *noConflict* mode, returning the `Backbone` variable
        // to its previous owner. Returns a reference to this Backbone object.
        Backbone.noConflict = function() {
            root.Backbone = previousBackbone;
            return this;
        };
        // Turn on `emulateHTTP` to support legacy HTTP servers. Setting this option
        // will fake `"PATCH"`, `"PUT"` and `"DELETE"` requests via the `_method` parameter and
        // set a `X-Http-Method-Override` header.
        Backbone.emulateHTTP = false;
        // Turn on `emulateJSON` to support legacy servers that can't deal with direct
        // `application/json` requests ... will encode the body as
        // `application/x-www-form-urlencoded` instead and will send the model in a
        // form param named `model`.
        Backbone.emulateJSON = false;
        // Backbone.Events
        // ---------------
        // A module that can be mixed in to *any object* in order to provide it with
        // custom events. You may bind with `on` or remove with `off` callback
        // functions to an event; `trigger`-ing an event fires all callbacks in
        // succession.
        //
        //     var object = {};
        //     _.extend(object, Backbone.Events);
        //     object.on('expand', function(){ alert('expanded'); });
        //     object.trigger('expand');
        //
        var Events = Backbone.Events = {
            // Bind an event to a `callback` function. Passing `"all"` will bind
            // the callback to all events fired.
            on: function(name, callback, context) {
                if (!eventsApi(this, "on", name, [ callback, context ]) || !callback) return this;
                this._events || (this._events = {});
                var events = this._events[name] || (this._events[name] = []);
                events.push({
                    callback: callback,
                    context: context,
                    ctx: context || this
                });
                return this;
            },
            // Bind an event to only be triggered a single time. After the first time
            // the callback is invoked, it will be removed.
            once: function(name, callback, context) {
                if (!eventsApi(this, "once", name, [ callback, context ]) || !callback) return this;
                var self = this;
                var once = _.once(function() {
                    self.off(name, once);
                    callback.apply(this, arguments);
                });
                once._callback = callback;
                return this.on(name, once, context);
            },
            // Remove one or many callbacks. If `context` is null, removes all
            // callbacks with that function. If `callback` is null, removes all
            // callbacks for the event. If `name` is null, removes all bound
            // callbacks for all events.
            off: function(name, callback, context) {
                var retain, ev, events, names, i, l, j, k;
                if (!this._events || !eventsApi(this, "off", name, [ callback, context ])) return this;
                if (!name && !callback && !context) {
                    this._events = void 0;
                    return this;
                }
                names = name ? [ name ] : _.keys(this._events);
                for (i = 0, l = names.length; i < l; i++) {
                    name = names[i];
                    if (events = this._events[name]) {
                        this._events[name] = retain = [];
                        if (callback || context) {
                            for (j = 0, k = events.length; j < k; j++) {
                                ev = events[j];
                                if (callback && callback !== ev.callback && callback !== ev.callback._callback || context && context !== ev.context) {
                                    retain.push(ev);
                                }
                            }
                        }
                        if (!retain.length) delete this._events[name];
                    }
                }
                return this;
            },
            // Trigger one or many events, firing all bound callbacks. Callbacks are
            // passed the same arguments as `trigger` is, apart from the event name
            // (unless you're listening on `"all"`, which will cause your callback to
            // receive the true name of the event as the first argument).
            trigger: function(name) {
                if (!this._events) return this;
                var args = slice.call(arguments, 1);
                if (!eventsApi(this, "trigger", name, args)) return this;
                var events = this._events[name];
                var allEvents = this._events.all;
                if (events) triggerEvents(events, args);
                if (allEvents) triggerEvents(allEvents, arguments);
                return this;
            },
            // Tell this object to stop listening to either specific events ... or
            // to every object it's currently listening to.
            stopListening: function(obj, name, callback) {
                var listeningTo = this._listeningTo;
                if (!listeningTo) return this;
                var remove = !name && !callback;
                if (!callback && typeof name === "object") callback = this;
                if (obj) (listeningTo = {})[obj._listenId] = obj;
                for (var id in listeningTo) {
                    obj = listeningTo[id];
                    obj.off(name, callback, this);
                    if (remove || _.isEmpty(obj._events)) delete this._listeningTo[id];
                }
                return this;
            }
        };
        // Regular expression used to split event strings.
        var eventSplitter = /\s+/;
        // Implement fancy features of the Events API such as multiple event
        // names `"change blur"` and jQuery-style event maps `{change: action}`
        // in terms of the existing API.
        var eventsApi = function(obj, action, name, rest) {
            if (!name) return true;
            // Handle event maps.
            if (typeof name === "object") {
                for (var key in name) {
                    obj[action].apply(obj, [ key, name[key] ].concat(rest));
                }
                return false;
            }
            // Handle space separated event names.
            if (eventSplitter.test(name)) {
                var names = name.split(eventSplitter);
                for (var i = 0, l = names.length; i < l; i++) {
                    obj[action].apply(obj, [ names[i] ].concat(rest));
                }
                return false;
            }
            return true;
        };
        // A difficult-to-believe, but optimized internal dispatch function for
        // triggering events. Tries to keep the usual cases speedy (most internal
        // Backbone events have 3 arguments).
        var triggerEvents = function(events, args) {
            var ev, i = -1, l = events.length, a1 = args[0], a2 = args[1], a3 = args[2];
            switch (args.length) {
              case 0:
                while (++i < l) (ev = events[i]).callback.call(ev.ctx);
                return;

              case 1:
                while (++i < l) (ev = events[i]).callback.call(ev.ctx, a1);
                return;

              case 2:
                while (++i < l) (ev = events[i]).callback.call(ev.ctx, a1, a2);
                return;

              case 3:
                while (++i < l) (ev = events[i]).callback.call(ev.ctx, a1, a2, a3);
                return;

              default:
                while (++i < l) (ev = events[i]).callback.apply(ev.ctx, args);
                return;
            }
        };
        var listenMethods = {
            listenTo: "on",
            listenToOnce: "once"
        };
        // Inversion-of-control versions of `on` and `once`. Tell *this* object to
        // listen to an event in another object ... keeping track of what it's
        // listening to.
        _.each(listenMethods, function(implementation, method) {
            Events[method] = function(obj, name, callback) {
                var listeningTo = this._listeningTo || (this._listeningTo = {});
                var id = obj._listenId || (obj._listenId = _.uniqueId("l"));
                listeningTo[id] = obj;
                if (!callback && typeof name === "object") callback = this;
                obj[implementation](name, callback, this);
                return this;
            };
        });
        // Aliases for backwards compatibility.
        Events.bind = Events.on;
        Events.unbind = Events.off;
        // Allow the `Backbone` object to serve as a global event bus, for folks who
        // want global "pubsub" in a convenient place.
        _.extend(Backbone, Events);
        // Backbone.Model
        // --------------
        // Backbone **Models** are the basic data object in the framework --
        // frequently representing a row in a table in a database on your server.
        // A discrete chunk of data and a bunch of useful, related methods for
        // performing computations and transformations on that data.
        // Create a new model with the specified attributes. A client id (`cid`)
        // is automatically generated and assigned for you.
        var Model = Backbone.Model = function(attributes, options) {
            var attrs = attributes || {};
            options || (options = {});
            this.cid = _.uniqueId("c");
            this.attributes = {};
            if (options.collection) this.collection = options.collection;
            if (options.parse) attrs = this.parse(attrs, options) || {};
            attrs = _.defaults({}, attrs, _.result(this, "defaults"));
            this.set(attrs, options);
            this.changed = {};
            this.initialize.apply(this, arguments);
        };
        // Attach all inheritable methods to the Model prototype.
        _.extend(Model.prototype, Events, {
            // A hash of attributes whose current and previous value differ.
            changed: null,
            // The value returned during the last failed validation.
            validationError: null,
            // The default name for the JSON `id` attribute is `"id"`. MongoDB and
            // CouchDB users may want to set this to `"_id"`.
            idAttribute: "id",
            // Initialize is an empty function by default. Override it with your own
            // initialization logic.
            initialize: function() {},
            // Return a copy of the model's `attributes` object.
            toJSON: function(options) {
                return _.clone(this.attributes);
            },
            // Proxy `Backbone.sync` by default -- but override this if you need
            // custom syncing semantics for *this* particular model.
            sync: function() {
                return Backbone.sync.apply(this, arguments);
            },
            // Get the value of an attribute.
            get: function(attr) {
                return this.attributes[attr];
            },
            // Get the HTML-escaped value of an attribute.
            escape: function(attr) {
                return _.escape(this.get(attr));
            },
            // Returns `true` if the attribute contains a value that is not null
            // or undefined.
            has: function(attr) {
                return this.get(attr) != null;
            },
            // Set a hash of model attributes on the object, firing `"change"`. This is
            // the core primitive operation of a model, updating the data and notifying
            // anyone who needs to know about the change in state. The heart of the beast.
            set: function(key, val, options) {
                var attr, attrs, unset, changes, silent, changing, prev, current;
                if (key == null) return this;
                // Handle both `"key", value` and `{key: value}` -style arguments.
                if (typeof key === "object") {
                    attrs = key;
                    options = val;
                } else {
                    (attrs = {})[key] = val;
                }
                options || (options = {});
                // Run validation.
                if (!this._validate(attrs, options)) return false;
                // Extract attributes and options.
                unset = options.unset;
                silent = options.silent;
                changes = [];
                changing = this._changing;
                this._changing = true;
                if (!changing) {
                    this._previousAttributes = _.clone(this.attributes);
                    this.changed = {};
                }
                current = this.attributes, prev = this._previousAttributes;
                // Check for changes of `id`.
                if (this.idAttribute in attrs) this.id = attrs[this.idAttribute];
                // For each `set` attribute, update or delete the current value.
                for (attr in attrs) {
                    val = attrs[attr];
                    if (!_.isEqual(current[attr], val)) changes.push(attr);
                    if (!_.isEqual(prev[attr], val)) {
                        this.changed[attr] = val;
                    } else {
                        delete this.changed[attr];
                    }
                    unset ? delete current[attr] : current[attr] = val;
                }
                // Trigger all relevant attribute changes.
                if (!silent) {
                    if (changes.length) this._pending = options;
                    for (var i = 0, l = changes.length; i < l; i++) {
                        this.trigger("change:" + changes[i], this, current[changes[i]], options);
                    }
                }
                // You might be wondering why there's a `while` loop here. Changes can
                // be recursively nested within `"change"` events.
                if (changing) return this;
                if (!silent) {
                    while (this._pending) {
                        options = this._pending;
                        this._pending = false;
                        this.trigger("change", this, options);
                    }
                }
                this._pending = false;
                this._changing = false;
                return this;
            },
            // Remove an attribute from the model, firing `"change"`. `unset` is a noop
            // if the attribute doesn't exist.
            unset: function(attr, options) {
                return this.set(attr, void 0, _.extend({}, options, {
                    unset: true
                }));
            },
            // Clear all attributes on the model, firing `"change"`.
            clear: function(options) {
                var attrs = {};
                for (var key in this.attributes) attrs[key] = void 0;
                return this.set(attrs, _.extend({}, options, {
                    unset: true
                }));
            },
            // Determine if the model has changed since the last `"change"` event.
            // If you specify an attribute name, determine if that attribute has changed.
            hasChanged: function(attr) {
                if (attr == null) return !_.isEmpty(this.changed);
                return _.has(this.changed, attr);
            },
            // Return an object containing all the attributes that have changed, or
            // false if there are no changed attributes. Useful for determining what
            // parts of a view need to be updated and/or what attributes need to be
            // persisted to the server. Unset attributes will be set to undefined.
            // You can also pass an attributes object to diff against the model,
            // determining if there *would be* a change.
            changedAttributes: function(diff) {
                if (!diff) return this.hasChanged() ? _.clone(this.changed) : false;
                var val, changed = false;
                var old = this._changing ? this._previousAttributes : this.attributes;
                for (var attr in diff) {
                    if (_.isEqual(old[attr], val = diff[attr])) continue;
                    (changed || (changed = {}))[attr] = val;
                }
                return changed;
            },
            // Get the previous value of an attribute, recorded at the time the last
            // `"change"` event was fired.
            previous: function(attr) {
                if (attr == null || !this._previousAttributes) return null;
                return this._previousAttributes[attr];
            },
            // Get all of the attributes of the model at the time of the previous
            // `"change"` event.
            previousAttributes: function() {
                return _.clone(this._previousAttributes);
            },
            // Fetch the model from the server. If the server's representation of the
            // model differs from its current attributes, they will be overridden,
            // triggering a `"change"` event.
            fetch: function(options) {
                options = options ? _.clone(options) : {};
                if (options.parse === void 0) options.parse = true;
                var model = this;
                var success = options.success;
                options.success = function(resp) {
                    if (!model.set(model.parse(resp, options), options)) return false;
                    if (success) success(model, resp, options);
                    model.trigger("sync", model, resp, options);
                };
                wrapError(this, options);
                return this.sync("read", this, options);
            },
            // Set a hash of model attributes, and sync the model to the server.
            // If the server returns an attributes hash that differs, the model's
            // state will be `set` again.
            save: function(key, val, options) {
                var attrs, method, xhr, attributes = this.attributes;
                // Handle both `"key", value` and `{key: value}` -style arguments.
                if (key == null || typeof key === "object") {
                    attrs = key;
                    options = val;
                } else {
                    (attrs = {})[key] = val;
                }
                options = _.extend({
                    validate: true
                }, options);
                // If we're not waiting and attributes exist, save acts as
                // `set(attr).save(null, opts)` with validation. Otherwise, check if
                // the model will be valid when the attributes, if any, are set.
                if (attrs && !options.wait) {
                    if (!this.set(attrs, options)) return false;
                } else {
                    if (!this._validate(attrs, options)) return false;
                }
                // Set temporary attributes if `{wait: true}`.
                if (attrs && options.wait) {
                    this.attributes = _.extend({}, attributes, attrs);
                }
                // After a successful server-side save, the client is (optionally)
                // updated with the server-side state.
                if (options.parse === void 0) options.parse = true;
                var model = this;
                var success = options.success;
                options.success = function(resp) {
                    // Ensure attributes are restored during synchronous saves.
                    model.attributes = attributes;
                    var serverAttrs = model.parse(resp, options);
                    if (options.wait) serverAttrs = _.extend(attrs || {}, serverAttrs);
                    if (_.isObject(serverAttrs) && !model.set(serverAttrs, options)) {
                        return false;
                    }
                    if (success) success(model, resp, options);
                    model.trigger("sync", model, resp, options);
                };
                wrapError(this, options);
                method = this.isNew() ? "create" : options.patch ? "patch" : "update";
                if (method === "patch") options.attrs = attrs;
                xhr = this.sync(method, this, options);
                // Restore attributes.
                if (attrs && options.wait) this.attributes = attributes;
                return xhr;
            },
            // Destroy this model on the server if it was already persisted.
            // Optimistically removes the model from its collection, if it has one.
            // If `wait: true` is passed, waits for the server to respond before removal.
            destroy: function(options) {
                options = options ? _.clone(options) : {};
                var model = this;
                var success = options.success;
                var destroy = function() {
                    model.trigger("destroy", model, model.collection, options);
                };
                options.success = function(resp) {
                    if (options.wait || model.isNew()) destroy();
                    if (success) success(model, resp, options);
                    if (!model.isNew()) model.trigger("sync", model, resp, options);
                };
                if (this.isNew()) {
                    options.success();
                    return false;
                }
                wrapError(this, options);
                var xhr = this.sync("delete", this, options);
                if (!options.wait) destroy();
                return xhr;
            },
            // Default URL for the model's representation on the server -- if you're
            // using Backbone's restful methods, override this to change the endpoint
            // that will be called.
            url: function() {
                var base = _.result(this, "urlRoot") || _.result(this.collection, "url") || urlError();
                if (this.isNew()) return base;
                return base.replace(/([^\/])$/, "$1/") + encodeURIComponent(this.id);
            },
            // **parse** converts a response into the hash of attributes to be `set` on
            // the model. The default implementation is just to pass the response along.
            parse: function(resp, options) {
                return resp;
            },
            // Create a new model with identical attributes to this one.
            clone: function() {
                return new this.constructor(this.attributes);
            },
            // A model is new if it has never been saved to the server, and lacks an id.
            isNew: function() {
                return !this.has(this.idAttribute);
            },
            // Check if the model is currently in a valid state.
            isValid: function(options) {
                return this._validate({}, _.extend(options || {}, {
                    validate: true
                }));
            },
            // Run validation against the next complete set of model attributes,
            // returning `true` if all is well. Otherwise, fire an `"invalid"` event.
            _validate: function(attrs, options) {
                if (!options.validate || !this.validate) return true;
                attrs = _.extend({}, this.attributes, attrs);
                var error = this.validationError = this.validate(attrs, options) || null;
                if (!error) return true;
                this.trigger("invalid", this, error, _.extend(options, {
                    validationError: error
                }));
                return false;
            }
        });
        // Underscore methods that we want to implement on the Model.
        var modelMethods = [ "keys", "values", "pairs", "invert", "pick", "omit" ];
        // Mix in each Underscore method as a proxy to `Model#attributes`.
        _.each(modelMethods, function(method) {
            Model.prototype[method] = function() {
                var args = slice.call(arguments);
                args.unshift(this.attributes);
                return _[method].apply(_, args);
            };
        });
        // Backbone.Collection
        // -------------------
        // If models tend to represent a single row of data, a Backbone Collection is
        // more analagous to a table full of data ... or a small slice or page of that
        // table, or a collection of rows that belong together for a particular reason
        // -- all of the messages in this particular folder, all of the documents
        // belonging to this particular author, and so on. Collections maintain
        // indexes of their models, both in order, and for lookup by `id`.
        // Create a new **Collection**, perhaps to contain a specific type of `model`.
        // If a `comparator` is specified, the Collection will maintain
        // its models in sort order, as they're added and removed.
        var Collection = Backbone.Collection = function(models, options) {
            options || (options = {});
            if (options.model) this.model = options.model;
            if (options.comparator !== void 0) this.comparator = options.comparator;
            this._reset();
            this.initialize.apply(this, arguments);
            if (models) this.reset(models, _.extend({
                silent: true
            }, options));
        };
        // Default options for `Collection#set`.
        var setOptions = {
            add: true,
            remove: true,
            merge: true
        };
        var addOptions = {
            add: true,
            remove: false
        };
        // Define the Collection's inheritable methods.
        _.extend(Collection.prototype, Events, {
            // The default model for a collection is just a **Backbone.Model**.
            // This should be overridden in most cases.
            model: Model,
            // Initialize is an empty function by default. Override it with your own
            // initialization logic.
            initialize: function() {},
            // The JSON representation of a Collection is an array of the
            // models' attributes.
            toJSON: function(options) {
                return this.map(function(model) {
                    return model.toJSON(options);
                });
            },
            // Proxy `Backbone.sync` by default.
            sync: function() {
                return Backbone.sync.apply(this, arguments);
            },
            // Add a model, or list of models to the set.
            add: function(models, options) {
                return this.set(models, _.extend({
                    merge: false
                }, options, addOptions));
            },
            // Remove a model, or a list of models from the set.
            remove: function(models, options) {
                var singular = !_.isArray(models);
                models = singular ? [ models ] : _.clone(models);
                options || (options = {});
                var i, l, index, model;
                for (i = 0, l = models.length; i < l; i++) {
                    model = models[i] = this.get(models[i]);
                    if (!model) continue;
                    delete this._byId[model.id];
                    delete this._byId[model.cid];
                    index = this.indexOf(model);
                    this.models.splice(index, 1);
                    this.length--;
                    if (!options.silent) {
                        options.index = index;
                        model.trigger("remove", model, this, options);
                    }
                    this._removeReference(model, options);
                }
                return singular ? models[0] : models;
            },
            // Update a collection by `set`-ing a new list of models, adding new ones,
            // removing models that are no longer present, and merging models that
            // already exist in the collection, as necessary. Similar to **Model#set**,
            // the core operation for updating the data contained by the collection.
            set: function(models, options) {
                options = _.defaults({}, options, setOptions);
                if (options.parse) models = this.parse(models, options);
                var singular = !_.isArray(models);
                models = singular ? models ? [ models ] : [] : _.clone(models);
                var i, l, id, model, attrs, existing, sort;
                var at = options.at;
                var targetModel = this.model;
                var sortable = this.comparator && at == null && options.sort !== false;
                var sortAttr = _.isString(this.comparator) ? this.comparator : null;
                var toAdd = [], toRemove = [], modelMap = {};
                var add = options.add, merge = options.merge, remove = options.remove;
                var order = !sortable && add && remove ? [] : false;
                // Turn bare objects into model references, and prevent invalid models
                // from being added.
                for (i = 0, l = models.length; i < l; i++) {
                    attrs = models[i] || {};
                    if (attrs instanceof Model) {
                        id = model = attrs;
                    } else {
                        id = attrs[targetModel.prototype.idAttribute || "id"];
                    }
                    // If a duplicate is found, prevent it from being added and
                    // optionally merge it into the existing model.
                    if (existing = this.get(id)) {
                        if (remove) modelMap[existing.cid] = true;
                        if (merge) {
                            attrs = attrs === model ? model.attributes : attrs;
                            if (options.parse) attrs = existing.parse(attrs, options);
                            existing.set(attrs, options);
                            if (sortable && !sort && existing.hasChanged(sortAttr)) sort = true;
                        }
                        models[i] = existing;
                    } else if (add) {
                        model = models[i] = this._prepareModel(attrs, options);
                        if (!model) continue;
                        toAdd.push(model);
                        this._addReference(model, options);
                    }
                    // Do not add multiple models with the same `id`.
                    model = existing || model;
                    if (order && (model.isNew() || !modelMap[model.id])) order.push(model);
                    modelMap[model.id] = true;
                }
                // Remove nonexistent models if appropriate.
                if (remove) {
                    for (i = 0, l = this.length; i < l; ++i) {
                        if (!modelMap[(model = this.models[i]).cid]) toRemove.push(model);
                    }
                    if (toRemove.length) this.remove(toRemove, options);
                }
                // See if sorting is needed, update `length` and splice in new models.
                if (toAdd.length || order && order.length) {
                    if (sortable) sort = true;
                    this.length += toAdd.length;
                    if (at != null) {
                        for (i = 0, l = toAdd.length; i < l; i++) {
                            this.models.splice(at + i, 0, toAdd[i]);
                        }
                    } else {
                        if (order) this.models.length = 0;
                        var orderedModels = order || toAdd;
                        for (i = 0, l = orderedModels.length; i < l; i++) {
                            this.models.push(orderedModels[i]);
                        }
                    }
                }
                // Silently sort the collection if appropriate.
                if (sort) this.sort({
                    silent: true
                });
                // Unless silenced, it's time to fire all appropriate add/sort events.
                if (!options.silent) {
                    for (i = 0, l = toAdd.length; i < l; i++) {
                        (model = toAdd[i]).trigger("add", model, this, options);
                    }
                    if (sort || order && order.length) this.trigger("sort", this, options);
                }
                // Return the added (or merged) model (or models).
                return singular ? models[0] : models;
            },
            // When you have more items than you want to add or remove individually,
            // you can reset the entire set with a new list of models, without firing
            // any granular `add` or `remove` events. Fires `reset` when finished.
            // Useful for bulk operations and optimizations.
            reset: function(models, options) {
                options || (options = {});
                for (var i = 0, l = this.models.length; i < l; i++) {
                    this._removeReference(this.models[i], options);
                }
                options.previousModels = this.models;
                this._reset();
                models = this.add(models, _.extend({
                    silent: true
                }, options));
                if (!options.silent) this.trigger("reset", this, options);
                return models;
            },
            // Add a model to the end of the collection.
            push: function(model, options) {
                return this.add(model, _.extend({
                    at: this.length
                }, options));
            },
            // Remove a model from the end of the collection.
            pop: function(options) {
                var model = this.at(this.length - 1);
                this.remove(model, options);
                return model;
            },
            // Add a model to the beginning of the collection.
            unshift: function(model, options) {
                return this.add(model, _.extend({
                    at: 0
                }, options));
            },
            // Remove a model from the beginning of the collection.
            shift: function(options) {
                var model = this.at(0);
                this.remove(model, options);
                return model;
            },
            // Slice out a sub-array of models from the collection.
            slice: function() {
                return slice.apply(this.models, arguments);
            },
            // Get a model from the set by id.
            get: function(obj) {
                if (obj == null) return void 0;
                return this._byId[obj] || this._byId[obj.id] || this._byId[obj.cid];
            },
            // Get the model at the given index.
            at: function(index) {
                return this.models[index];
            },
            // Return models with matching attributes. Useful for simple cases of
            // `filter`.
            where: function(attrs, first) {
                if (_.isEmpty(attrs)) return first ? void 0 : [];
                return this[first ? "find" : "filter"](function(model) {
                    for (var key in attrs) {
                        if (attrs[key] !== model.get(key)) return false;
                    }
                    return true;
                });
            },
            // Return the first model with matching attributes. Useful for simple cases
            // of `find`.
            findWhere: function(attrs) {
                return this.where(attrs, true);
            },
            // Force the collection to re-sort itself. You don't need to call this under
            // normal circumstances, as the set will maintain sort order as each item
            // is added.
            sort: function(options) {
                if (!this.comparator) throw new Error("Cannot sort a set without a comparator");
                options || (options = {});
                // Run sort based on type of `comparator`.
                if (_.isString(this.comparator) || this.comparator.length === 1) {
                    this.models = this.sortBy(this.comparator, this);
                } else {
                    this.models.sort(_.bind(this.comparator, this));
                }
                if (!options.silent) this.trigger("sort", this, options);
                return this;
            },
            // Pluck an attribute from each model in the collection.
            pluck: function(attr) {
                return _.invoke(this.models, "get", attr);
            },
            // Fetch the default set of models for this collection, resetting the
            // collection when they arrive. If `reset: true` is passed, the response
            // data will be passed through the `reset` method instead of `set`.
            fetch: function(options) {
                options = options ? _.clone(options) : {};
                if (options.parse === void 0) options.parse = true;
                var success = options.success;
                var collection = this;
                options.success = function(resp) {
                    var method = options.reset ? "reset" : "set";
                    collection[method](resp, options);
                    if (success) success(collection, resp, options);
                    collection.trigger("sync", collection, resp, options);
                };
                wrapError(this, options);
                return this.sync("read", this, options);
            },
            // Create a new instance of a model in this collection. Add the model to the
            // collection immediately, unless `wait: true` is passed, in which case we
            // wait for the server to agree.
            create: function(model, options) {
                options = options ? _.clone(options) : {};
                if (!(model = this._prepareModel(model, options))) return false;
                if (!options.wait) this.add(model, options);
                var collection = this;
                var success = options.success;
                options.success = function(model, resp) {
                    if (options.wait) collection.add(model, options);
                    if (success) success(model, resp, options);
                };
                model.save(null, options);
                return model;
            },
            // **parse** converts a response into a list of models to be added to the
            // collection. The default implementation is just to pass it through.
            parse: function(resp, options) {
                return resp;
            },
            // Create a new collection with an identical list of models as this one.
            clone: function() {
                return new this.constructor(this.models);
            },
            // Private method to reset all internal state. Called when the collection
            // is first initialized or reset.
            _reset: function() {
                this.length = 0;
                this.models = [];
                this._byId = {};
            },
            // Prepare a hash of attributes (or other model) to be added to this
            // collection.
            _prepareModel: function(attrs, options) {
                if (attrs instanceof Model) return attrs;
                options = options ? _.clone(options) : {};
                options.collection = this;
                var model = new this.model(attrs, options);
                if (!model.validationError) return model;
                this.trigger("invalid", this, model.validationError, options);
                return false;
            },
            // Internal method to create a model's ties to a collection.
            _addReference: function(model, options) {
                this._byId[model.cid] = model;
                if (model.id != null) this._byId[model.id] = model;
                if (!model.collection) model.collection = this;
                model.on("all", this._onModelEvent, this);
            },
            // Internal method to sever a model's ties to a collection.
            _removeReference: function(model, options) {
                if (this === model.collection) delete model.collection;
                model.off("all", this._onModelEvent, this);
            },
            // Internal method called every time a model in the set fires an event.
            // Sets need to update their indexes when models change ids. All other
            // events simply proxy through. "add" and "remove" events that originate
            // in other collections are ignored.
            _onModelEvent: function(event, model, collection, options) {
                if ((event === "add" || event === "remove") && collection !== this) return;
                if (event === "destroy") this.remove(model, options);
                if (model && event === "change:" + model.idAttribute) {
                    delete this._byId[model.previous(model.idAttribute)];
                    if (model.id != null) this._byId[model.id] = model;
                }
                this.trigger.apply(this, arguments);
            }
        });
        // Underscore methods that we want to implement on the Collection.
        // 90% of the core usefulness of Backbone Collections is actually implemented
        // right here:
        var methods = [ "forEach", "each", "map", "collect", "reduce", "foldl", "inject", "reduceRight", "foldr", "find", "detect", "filter", "select", "reject", "every", "all", "some", "any", "include", "contains", "invoke", "max", "min", "toArray", "size", "first", "head", "take", "initial", "rest", "tail", "drop", "last", "without", "difference", "indexOf", "shuffle", "lastIndexOf", "isEmpty", "chain", "sample" ];
        // Mix in each Underscore method as a proxy to `Collection#models`.
        _.each(methods, function(method) {
            Collection.prototype[method] = function() {
                var args = slice.call(arguments);
                args.unshift(this.models);
                return _[method].apply(_, args);
            };
        });
        // Underscore methods that take a property name as an argument.
        var attributeMethods = [ "groupBy", "countBy", "sortBy", "indexBy" ];
        // Use attributes instead of properties.
        _.each(attributeMethods, function(method) {
            Collection.prototype[method] = function(value, context) {
                var iterator = _.isFunction(value) ? value : function(model) {
                    return model.get(value);
                };
                return _[method](this.models, iterator, context);
            };
        });
        // Backbone.View
        // -------------
        // Backbone Views are almost more convention than they are actual code. A View
        // is simply a JavaScript object that represents a logical chunk of UI in the
        // DOM. This might be a single item, an entire list, a sidebar or panel, or
        // even the surrounding frame which wraps your whole app. Defining a chunk of
        // UI as a **View** allows you to define your DOM events declaratively, without
        // having to worry about render order ... and makes it easy for the view to
        // react to specific changes in the state of your models.
        // Creating a Backbone.View creates its initial element outside of the DOM,
        // if an existing element is not provided...
        var View = Backbone.View = function(options) {
            this.cid = _.uniqueId("view");
            options || (options = {});
            _.extend(this, _.pick(options, viewOptions));
            this._ensureElement();
            this.initialize.apply(this, arguments);
            this.delegateEvents();
        };
        // Cached regex to split keys for `delegate`.
        var delegateEventSplitter = /^(\S+)\s*(.*)$/;
        // List of view options to be merged as properties.
        var viewOptions = [ "model", "collection", "el", "id", "attributes", "className", "tagName", "events" ];
        // Set up all inheritable **Backbone.View** properties and methods.
        _.extend(View.prototype, Events, {
            // The default `tagName` of a View's element is `"div"`.
            tagName: "div",
            // jQuery delegate for element lookup, scoped to DOM elements within the
            // current view. This should be preferred to global lookups where possible.
            $: function(selector) {
                return this.$el.find(selector);
            },
            // Initialize is an empty function by default. Override it with your own
            // initialization logic.
            initialize: function() {},
            // **render** is the core function that your view should override, in order
            // to populate its element (`this.el`), with the appropriate HTML. The
            // convention is for **render** to always return `this`.
            render: function() {
                return this;
            },
            // Remove this view by taking the element out of the DOM, and removing any
            // applicable Backbone.Events listeners.
            remove: function() {
                this.$el.remove();
                this.stopListening();
                return this;
            },
            // Change the view's element (`this.el` property), including event
            // re-delegation.
            setElement: function(element, delegate) {
                if (this.$el) this.undelegateEvents();
                this.$el = element instanceof Backbone.$ ? element : Backbone.$(element);
                this.el = this.$el[0];
                if (delegate !== false) this.delegateEvents();
                return this;
            },
            // Set callbacks, where `this.events` is a hash of
            //
            // *{"event selector": "callback"}*
            //
            //     {
            //       'mousedown .title':  'edit',
            //       'click .button':     'save',
            //       'click .open':       function(e) { ... }
            //     }
            //
            // pairs. Callbacks will be bound to the view, with `this` set properly.
            // Uses event delegation for efficiency.
            // Omitting the selector binds the event to `this.el`.
            // This only works for delegate-able events: not `focus`, `blur`, and
            // not `change`, `submit`, and `reset` in Internet Explorer.
            delegateEvents: function(events) {
                if (!(events || (events = _.result(this, "events")))) return this;
                this.undelegateEvents();
                for (var key in events) {
                    var method = events[key];
                    if (!_.isFunction(method)) method = this[events[key]];
                    if (!method) continue;
                    var match = key.match(delegateEventSplitter);
                    var eventName = match[1], selector = match[2];
                    method = _.bind(method, this);
                    eventName += ".delegateEvents" + this.cid;
                    if (selector === "") {
                        this.$el.on(eventName, method);
                    } else {
                        this.$el.on(eventName, selector, method);
                    }
                }
                return this;
            },
            // Clears all callbacks previously bound to the view with `delegateEvents`.
            // You usually don't need to use this, but may wish to if you have multiple
            // Backbone views attached to the same DOM element.
            undelegateEvents: function() {
                this.$el.off(".delegateEvents" + this.cid);
                return this;
            },
            // Ensure that the View has a DOM element to render into.
            // If `this.el` is a string, pass it through `$()`, take the first
            // matching element, and re-assign it to `el`. Otherwise, create
            // an element from the `id`, `className` and `tagName` properties.
            _ensureElement: function() {
                if (!this.el) {
                    var attrs = _.extend({}, _.result(this, "attributes"));
                    if (this.id) attrs.id = _.result(this, "id");
                    if (this.className) attrs["class"] = _.result(this, "className");
                    var $el = Backbone.$("<" + _.result(this, "tagName") + ">").attr(attrs);
                    this.setElement($el, false);
                } else {
                    this.setElement(_.result(this, "el"), false);
                }
            }
        });
        // Backbone.sync
        // -------------
        // Override this function to change the manner in which Backbone persists
        // models to the server. You will be passed the type of request, and the
        // model in question. By default, makes a RESTful Ajax request
        // to the model's `url()`. Some possible customizations could be:
        //
        // * Use `setTimeout` to batch rapid-fire updates into a single request.
        // * Send up the models as XML instead of JSON.
        // * Persist models via WebSockets instead of Ajax.
        //
        // Turn on `Backbone.emulateHTTP` in order to send `PUT` and `DELETE` requests
        // as `POST`, with a `_method` parameter containing the true HTTP method,
        // as well as all requests with the body as `application/x-www-form-urlencoded`
        // instead of `application/json` with the model in a param named `model`.
        // Useful when interfacing with server-side languages like **PHP** that make
        // it difficult to read the body of `PUT` requests.
        Backbone.sync = function(method, model, options) {
            var type = methodMap[method];
            // Default options, unless specified.
            _.defaults(options || (options = {}), {
                emulateHTTP: Backbone.emulateHTTP,
                emulateJSON: Backbone.emulateJSON
            });
            // Default JSON-request options.
            var params = {
                type: type,
                dataType: "json"
            };
            // Ensure that we have a URL.
            if (!options.url) {
                params.url = _.result(model, "url") || urlError();
            }
            // Ensure that we have the appropriate request data.
            if (options.data == null && model && (method === "create" || method === "update" || method === "patch")) {
                params.contentType = "application/json";
                params.data = JSON.stringify(options.attrs || model.toJSON(options));
            }
            // For older servers, emulate JSON by encoding the request into an HTML-form.
            if (options.emulateJSON) {
                params.contentType = "application/x-www-form-urlencoded";
                params.data = params.data ? {
                    model: params.data
                } : {};
            }
            // For older servers, emulate HTTP by mimicking the HTTP method with `_method`
            // And an `X-HTTP-Method-Override` header.
            if (options.emulateHTTP && (type === "PUT" || type === "DELETE" || type === "PATCH")) {
                params.type = "POST";
                if (options.emulateJSON) params.data._method = type;
                var beforeSend = options.beforeSend;
                options.beforeSend = function(xhr) {
                    xhr.setRequestHeader("X-HTTP-Method-Override", type);
                    if (beforeSend) return beforeSend.apply(this, arguments);
                };
            }
            // Don't process data on a non-GET request.
            if (params.type !== "GET" && !options.emulateJSON) {
                params.processData = false;
            }
            // If we're sending a `PATCH` request, and we're in an old Internet Explorer
            // that still has ActiveX enabled by default, override jQuery to use that
            // for XHR instead. Remove this line when jQuery supports `PATCH` on IE8.
            if (params.type === "PATCH" && noXhrPatch) {
                params.xhr = function() {
                    return new ActiveXObject("Microsoft.XMLHTTP");
                };
            }
            // Make the request, allowing the user to override any Ajax options.
            var xhr = options.xhr = Backbone.ajax(_.extend(params, options));
            model.trigger("request", model, xhr, options);
            return xhr;
        };
        var noXhrPatch = typeof window !== "undefined" && !!window.ActiveXObject && !(window.XMLHttpRequest && new XMLHttpRequest().dispatchEvent);
        // Map from CRUD to HTTP for our default `Backbone.sync` implementation.
        var methodMap = {
            create: "POST",
            update: "PUT",
            patch: "PATCH",
            "delete": "DELETE",
            read: "GET"
        };
        // Set the default implementation of `Backbone.ajax` to proxy through to `$`.
        // Override this if you'd like to use a different library.
        Backbone.ajax = function() {
            return Backbone.$.ajax.apply(Backbone.$, arguments);
        };
        // Backbone.Router
        // ---------------
        // Routers map faux-URLs to actions, and fire events when routes are
        // matched. Creating a new one sets its `routes` hash, if not set statically.
        var Router = Backbone.Router = function(options) {
            options || (options = {});
            if (options.routes) this.routes = options.routes;
            this._bindRoutes();
            this.initialize.apply(this, arguments);
        };
        // Cached regular expressions for matching named param parts and splatted
        // parts of route strings.
        var optionalParam = /\((.*?)\)/g;
        var namedParam = /(\(\?)?:\w+/g;
        var splatParam = /\*\w+/g;
        var escapeRegExp = /[\-{}\[\]+?.,\\\^$|#\s]/g;
        // Set up all inheritable **Backbone.Router** properties and methods.
        _.extend(Router.prototype, Events, {
            // Initialize is an empty function by default. Override it with your own
            // initialization logic.
            initialize: function() {},
            // Manually bind a single named route to a callback. For example:
            //
            //     this.route('search/:query/p:num', 'search', function(query, num) {
            //       ...
            //     });
            //
            route: function(route, name, callback) {
                if (!_.isRegExp(route)) route = this._routeToRegExp(route);
                if (_.isFunction(name)) {
                    callback = name;
                    name = "";
                }
                if (!callback) callback = this[name];
                var router = this;
                Backbone.history.route(route, function(fragment) {
                    var args = router._extractParameters(route, fragment);
                    router.execute(callback, args);
                    router.trigger.apply(router, [ "route:" + name ].concat(args));
                    router.trigger("route", name, args);
                    Backbone.history.trigger("route", router, name, args);
                });
                return this;
            },
            // Execute a route handler with the provided parameters.  This is an
            // excellent place to do pre-route setup or post-route cleanup.
            execute: function(callback, args) {
                if (callback) callback.apply(this, args);
            },
            // Simple proxy to `Backbone.history` to save a fragment into the history.
            navigate: function(fragment, options) {
                Backbone.history.navigate(fragment, options);
                return this;
            },
            // Bind all defined routes to `Backbone.history`. We have to reverse the
            // order of the routes here to support behavior where the most general
            // routes can be defined at the bottom of the route map.
            _bindRoutes: function() {
                if (!this.routes) return;
                this.routes = _.result(this, "routes");
                var route, routes = _.keys(this.routes);
                while ((route = routes.pop()) != null) {
                    this.route(route, this.routes[route]);
                }
            },
            // Convert a route string into a regular expression, suitable for matching
            // against the current location hash.
            _routeToRegExp: function(route) {
                route = route.replace(escapeRegExp, "\\$&").replace(optionalParam, "(?:$1)?").replace(namedParam, function(match, optional) {
                    return optional ? match : "([^/?]+)";
                }).replace(splatParam, "([^?]*?)");
                return new RegExp("^" + route + "(?:\\?(.*))?$");
            },
            // Given a route, and a URL fragment that it matches, return the array of
            // extracted decoded parameters. Empty or unmatched parameters will be
            // treated as `null` to normalize cross-browser behavior.
            _extractParameters: function(route, fragment) {
                var params = route.exec(fragment).slice(1);
                return _.map(params, function(param, i) {
                    // Don't decode the search params.
                    if (i === params.length - 1) return param || null;
                    return param ? decodeURIComponent(param) : null;
                });
            }
        });
        // Backbone.History
        // ----------------
        // Handles cross-browser history management, based on either
        // [pushState](http://diveintohtml5.info/history.html) and real URLs, or
        // [onhashchange](https://developer.mozilla.org/en-US/docs/DOM/window.onhashchange)
        // and URL fragments. If the browser supports neither (old IE, natch),
        // falls back to polling.
        var History = Backbone.History = function() {
            this.handlers = [];
            _.bindAll(this, "checkUrl");
            // Ensure that `History` can be used outside of the browser.
            if (typeof window !== "undefined") {
                this.location = window.location;
                this.history = window.history;
            }
        };
        // Cached regex for stripping a leading hash/slash and trailing space.
        var routeStripper = /^[#\/]|\s+$/g;
        // Cached regex for stripping leading and trailing slashes.
        var rootStripper = /^\/+|\/+$/g;
        // Cached regex for detecting MSIE.
        var isExplorer = /msie [\w.]+/;
        // Cached regex for removing a trailing slash.
        var trailingSlash = /\/$/;
        // Cached regex for stripping urls of hash.
        var pathStripper = /#.*$/;
        // Has the history handling already been started?
        History.started = false;
        // Set up all inheritable **Backbone.History** properties and methods.
        _.extend(History.prototype, Events, {
            // The default interval to poll for hash changes, if necessary, is
            // twenty times a second.
            interval: 50,
            // Are we at the app root?
            atRoot: function() {
                return this.location.pathname.replace(/[^\/]$/, "$&/") === this.root;
            },
            // Gets the true hash value. Cannot use location.hash directly due to bug
            // in Firefox where location.hash will always be decoded.
            getHash: function(window) {
                var match = (window || this).location.href.match(/#(.*)$/);
                return match ? match[1] : "";
            },
            // Get the cross-browser normalized URL fragment, either from the URL,
            // the hash, or the override.
            getFragment: function(fragment, forcePushState) {
                if (fragment == null) {
                    if (this._hasPushState || !this._wantsHashChange || forcePushState) {
                        fragment = decodeURI(this.location.pathname + this.location.search);
                        var root = this.root.replace(trailingSlash, "");
                        if (!fragment.indexOf(root)) fragment = fragment.slice(root.length);
                    } else {
                        fragment = this.getHash();
                    }
                }
                return fragment.replace(routeStripper, "");
            },
            // Start the hash change handling, returning `true` if the current URL matches
            // an existing route, and `false` otherwise.
            start: function(options) {
                if (History.started) throw new Error("Backbone.history has already been started");
                History.started = true;
                // Figure out the initial configuration. Do we need an iframe?
                // Is pushState desired ... is it available?
                this.options = _.extend({
                    root: "/"
                }, this.options, options);
                this.root = this.options.root;
                this._wantsHashChange = this.options.hashChange !== false;
                this._wantsPushState = !!this.options.pushState;
                this._hasPushState = !!(this.options.pushState && this.history && this.history.pushState);
                var fragment = this.getFragment();
                var docMode = document.documentMode;
                var oldIE = isExplorer.exec(navigator.userAgent.toLowerCase()) && (!docMode || docMode <= 7);
                // Normalize root to always include a leading and trailing slash.
                this.root = ("/" + this.root + "/").replace(rootStripper, "/");
                if (oldIE && this._wantsHashChange) {
                    var frame = Backbone.$('<iframe src="javascript:0" tabindex="-1">');
                    this.iframe = frame.hide().appendTo("body")[0].contentWindow;
                    this.navigate(fragment);
                }
                // Depending on whether we're using pushState or hashes, and whether
                // 'onhashchange' is supported, determine how we check the URL state.
                if (this._hasPushState) {
                    Backbone.$(window).on("popstate", this.checkUrl);
                } else if (this._wantsHashChange && "onhashchange" in window && !oldIE) {
                    Backbone.$(window).on("hashchange", this.checkUrl);
                } else if (this._wantsHashChange) {
                    this._checkUrlInterval = setInterval(this.checkUrl, this.interval);
                }
                // Determine if we need to change the base url, for a pushState link
                // opened by a non-pushState browser.
                this.fragment = fragment;
                var loc = this.location;
                // Transition from hashChange to pushState or vice versa if both are
                // requested.
                if (this._wantsHashChange && this._wantsPushState) {
                    // If we've started off with a route from a `pushState`-enabled
                    // browser, but we're currently in a browser that doesn't support it...
                    if (!this._hasPushState && !this.atRoot()) {
                        this.fragment = this.getFragment(null, true);
                        this.location.replace(this.root + "#" + this.fragment);
                        // Return immediately as browser will do redirect to new url
                        return true;
                    } else if (this._hasPushState && this.atRoot() && loc.hash) {
                        this.fragment = this.getHash().replace(routeStripper, "");
                        this.history.replaceState({}, document.title, this.root + this.fragment);
                    }
                }
                if (!this.options.silent) return this.loadUrl();
            },
            // Disable Backbone.history, perhaps temporarily. Not useful in a real app,
            // but possibly useful for unit testing Routers.
            stop: function() {
                Backbone.$(window).off("popstate", this.checkUrl).off("hashchange", this.checkUrl);
                clearInterval(this._checkUrlInterval);
                History.started = false;
            },
            // Add a route to be tested when the fragment changes. Routes added later
            // may override previous routes.
            route: function(route, callback) {
                this.handlers.unshift({
                    route: route,
                    callback: callback
                });
            },
            // Checks the current URL to see if it has changed, and if it has,
            // calls `loadUrl`, normalizing across the hidden iframe.
            checkUrl: function(e) {
                var current = this.getFragment();
                if (current === this.fragment && this.iframe) {
                    current = this.getFragment(this.getHash(this.iframe));
                }
                if (current === this.fragment) return false;
                if (this.iframe) this.navigate(current);
                this.loadUrl();
            },
            // Attempt to load the current URL fragment. If a route succeeds with a
            // match, returns `true`. If no defined routes matches the fragment,
            // returns `false`.
            loadUrl: function(fragment) {
                fragment = this.fragment = this.getFragment(fragment);
                return _.any(this.handlers, function(handler) {
                    if (handler.route.test(fragment)) {
                        handler.callback(fragment);
                        return true;
                    }
                });
            },
            // Save a fragment into the hash history, or replace the URL state if the
            // 'replace' option is passed. You are responsible for properly URL-encoding
            // the fragment in advance.
            //
            // The options object can contain `trigger: true` if you wish to have the
            // route callback be fired (not usually desirable), or `replace: true`, if
            // you wish to modify the current URL without adding an entry to the history.
            navigate: function(fragment, options) {
                if (!History.started) return false;
                if (!options || options === true) options = {
                    trigger: !!options
                };
                var url = this.root + (fragment = this.getFragment(fragment || ""));
                // Strip the hash for matching.
                fragment = fragment.replace(pathStripper, "");
                if (this.fragment === fragment) return;
                this.fragment = fragment;
                // Don't include a trailing slash on the root.
                if (fragment === "" && url !== "/") url = url.slice(0, -1);
                // If pushState is available, we use it to set the fragment as a real URL.
                if (this._hasPushState) {
                    this.history[options.replace ? "replaceState" : "pushState"]({}, document.title, url);
                } else if (this._wantsHashChange) {
                    this._updateHash(this.location, fragment, options.replace);
                    if (this.iframe && fragment !== this.getFragment(this.getHash(this.iframe))) {
                        // Opening and closing the iframe tricks IE7 and earlier to push a
                        // history entry on hash-tag change.  When replace is true, we don't
                        // want this.
                        if (!options.replace) this.iframe.document.open().close();
                        this._updateHash(this.iframe.location, fragment, options.replace);
                    }
                } else {
                    return this.location.assign(url);
                }
                if (options.trigger) return this.loadUrl(fragment);
            },
            // Update the hash location, either replacing the current entry, or adding
            // a new one to the browser history.
            _updateHash: function(location, fragment, replace) {
                if (replace) {
                    var href = location.href.replace(/(javascript:|#).*$/, "");
                    location.replace(href + "#" + fragment);
                } else {
                    // Some browsers require that `hash` contains a leading #.
                    location.hash = "#" + fragment;
                }
            }
        });
        // Create the default Backbone.history.
        Backbone.history = new History();
        // Helpers
        // -------
        // Helper function to correctly set up the prototype chain, for subclasses.
        // Similar to `goog.inherits`, but uses a hash of prototype properties and
        // class properties to be extended.
        var extend = function(protoProps, staticProps) {
            var parent = this;
            var child;
            // The constructor function for the new subclass is either defined by you
            // (the "constructor" property in your `extend` definition), or defaulted
            // by us to simply call the parent's constructor.
            if (protoProps && _.has(protoProps, "constructor")) {
                child = protoProps.constructor;
            } else {
                child = function() {
                    return parent.apply(this, arguments);
                };
            }
            // Add static properties to the constructor function, if supplied.
            _.extend(child, parent, staticProps);
            // Set the prototype chain to inherit from `parent`, without calling
            // `parent`'s constructor function.
            var Surrogate = function() {
                this.constructor = child;
            };
            Surrogate.prototype = parent.prototype;
            child.prototype = new Surrogate();
            // Add prototype properties (instance properties) to the subclass,
            // if supplied.
            if (protoProps) _.extend(child.prototype, protoProps);
            // Set a convenience property in case the parent's prototype is needed
            // later.
            child.__super__ = parent.prototype;
            return child;
        };
        // Set up inheritance for the model, collection, router, view and history.
        Model.extend = Collection.extend = Router.extend = View.extend = History.extend = extend;
        // Throw an error when a URL is needed, and none is supplied.
        var urlError = function() {
            throw new Error('A "url" property or function must be specified');
        };
        // Wrap an optional error callback with a fallback error event.
        var wrapError = function(model, options) {
            var error = options.error;
            options.error = function(resp) {
                if (error) error(model, resp, options);
                model.trigger("error", model, resp, options);
            };
        };
        return Backbone;
    });
}.bind(this));

require.register("app/vendor/backbone.localStorage.js", function(exports, require, module) {
    /**
     * Backbone localStorage Adapter
     * Version 1.1.7
     *
     * https://github.com/jeromegn/Backbone.localStorage
     */
    (function(root, factory) {
        if (typeof exports === "object" && typeof require === "function") {
            module.exports = factory(require("underscore"), require("backbone"));
        } else if (typeof define === "function" && define.amd) {
            // AMD. Register as an anonymous module.
            define([ "underscore", "backbone" ], function(_, Backbone) {
                // Use global variables if the locals are undefined.
                return factory(_ || root._, Backbone || root.Backbone);
            });
        } else {
            // RequireJS isn't being used. Assume underscore and backbone are loaded in <script> tags
            factory(_, Backbone);
        }
    })(this, function(_, Backbone) {
        // A simple module to replace `Backbone.sync` with *localStorage*-based
        // persistence. Models are given GUIDS, and saved into a JSON object. Simple
        // as that.
        // Hold reference to Underscore.js and Backbone.js in the closure in order
        // to make things work even if they are removed from the global namespace
        // Generate four random hex digits.
        function S4() {
            return ((1 + Math.random()) * 65536 | 0).toString(16).substring(1);
        }
        // Generate a pseudo-GUID by concatenating random hexadecimal.
        function guid() {
            return S4() + S4() + "-" + S4() + "-" + S4() + "-" + S4() + "-" + S4() + S4() + S4();
        }
        // Our Store is represented by a single JS object in *localStorage*. Create it
        // with a meaningful name, like the name you'd give a table.
        // window.Store is deprectated, use Backbone.LocalStorage instead
        Backbone.LocalStorage = window.Store = function(name) {
            if (!this.localStorage) {
                throw "Backbone.localStorage: Environment does not support localStorage.";
            }
            this.name = name;
            var store = this.localStorage().getItem(this.name);
            this.records = store && store.split(",") || [];
        };
        _.extend(Backbone.LocalStorage.prototype, {
            // Save the current state of the **Store** to *localStorage*.
            save: function() {
                this.localStorage().setItem(this.name, this.records.join(","));
            },
            // Add a model, giving it a (hopefully)-unique GUID, if it doesn't already
            // have an id of it's own.
            create: function(model) {
                if (!model.id) {
                    model.id = guid();
                    model.set(model.idAttribute, model.id);
                }
                this.localStorage().setItem(this.name + "-" + model.id, JSON.stringify(model));
                this.records.push(model.id.toString());
                this.save();
                return this.find(model);
            },
            // Update a model by replacing its copy in `this.data`.
            update: function(model) {
                this.localStorage().setItem(this.name + "-" + model.id, JSON.stringify(model));
                if (!_.include(this.records, model.id.toString())) this.records.push(model.id.toString());
                this.save();
                return this.find(model);
            },
            // Retrieve a model from `this.data` by id.
            find: function(model) {
                return this.jsonData(this.localStorage().getItem(this.name + "-" + model.id));
            },
            // Return the array of all models currently in storage.
            findAll: function() {
                // Lodash removed _#chain in v1.0.0-rc.1
                return (_.chain || _)(this.records).map(function(id) {
                    return this.jsonData(this.localStorage().getItem(this.name + "-" + id));
                }, this).compact().value();
            },
            // Delete a model from `this.data`, returning it.
            destroy: function(model) {
                if (model.isNew()) return false;
                this.localStorage().removeItem(this.name + "-" + model.id);
                this.records = _.reject(this.records, function(id) {
                    return id === model.id.toString();
                });
                this.save();
                return model;
            },
            localStorage: function() {
                return localStorage;
            },
            // fix for "illegal access" error on Android when JSON.parse is passed null
            jsonData: function(data) {
                return data && JSON.parse(data);
            },
            // Clear localStorage for specific collection.
            _clear: function() {
                var local = this.localStorage(), itemRe = new RegExp("^" + this.name + "-");
                // Remove id-tracking item (e.g., "foo").
                local.removeItem(this.name);
                // Lodash removed _#chain in v1.0.0-rc.1
                // Match all data items (e.g., "foo-ID") and remove.
                (_.chain || _)(local).keys().filter(function(k) {
                    return itemRe.test(k);
                }).each(function(k) {
                    local.removeItem(k);
                });
                this.records.length = 0;
            },
            // Size of localStorage.
            _storageSize: function() {
                return this.localStorage().length;
            }
        });
        // localSync delegate to the model or collection's
        // *localStorage* property, which should be an instance of `Store`.
        // window.Store.sync and Backbone.localSync is deprecated, use Backbone.LocalStorage.sync instead
        Backbone.LocalStorage.sync = window.Store.sync = Backbone.localSync = function(method, model, options) {
            var store = model.localStorage || model.collection.localStorage;
            var resp, errorMessage, syncDfd = Backbone.$.Deferred && Backbone.$.Deferred();
            //If $ is having Deferred - use it.
            try {
                switch (method) {
                  case "read":
                    resp = model.id != undefined ? store.find(model) : store.findAll();
                    break;

                  case "create":
                    resp = store.create(model);
                    break;

                  case "update":
                    resp = store.update(model);
                    break;

                  case "delete":
                    resp = store.destroy(model);
                    break;
                }
            } catch (error) {
                if (error.code === 22 && store._storageSize() === 0) errorMessage = "Private browsing is unsupported"; else errorMessage = error.message;
            }
            if (resp) {
                if (options && options.success) {
                    if (Backbone.VERSION === "0.9.10") {
                        options.success(model, resp, options);
                    } else {
                        options.success(resp);
                    }
                }
                if (syncDfd) {
                    syncDfd.resolve(resp);
                }
            } else {
                errorMessage = errorMessage ? errorMessage : "Record Not Found";
                if (options && options.error) if (Backbone.VERSION === "0.9.10") {
                    options.error(model, errorMessage, options);
                } else {
                    options.error(errorMessage);
                }
                if (syncDfd) syncDfd.reject(errorMessage);
            }
            // add compatibility with $.ajax
            // always execute callback for success and error
            if (options && options.complete) options.complete(resp);
            return syncDfd && syncDfd.promise();
        };
        Backbone.ajaxSync = Backbone.sync;
        Backbone.getSyncMethod = function(model) {
            if (model.localStorage || model.collection && model.collection.localStorage) {
                return Backbone.localSync;
            }
            return Backbone.ajaxSync;
        };
        // Override 'Backbone.sync' to default to localSync,
        // the original 'Backbone.sync' is still available in 'Backbone.ajaxSync'
        Backbone.sync = function(method, model, options) {
            return Backbone.getSyncMethod(model).apply(this, [ method, model, options ]);
        };
        return Backbone.LocalStorage;
    });
}.bind(this));

require.register("app/vendor/firebase.js", function(exports, require, module) {
    (function() {
        function g(a) {
            throw a;
        }
        var aa = void 0, j = !0, k = null, l = !1;
        function ba(a) {
            return function() {
                return this[a];
            };
        }
        function o(a) {
            return function() {
                return a;
            };
        }
        var r, ca = this;
        function da() {}
        function ea(a) {
            a.mb = function() {
                return a.ed ? a.ed : a.ed = new a();
            };
        }
        function fa(a) {
            var b = typeof a;
            if ("object" == b) if (a) {
                if (a instanceof Array) return "array";
                if (a instanceof Object) return b;
                var c = Object.prototype.toString.call(a);
                if ("[object Window]" == c) return "object";
                if ("[object Array]" == c || "number" == typeof a.length && "undefined" != typeof a.splice && "undefined" != typeof a.propertyIsEnumerable && !a.propertyIsEnumerable("splice")) return "array";
                if ("[object Function]" == c || "undefined" != typeof a.call && "undefined" != typeof a.propertyIsEnumerable && !a.propertyIsEnumerable("call")) return "function";
            } else return "null"; else if ("function" == b && "undefined" == typeof a.call) return "object";
            return b;
        }
        function s(a) {
            return a !== aa;
        }
        function ga(a) {
            var b = fa(a);
            return "array" == b || "object" == b && "number" == typeof a.length;
        }
        function u(a) {
            return "string" == typeof a;
        }
        function ha(a) {
            return "number" == typeof a;
        }
        function ia(a) {
            var b = typeof a;
            return "object" == b && a != k || "function" == b;
        }
        Math.floor(2147483648 * Math.random()).toString(36);
        function ja(a, b, c) {
            return a.call.apply(a.bind, arguments);
        }
        function ka(a, b, c) {
            a || g(Error());
            if (2 < arguments.length) {
                var d = Array.prototype.slice.call(arguments, 2);
                return function() {
                    var c = Array.prototype.slice.call(arguments);
                    Array.prototype.unshift.apply(c, d);
                    return a.apply(b, c);
                };
            }
            return function() {
                return a.apply(b, arguments);
            };
        }
        function v(a, b, c) {
            v = Function.prototype.bind && -1 != Function.prototype.bind.toString().indexOf("native code") ? ja : ka;
            return v.apply(k, arguments);
        }
        function la(a, b) {
            function c() {}
            c.prototype = b.prototype;
            a.Yd = b.prototype;
            a.prototype = new c();
        }
        function ma(a) {
            a = String(a);
            if (/^\s*$/.test(a) ? 0 : /^[\],:{}\s\u2028\u2029]*$/.test(a.replace(/\\["\\\/bfnrtu]/g, "@").replace(/"[^"\\\n\r\u2028\u2029\x00-\x08\x10-\x1f\x80-\x9f]*"|true|false|null|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?/g, "]").replace(/(?:^|:|,)(?:[\s\u2028\u2029]*\[)+/g, ""))) try {
                return eval("(" + a + ")");
            } catch (b) {}
            g(Error("Invalid JSON string: " + a));
        }
        function na() {
            this.gc = aa;
        }
        function oa(a, b, c) {
            switch (typeof b) {
              case "string":
                pa(b, c);
                break;

              case "number":
                c.push(isFinite(b) && !isNaN(b) ? b : "null");
                break;

              case "boolean":
                c.push(b);
                break;

              case "undefined":
                c.push("null");
                break;

              case "object":
                if (b == k) {
                    c.push("null");
                    break;
                }
                if ("array" == fa(b)) {
                    var d = b.length;
                    c.push("[");
                    for (var e = "", f = 0; f < d; f++) c.push(e), e = b[f], oa(a, a.gc ? a.gc.call(b, String(f), e) : e, c), 
                    e = ",";
                    c.push("]");
                    break;
                }
                c.push("{");
                d = "";
                for (f in b) Object.prototype.hasOwnProperty.call(b, f) && (e = b[f], "function" != typeof e && (c.push(d), 
                pa(f, c), c.push(":"), oa(a, a.gc ? a.gc.call(b, f, e) : e, c), d = ","));
                c.push("}");
                break;

              case "function":
                break;

              default:
                g(Error("Unknown type: " + typeof b));
            }
        }
        var qa = {
            '"': '\\"',
            "\\": "\\\\",
            "/": "\\/",
            "\b": "\\b",
            "\f": "\\f",
            "\n": "\\n",
            "\r": "\\r",
            "	": "\\t",
            "": "\\u000b"
        }, ra = /\uffff/.test("") ? /[\\\"\x00-\x1f\x7f-\uffff]/g : /[\\\"\x00-\x1f\x7f-\xff]/g;
        function pa(a, b) {
            b.push('"', a.replace(ra, function(a) {
                if (a in qa) return qa[a];
                var b = a.charCodeAt(0), e = "\\u";
                16 > b ? e += "000" : 256 > b ? e += "00" : 4096 > b && (e += "0");
                return qa[a] = e + b.toString(16);
            }), '"');
        }
        function sa(a) {
            return "undefined" !== typeof JSON && s(JSON.parse) ? JSON.parse(a) : ma(a);
        }
        function w(a) {
            if ("undefined" !== typeof JSON && s(JSON.stringify)) a = JSON.stringify(a); else {
                var b = [];
                oa(new na(), a, b);
                a = b.join("");
            }
            return a;
        }
        function ta(a) {
            for (var b = [], c = 0, d = 0; d < a.length; d++) {
                var e = a.charCodeAt(d);
                55296 <= e && 56319 >= e && (e -= 55296, d++, y(d < a.length, "Surrogate pair missing trail surrogate."), 
                e = 65536 + (e << 10) + (a.charCodeAt(d) - 56320));
                128 > e ? b[c++] = e : (2048 > e ? b[c++] = e >> 6 | 192 : (65536 > e ? b[c++] = e >> 12 | 224 : (b[c++] = e >> 18 | 240, 
                b[c++] = e >> 12 & 63 | 128), b[c++] = e >> 6 & 63 | 128), b[c++] = e & 63 | 128);
            }
            return b;
        }
        function z(a, b, c, d) {
            var e;
            d < b ? e = "at least " + b : d > c && (e = 0 === c ? "none" : "no more than " + c);
            e && g(Error(a + " failed: Was called with " + d + (1 === d ? " argument." : " arguments.") + " Expects " + e + "."));
        }
        function A(a, b, c) {
            var d = "";
            switch (b) {
              case 1:
                d = c ? "first" : "First";
                break;

              case 2:
                d = c ? "second" : "Second";
                break;

              case 3:
                d = c ? "third" : "Third";
                break;

              case 4:
                d = c ? "fourth" : "Fourth";
                break;

              default:
                ua.assert(l, "errorPrefix_ called with argumentNumber > 4.  Need to update it?");
            }
            return a + " failed: " + (d + " argument ");
        }
        function B(a, b, c, d) {
            (!d || s(c)) && "function" != fa(c) && g(Error(A(a, b, d) + "must be a valid function."));
        }
        function va(a, b, c) {
            s(c) && (!ia(c) || c === k) && g(Error(A(a, b, j) + "must be a valid context object."));
        }
        function C(a, b) {
            return Object.prototype.hasOwnProperty.call(a, b);
        }
        function wa(a, b) {
            if (Object.prototype.hasOwnProperty.call(a, b)) return a[b];
        }
        var ua = {}, xa = /[\[\].#$\/]/, ya = /[\[\].#$]/;
        function za(a) {
            return u(a) && 0 !== a.length && !xa.test(a);
        }
        function Aa(a, b, c) {
            (!c || s(b)) && Ba(A(a, 1, c), b);
        }
        function Ba(a, b, c, d) {
            c || (c = 0);
            d || (d = []);
            s(b) || g(Error(a + "contains undefined" + Ca(d)));
            "function" == fa(b) && g(Error(a + "contains a function" + Ca(d) + " with contents: " + b.toString()));
            Da(b) && g(Error(a + "contains " + b.toString() + Ca(d)));
            1e3 < c && g(new TypeError(a + "contains a cyclic object value (" + d.slice(0, 100).join(".") + "...)"));
            u(b) && (b.length > 10485760 / 3 && 10485760 < ta(b).length) && g(Error(a + "contains a string greater than 10485760 utf8 bytes" + Ca(d) + " ('" + b.substring(0, 50) + "...')"));
            if (ia(b)) for (var e in b) C(b, e) && (".priority" !== e && (".value" !== e && ".sv" !== e && !za(e)) && g(Error(a + "contains an invalid key (" + e + ")" + Ca(d) + '.  Keys must be non-empty strings and can\'t contain ".", "#", "$", "/", "[", or "]"')), 
            d.push(e), Ba(a, b[e], c + 1, d), d.pop());
        }
        function Ca(a) {
            return 0 == a.length ? "" : " in property '" + a.join(".") + "'";
        }
        function Ea(a, b) {
            ia(b) || g(Error(A(a, 1, l) + " must be an object containing the children to replace."));
            Aa(a, b, l);
        }
        function Fa(a, b, c, d) {
            if (!d || s(c)) c !== k && (!ha(c) && !u(c) && (!ia(c) || !C(c, ".sv"))) && g(Error(A(a, b, d) + "must be a valid firebase priority (a string, number, or null)."));
        }
        function Ga(a, b, c) {
            if (!c || s(b)) switch (b) {
              case "value":
              case "child_added":
              case "child_removed":
              case "child_changed":
              case "child_moved":
                break;

              default:
                g(Error(A(a, 1, c) + 'must be a valid event type: "value", "child_added", "child_removed", "child_changed", or "child_moved".'));
            }
        }
        function Ha(a, b) {
            s(b) && !za(b) && g(Error(A(a, 2, j) + 'was an invalid key: "' + b + '".  Firebase keys must be non-empty strings and can\'t contain ".", "#", "$", "/", "[", or "]").'));
        }
        function Ia(a, b) {
            (!u(b) || 0 === b.length || ya.test(b)) && g(Error(A(a, 1, l) + 'was an invalid path: "' + b + '". Paths must be non-empty strings and can\'t contain ".", "#", "$", "[", or "]"'));
        }
        function D(a, b) {
            ".info" === E(b) && g(Error(a + " failed: Can't modify data under /.info/"));
        }
        function F(a, b, c, d, e, f, h) {
            this.n = a;
            this.path = b;
            this.Da = c;
            this.da = d;
            this.va = e;
            this.Ba = f;
            this.Ra = h;
            s(this.da) && (s(this.Ba) && s(this.Da)) && g("Query: Can't combine startAt(), endAt(), and limit().");
        }
        F.prototype.Nc = function() {
            z("Query.ref", 0, 0, arguments.length);
            return new H(this.n, this.path);
        };
        F.prototype.ref = F.prototype.Nc;
        F.prototype.Xa = function(a, b) {
            z("Query.on", 2, 4, arguments.length);
            Ga("Query.on", a, l);
            B("Query.on", 2, b, l);
            var c = Ja("Query.on", arguments[2], arguments[3]);
            this.n.Mb(this, a, b, c.cancel, c.T);
            return b;
        };
        F.prototype.on = F.prototype.Xa;
        F.prototype.ub = function(a, b, c) {
            z("Query.off", 0, 3, arguments.length);
            Ga("Query.off", a, j);
            B("Query.off", 2, b, j);
            va("Query.off", 3, c);
            this.n.fc(this, a, b, c);
        };
        F.prototype.off = F.prototype.ub;
        F.prototype.Ld = function(a, b) {
            function c(h) {
                f && (f = l, e.ub(a, c), b.call(d.T, h));
            }
            z("Query.once", 2, 4, arguments.length);
            Ga("Query.once", a, l);
            B("Query.once", 2, b, l);
            var d = Ja("Query.once", arguments[2], arguments[3]), e = this, f = j;
            this.Xa(a, c, function(b) {
                e.ub(a, c);
                d.cancel && d.cancel.call(d.T, b);
            });
        };
        F.prototype.once = F.prototype.Ld;
        F.prototype.Ed = function(a) {
            z("Query.limit", 1, 1, arguments.length);
            (!ha(a) || Math.floor(a) !== a || 0 >= a) && g("Query.limit: First argument must be a positive integer.");
            return new F(this.n, this.path, a, this.da, this.va, this.Ba, this.Ra);
        };
        F.prototype.limit = F.prototype.Ed;
        F.prototype.Ud = function(a, b) {
            z("Query.startAt", 0, 2, arguments.length);
            Fa("Query.startAt", 1, a, j);
            Ha("Query.startAt", b);
            s(a) || (b = a = k);
            return new F(this.n, this.path, this.Da, a, b, this.Ba, this.Ra);
        };
        F.prototype.startAt = F.prototype.Ud;
        F.prototype.zd = function(a, b) {
            z("Query.endAt", 0, 2, arguments.length);
            Fa("Query.endAt", 1, a, j);
            Ha("Query.endAt", b);
            return new F(this.n, this.path, this.Da, this.da, this.va, a, b);
        };
        F.prototype.endAt = F.prototype.zd;
        function Ka(a) {
            var b = {};
            s(a.da) && (b.sp = a.da);
            s(a.va) && (b.sn = a.va);
            s(a.Ba) && (b.ep = a.Ba);
            s(a.Ra) && (b.en = a.Ra);
            s(a.Da) && (b.l = a.Da);
            s(a.da) && (s(a.va) && a.da === k && a.va === k) && (b.vf = "l");
            return b;
        }
        F.prototype.La = function() {
            var a = La(Ka(this));
            return "{}" === a ? "default" : a;
        };
        function Ja(a, b, c) {
            var d = {};
            b && c ? (d.cancel = b, B(a, 3, d.cancel, j), d.T = c, va(a, 4, d.T)) : b && ("object" === typeof b && b !== k ? d.T = b : "function" === typeof b ? d.cancel = b : g(Error(A(a, 3, j) + "must either be a cancel callback or a context object.")));
            return d;
        }
        function J(a) {
            if (a instanceof J) return a;
            if (1 == arguments.length) {
                this.m = a.split("/");
                for (var b = 0, c = 0; c < this.m.length; c++) 0 < this.m[c].length && (this.m[b] = this.m[c], 
                b++);
                this.m.length = b;
                this.Z = 0;
            } else this.m = arguments[0], this.Z = arguments[1];
        }
        function E(a) {
            return a.Z >= a.m.length ? k : a.m[a.Z];
        }
        function Ma(a) {
            var b = a.Z;
            b < a.m.length && b++;
            return new J(a.m, b);
        }
        r = J.prototype;
        r.toString = function() {
            for (var a = "", b = this.Z; b < this.m.length; b++) "" !== this.m[b] && (a += "/" + this.m[b]);
            return a || "/";
        };
        r.parent = function() {
            if (this.Z >= this.m.length) return k;
            for (var a = [], b = this.Z; b < this.m.length - 1; b++) a.push(this.m[b]);
            return new J(a, 0);
        };
        r.F = function(a) {
            for (var b = [], c = this.Z; c < this.m.length; c++) b.push(this.m[c]);
            if (a instanceof J) for (c = a.Z; c < a.m.length; c++) b.push(a.m[c]); else {
                a = a.split("/");
                for (c = 0; c < a.length; c++) 0 < a[c].length && b.push(a[c]);
            }
            return new J(b, 0);
        };
        r.f = function() {
            return this.Z >= this.m.length;
        };
        function Na(a, b) {
            var c = E(a);
            if (c === k) return b;
            if (c === E(b)) return Na(Ma(a), Ma(b));
            g("INTERNAL ERROR: innerPath (" + b + ") is not within outerPath (" + a + ")");
        }
        r.contains = function(a) {
            var b = 0;
            if (this.m.length > a.m.length) return l;
            for (;b < this.m.length; ) {
                if (this.m[b] !== a.m[b]) return l;
                ++b;
            }
            return j;
        };
        function Oa() {
            this.children = {};
            this.sc = 0;
            this.value = k;
        }
        function Pa(a, b, c) {
            this.Ea = a ? a : "";
            this.Ab = b ? b : k;
            this.z = c ? c : new Oa();
        }
        function K(a, b) {
            for (var c = b instanceof J ? b : new J(b), d = a, e; (e = E(c)) !== k; ) d = new Pa(e, d, wa(d.z.children, e) || new Oa()), 
            c = Ma(c);
            return d;
        }
        r = Pa.prototype;
        r.k = function() {
            return this.z.value;
        };
        function Qa(a, b) {
            y("undefined" !== typeof b);
            a.z.value = b;
            Ra(a);
        }
        r.nb = function() {
            return 0 < this.z.sc;
        };
        r.f = function() {
            return this.k() === k && !this.nb();
        };
        r.w = function(a) {
            for (var b in this.z.children) a(new Pa(b, this, this.z.children[b]));
        };
        function Sa(a, b, c, d) {
            c && !d && b(a);
            a.w(function(a) {
                Sa(a, b, j, d);
            });
            c && d && b(a);
        }
        function Ta(a, b, c) {
            for (a = c ? a : a.parent(); a !== k; ) {
                if (b(a)) return j;
                a = a.parent();
            }
            return l;
        }
        r.path = function() {
            return new J(this.Ab === k ? this.Ea : this.Ab.path() + "/" + this.Ea);
        };
        r.name = ba("Ea");
        r.parent = ba("Ab");
        function Ra(a) {
            if (a.Ab !== k) {
                var b = a.Ab, c = a.Ea, d = a.f(), e = C(b.z.children, c);
                d && e ? (delete b.z.children[c], b.z.sc--, Ra(b)) : !d && !e && (b.z.children[c] = a.z, 
                b.z.sc++, Ra(b));
            }
        }
        function Ua(a, b) {
            this.Oa = a ? a : Va;
            this.ca = b ? b : Wa;
        }
        function Va(a, b) {
            return a < b ? -1 : a > b ? 1 : 0;
        }
        r = Ua.prototype;
        r.oa = function(a, b) {
            return new Ua(this.Oa, this.ca.oa(a, b, this.Oa).copy(k, k, l, k, k));
        };
        r.remove = function(a) {
            return new Ua(this.Oa, this.ca.remove(a, this.Oa).copy(k, k, l, k, k));
        };
        r.get = function(a) {
            for (var b, c = this.ca; !c.f(); ) {
                b = this.Oa(a, c.key);
                if (0 === b) return c.value;
                0 > b ? c = c.left : 0 < b && (c = c.right);
            }
            return k;
        };
        function Xa(a, b) {
            for (var c, d = a.ca, e = k; !d.f(); ) {
                c = a.Oa(b, d.key);
                if (0 === c) {
                    if (d.left.f()) return e ? e.key : k;
                    for (d = d.left; !d.right.f(); ) d = d.right;
                    return d.key;
                }
                0 > c ? d = d.left : 0 < c && (e = d, d = d.right);
            }
            g(Error("Attempted to find predecessor key for a nonexistent key.  What gives?"));
        }
        r.f = function() {
            return this.ca.f();
        };
        r.count = function() {
            return this.ca.count();
        };
        r.tb = function() {
            return this.ca.tb();
        };
        r.Va = function() {
            return this.ca.Va();
        };
        r.Ca = function(a) {
            return this.ca.Ca(a);
        };
        r.Ma = function(a) {
            return this.ca.Ma(a);
        };
        r.Ua = function(a) {
            return new Ya(this.ca, a);
        };
        function Ya(a, b) {
            this.md = b;
            for (this.Tb = []; !a.f(); ) this.Tb.push(a), a = a.left;
        }
        function Za(a) {
            if (0 === a.Tb.length) return k;
            var b = a.Tb.pop(), c;
            c = a.md ? a.md(b.key, b.value) : {
                key: b.key,
                value: b.value
            };
            for (b = b.right; !b.f(); ) a.Tb.push(b), b = b.left;
            return c;
        }
        function $a(a, b, c, d, e) {
            this.key = a;
            this.value = b;
            this.color = c != k ? c : j;
            this.left = d != k ? d : Wa;
            this.right = e != k ? e : Wa;
        }
        r = $a.prototype;
        r.copy = function(a, b, c, d, e) {
            return new $a(a != k ? a : this.key, b != k ? b : this.value, c != k ? c : this.color, d != k ? d : this.left, e != k ? e : this.right);
        };
        r.count = function() {
            return this.left.count() + 1 + this.right.count();
        };
        r.f = o(l);
        r.Ca = function(a) {
            return this.left.Ca(a) || a(this.key, this.value) || this.right.Ca(a);
        };
        r.Ma = function(a) {
            return this.right.Ma(a) || a(this.key, this.value) || this.left.Ma(a);
        };
        function ab(a) {
            return a.left.f() ? a : ab(a.left);
        }
        r.tb = function() {
            return ab(this).key;
        };
        r.Va = function() {
            return this.right.f() ? this.key : this.right.Va();
        };
        r.oa = function(a, b, c) {
            var d, e;
            e = this;
            d = c(a, e.key);
            e = 0 > d ? e.copy(k, k, k, e.left.oa(a, b, c), k) : 0 === d ? e.copy(k, b, k, k, k) : e.copy(k, k, k, k, e.right.oa(a, b, c));
            return db(e);
        };
        function eb(a) {
            if (a.left.f()) return Wa;
            !a.left.O() && !a.left.left.O() && (a = fb(a));
            a = a.copy(k, k, k, eb(a.left), k);
            return db(a);
        }
        r.remove = function(a, b) {
            var c, d;
            c = this;
            if (0 > b(a, c.key)) !c.left.f() && (!c.left.O() && !c.left.left.O()) && (c = fb(c)), 
            c = c.copy(k, k, k, c.left.remove(a, b), k); else {
                c.left.O() && (c = gb(c));
                !c.right.f() && (!c.right.O() && !c.right.left.O()) && (c = hb(c), c.left.left.O() && (c = gb(c), 
                c = hb(c)));
                if (0 === b(a, c.key)) {
                    if (c.right.f()) return Wa;
                    d = ab(c.right);
                    c = c.copy(d.key, d.value, k, k, eb(c.right));
                }
                c = c.copy(k, k, k, k, c.right.remove(a, b));
            }
            return db(c);
        };
        r.O = ba("color");
        function db(a) {
            a.right.O() && !a.left.O() && (a = ib(a));
            a.left.O() && a.left.left.O() && (a = gb(a));
            a.left.O() && a.right.O() && (a = hb(a));
            return a;
        }
        function fb(a) {
            a = hb(a);
            a.right.left.O() && (a = a.copy(k, k, k, k, gb(a.right)), a = ib(a), a = hb(a));
            return a;
        }
        function ib(a) {
            var b;
            b = a.copy(k, k, j, k, a.right.left);
            return a.right.copy(k, k, a.color, b, k);
        }
        function gb(a) {
            var b;
            b = a.copy(k, k, j, a.left.right, k);
            return a.left.copy(k, k, a.color, k, b);
        }
        function hb(a) {
            var b, c;
            b = a.left.copy(k, k, !a.left.color, k, k);
            c = a.right.copy(k, k, !a.right.color, k, k);
            return a.copy(k, k, !a.color, b, c);
        }
        function jb() {}
        r = jb.prototype;
        r.copy = function() {
            return this;
        };
        r.oa = function(a, b) {
            return new $a(a, b, aa, aa, aa);
        };
        r.remove = function() {
            return this;
        };
        r.count = o(0);
        r.f = o(j);
        r.Ca = o(l);
        r.Ma = o(l);
        r.tb = o(k);
        r.Va = o(k);
        r.O = o(l);
        var Wa = new jb();
        function kb(a) {
            this.Pb = a;
            this.bc = "firebase:";
        }
        kb.prototype.set = function(a, b) {
            b == k ? this.Pb.removeItem(this.bc + a) : this.Pb.setItem(this.bc + a, w(b));
        };
        kb.prototype.get = function(a) {
            a = this.Pb.getItem(this.bc + a);
            return a == k ? k : sa(a);
        };
        kb.prototype.remove = function(a) {
            this.Pb.removeItem(this.bc + a);
        };
        function lb() {
            this.ib = {};
        }
        lb.prototype.set = function(a, b) {
            b == k ? delete this.ib[a] : this.ib[a] = b;
        };
        lb.prototype.get = function(a) {
            return C(this.ib, a) ? this.ib[a] : k;
        };
        lb.prototype.remove = function(a) {
            delete this.ib[a];
        };
        function mb(a) {
            try {
                if ("undefined" !== typeof window && "undefined" !== typeof window[a]) {
                    var b = window[a];
                    b.setItem("firebase:sentinel", "cache");
                    b.removeItem("firebase:sentinel");
                    return new kb(b);
                }
            } catch (c) {}
            return new lb();
        }
        var nb = mb("localStorage"), ob = mb("sessionStorage");
        function pb(a, b, c, d) {
            this.host = a.toLowerCase();
            this.domain = this.host.substr(this.host.indexOf(".") + 1);
            this.hc = b;
            this.Sb = c;
            this.fa = d || nb.get("host:" + a) || this.host;
        }
        function qb(a, b) {
            b !== a.fa && (a.fa = b, "s-" === a.fa.substr(0, 2) && nb.set("host:" + a.host, a.fa));
        }
        pb.prototype.toString = function() {
            return (this.hc ? "https://" : "http://") + this.host;
        };
        function rb() {}
        function sb() {
            this.B = [];
            this.rc = [];
            this.ud = [];
            this.Zb = [];
            this.Zb[0] = 128;
            for (var a = 1; 64 > a; ++a) this.Zb[a] = 0;
            this.reset();
        }
        la(sb, rb);
        sb.prototype.reset = function() {
            this.B[0] = 1732584193;
            this.B[1] = 4023233417;
            this.B[2] = 2562383102;
            this.B[3] = 271733878;
            this.B[4] = 3285377520;
            this.Vc = this.ob = 0;
        };
        function tb(a, b) {
            var c;
            c || (c = 0);
            for (var d = a.ud, e = c; e < c + 64; e += 4) d[e / 4] = b[e] << 24 | b[e + 1] << 16 | b[e + 2] << 8 | b[e + 3];
            for (e = 16; 80 > e; e++) {
                var f = d[e - 3] ^ d[e - 8] ^ d[e - 14] ^ d[e - 16];
                d[e] = (f << 1 | f >>> 31) & 4294967295;
            }
            c = a.B[0];
            for (var h = a.B[1], i = a.B[2], m = a.B[3], n = a.B[4], p, e = 0; 80 > e; e++) 40 > e ? 20 > e ? (f = m ^ h & (i ^ m), 
            p = 1518500249) : (f = h ^ i ^ m, p = 1859775393) : 60 > e ? (f = h & i | m & (h | i), 
            p = 2400959708) : (f = h ^ i ^ m, p = 3395469782), f = (c << 5 | c >>> 27) + f + n + p + d[e] & 4294967295, 
            n = m, m = i, i = (h << 30 | h >>> 2) & 4294967295, h = c, c = f;
            a.B[0] = a.B[0] + c & 4294967295;
            a.B[1] = a.B[1] + h & 4294967295;
            a.B[2] = a.B[2] + i & 4294967295;
            a.B[3] = a.B[3] + m & 4294967295;
            a.B[4] = a.B[4] + n & 4294967295;
        }
        sb.prototype.update = function(a, b) {
            s(b) || (b = a.length);
            var c = this.rc, d = this.ob, e = 0;
            if (u(a)) for (;e < b; ) c[d++] = a.charCodeAt(e++), 64 == d && (tb(this, c), d = 0); else for (;e < b; ) c[d++] = a[e++], 
            64 == d && (tb(this, c), d = 0);
            this.ob = d;
            this.Vc += b;
        };
        var ub = Array.prototype, vb = ub.forEach ? function(a, b, c) {
            ub.forEach.call(a, b, c);
        } : function(a, b, c) {
            for (var d = a.length, e = u(a) ? a.split("") : a, f = 0; f < d; f++) f in e && b.call(c, e[f], f, a);
        }, wb = ub.map ? function(a, b, c) {
            return ub.map.call(a, b, c);
        } : function(a, b, c) {
            for (var d = a.length, e = Array(d), f = u(a) ? a.split("") : a, h = 0; h < d; h++) h in f && (e[h] = b.call(c, f[h], h, a));
            return e;
        }, xb = ub.every ? function(a, b, c) {
            return ub.every.call(a, b, c);
        } : function(a, b, c) {
            for (var d = a.length, e = u(a) ? a.split("") : a, f = 0; f < d; f++) if (f in e && !b.call(c, e[f], f, a)) return l;
            return j;
        };
        var yb, zb, Ab, Bb;
        function Cb() {
            return ca.navigator ? ca.navigator.userAgent : k;
        }
        Bb = Ab = zb = yb = l;
        var Db;
        if (Db = Cb()) {
            var Eb = ca.navigator;
            yb = 0 == Db.indexOf("Opera");
            zb = !yb && -1 != Db.indexOf("MSIE");
            Ab = !yb && -1 != Db.indexOf("WebKit");
            Bb = !yb && !Ab && "Gecko" == Eb.product;
        }
        var Fb = zb, Gb = Bb, Hb = Ab;
        var Ib;
        if (yb && ca.opera) {
            var Jb = ca.opera.version;
            "function" == typeof Jb && Jb();
        } else Gb ? Ib = /rv\:([^\);]+)(\)|;)/ : Fb ? Ib = /MSIE\s+([^\);]+)(\)|;)/ : Hb && (Ib = /WebKit\/(\S+)/), 
        Ib && Ib.exec(Cb());
        var Kb = k, Lb = k;
        function Mb(a, b) {
            ga(a) || g(Error("encodeByteArray takes an array as a parameter"));
            if (!Kb) {
                Kb = {};
                Lb = {};
                for (var c = 0; 65 > c; c++) Kb[c] = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=".charAt(c), 
                Lb[c] = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_.".charAt(c);
            }
            for (var c = b ? Lb : Kb, d = [], e = 0; e < a.length; e += 3) {
                var f = a[e], h = e + 1 < a.length, i = h ? a[e + 1] : 0, m = e + 2 < a.length, n = m ? a[e + 2] : 0, p = f >> 2, f = (f & 3) << 4 | i >> 4, i = (i & 15) << 2 | n >> 6, n = n & 63;
                m || (n = 64, h || (i = 64));
                d.push(c[p], c[f], c[i], c[n]);
            }
            return d.join("");
        }
        var Nb, Ob = 1;
        Nb = function() {
            return Ob++;
        };
        function y(a, b) {
            a || g(Error("Firebase INTERNAL ASSERT FAILED:" + b));
        }
        function Pb(a) {
            var b = ta(a), a = new sb();
            a.update(b);
            var b = [], c = 8 * a.Vc;
            56 > a.ob ? a.update(a.Zb, 56 - a.ob) : a.update(a.Zb, 64 - (a.ob - 56));
            for (var d = 63; 56 <= d; d--) a.rc[d] = c & 255, c /= 256;
            tb(a, a.rc);
            for (d = c = 0; 5 > d; d++) for (var e = 24; 0 <= e; e -= 8) b[c++] = a.B[d] >> e & 255;
            return Mb(b);
        }
        function Qb() {
            for (var a = "", b = 0; b < arguments.length; b++) a = ga(arguments[b]) ? a + Qb.apply(k, arguments[b]) : "object" === typeof arguments[b] ? a + w(arguments[b]) : a + arguments[b], 
            a += " ";
            return a;
        }
        var Rb = k, Sb = j;
        function L() {
            Sb === j && (Sb = l, Rb === k && ob.get("logging_enabled") === j && Tb(j));
            if (Rb) {
                var a = Qb.apply(k, arguments);
                Rb(a);
            }
        }
        function Ub(a) {
            return function() {
                L(a, arguments);
            };
        }
        function Vb() {
            if ("undefined" !== typeof console) {
                var a = "FIREBASE INTERNAL ERROR: " + Qb.apply(k, arguments);
                "undefined" !== typeof console.error ? console.error(a) : console.log(a);
            }
        }
        function Wb() {
            var a = Qb.apply(k, arguments);
            g(Error("FIREBASE FATAL ERROR: " + a));
        }
        function M() {
            if ("undefined" !== typeof console) {
                var a = "FIREBASE WARNING: " + Qb.apply(k, arguments);
                "undefined" !== typeof console.warn ? console.warn(a) : console.log(a);
            }
        }
        function Da(a) {
            return ha(a) && (a != a || a == Number.POSITIVE_INFINITY || a == Number.NEGATIVE_INFINITY);
        }
        function Xb(a, b) {
            return a !== b ? a === k ? -1 : b === k ? 1 : typeof a !== typeof b ? "number" === typeof a ? -1 : 1 : a > b ? 1 : -1 : 0;
        }
        function Yb(a, b) {
            if (a === b) return 0;
            var c = Zb(a), d = Zb(b);
            return c !== k ? d !== k ? c - d : -1 : d !== k ? 1 : a < b ? -1 : 1;
        }
        function $b(a, b) {
            if (b && a in b) return b[a];
            g(Error("Missing required key (" + a + ") in object: " + w(b)));
        }
        function La(a) {
            if ("object" !== typeof a || a === k) return w(a);
            var b = [], c;
            for (c in a) b.push(c);
            b.sort();
            c = "{";
            for (var d = 0; d < b.length; d++) 0 !== d && (c += ","), c += w(b[d]), c += ":", 
            c += La(a[b[d]]);
            return c + "}";
        }
        function ac(a, b) {
            if (a.length <= b) return [ a ];
            for (var c = [], d = 0; d < a.length; d += b) d + b > a ? c.push(a.substring(d, a.length)) : c.push(a.substring(d, d + b));
            return c;
        }
        function bc(a, b) {
            if ("array" == fa(a)) for (var c = 0; c < a.length; ++c) b(c, a[c]); else cc(a, b);
        }
        function dc(a) {
            y(!Da(a));
            var b, c, d, e;
            0 === a ? (d = c = 0, b = -Infinity === 1 / a ? 1 : 0) : (b = 0 > a, a = Math.abs(a), 
            a >= Math.pow(2, -1022) ? (d = Math.min(Math.floor(Math.log(a) / Math.LN2), 1023), 
            c = d + 1023, d = Math.round(a * Math.pow(2, 52 - d) - Math.pow(2, 52))) : (c = 0, 
            d = Math.round(a / Math.pow(2, -1074))));
            e = [];
            for (a = 52; a; a -= 1) e.push(d % 2 ? 1 : 0), d = Math.floor(d / 2);
            for (a = 11; a; a -= 1) e.push(c % 2 ? 1 : 0), c = Math.floor(c / 2);
            e.push(b ? 1 : 0);
            e.reverse();
            b = e.join("");
            c = "";
            for (a = 0; 64 > a; a += 8) d = parseInt(b.substr(a, 8), 2).toString(16), 1 === d.length && (d = "0" + d), 
            c += d;
            return c.toLowerCase();
        }
        var ec = /^-?\d{1,10}$/;
        function Zb(a) {
            return ec.test(a) && (a = Number(a), -2147483648 <= a && 2147483647 >= a) ? a : k;
        }
        function fc(a) {
            try {
                a();
            } catch (b) {
                setTimeout(function() {
                    g(b);
                });
            }
        }
        function gc(a, b) {
            this.D = a;
            y(this.D !== k, "LeafNode shouldn't be created with null value.");
            this.Ya = "undefined" !== typeof b ? b : k;
        }
        r = gc.prototype;
        r.N = o(j);
        r.j = ba("Ya");
        r.za = function(a) {
            return new gc(this.D, a);
        };
        r.M = function() {
            return N;
        };
        r.Q = function(a) {
            return E(a) === k ? this : N;
        };
        r.ea = o(k);
        r.H = function(a, b) {
            return new O().H(a, b).za(this.Ya);
        };
        r.ya = function(a, b) {
            var c = E(a);
            return c === k ? b : this.H(c, N.ya(Ma(a), b));
        };
        r.f = o(l);
        r.Ub = o(0);
        r.V = function(a) {
            return a && this.j() !== k ? {
                ".value": this.k(),
                ".priority": this.j()
            } : this.k();
        };
        r.hash = function() {
            var a = "";
            this.j() !== k && (a += "priority:" + hc(this.j()) + ":");
            var b = typeof this.D, a = a + (b + ":"), a = "number" === b ? a + dc(this.D) : a + this.D;
            return Pb(a);
        };
        r.k = ba("D");
        r.toString = function() {
            return "string" === typeof this.D ? '"' + this.D + '"' : this.D;
        };
        function ic(a, b) {
            return Xb(a.ia, b.ia) || Yb(a.name, b.name);
        }
        function jc(a, b) {
            return Yb(a.name, b.name);
        }
        function kc(a, b) {
            return Yb(a, b);
        }
        function O(a, b) {
            this.o = a || new Ua(kc);
            this.Ya = "undefined" !== typeof b ? b : k;
        }
        r = O.prototype;
        r.N = o(l);
        r.j = ba("Ya");
        r.za = function(a) {
            return new O(this.o, a);
        };
        r.H = function(a, b) {
            var c = this.o.remove(a);
            b && b.f() && (b = k);
            b !== k && (c = c.oa(a, b));
            return b && b.j() !== k ? new lc(c, k, this.Ya) : new O(c, this.Ya);
        };
        r.ya = function(a, b) {
            var c = E(a);
            if (c === k) return b;
            var d = this.M(c).ya(Ma(a), b);
            return this.H(c, d);
        };
        r.f = function() {
            return this.o.f();
        };
        r.Ub = function() {
            return this.o.count();
        };
        var mc = /^\d+$/;
        r = O.prototype;
        r.V = function(a) {
            if (this.f()) return k;
            var b = {}, c = 0, d = 0, e = j;
            this.w(function(f, h) {
                b[f] = h.V(a);
                c++;
                e && mc.test(f) ? d = Math.max(d, Number(f)) : e = l;
            });
            if (!a && e && d < 2 * c) {
                var f = [], h;
                for (h in b) f[h] = b[h];
                return f;
            }
            a && this.j() !== k && (b[".priority"] = this.j());
            return b;
        };
        r.hash = function() {
            var a = "";
            this.j() !== k && (a += "priority:" + hc(this.j()) + ":");
            this.w(function(b, c) {
                var d = c.hash();
                "" !== d && (a += ":" + b + ":" + d);
            });
            return "" === a ? "" : Pb(a);
        };
        r.M = function(a) {
            a = this.o.get(a);
            return a === k ? N : a;
        };
        r.Q = function(a) {
            var b = E(a);
            return b === k ? this : this.M(b).Q(Ma(a));
        };
        r.ea = function(a) {
            return Xa(this.o, a);
        };
        r.cd = function() {
            return this.o.tb();
        };
        r.dd = function() {
            return this.o.Va();
        };
        r.w = function(a) {
            return this.o.Ca(a);
        };
        r.yc = function(a) {
            return this.o.Ma(a);
        };
        r.Ua = function() {
            return this.o.Ua();
        };
        r.toString = function() {
            var a = "{", b = j;
            this.w(function(c, d) {
                b ? b = l : a += ", ";
                a += '"' + c + '" : ' + d.toString();
            });
            return a += "}";
        };
        var N = new O();
        function lc(a, b, c) {
            O.call(this, a, c);
            b === k && (b = new Ua(ic), a.Ca(function(a, c) {
                b = b.oa({
                    name: a,
                    ia: c.j()
                }, c);
            }));
            this.ua = b;
        }
        la(lc, O);
        r = lc.prototype;
        r.H = function(a, b) {
            var c = this.M(a), d = this.o, e = this.ua;
            c !== k && (d = d.remove(a), e = e.remove({
                name: a,
                ia: c.j()
            }));
            b && b.f() && (b = k);
            b !== k && (d = d.oa(a, b), e = e.oa({
                name: a,
                ia: b.j()
            }, b));
            return new lc(d, e, this.j());
        };
        r.ea = function(a, b) {
            var c = Xa(this.ua, {
                name: a,
                ia: b.j()
            });
            return c ? c.name : k;
        };
        r.w = function(a) {
            return this.ua.Ca(function(b, c) {
                return a(b.name, c);
            });
        };
        r.yc = function(a) {
            return this.ua.Ma(function(b, c) {
                return a(b.name, c);
            });
        };
        r.Ua = function() {
            return this.ua.Ua(function(a, b) {
                return {
                    key: a.name,
                    value: b
                };
            });
        };
        r.cd = function() {
            return this.ua.f() ? k : this.ua.tb().name;
        };
        r.dd = function() {
            return this.ua.f() ? k : this.ua.Va().name;
        };
        function Q(a, b) {
            if (a === k) return N;
            var c = k;
            "object" === typeof a && ".priority" in a ? c = a[".priority"] : "undefined" !== typeof b && (c = b);
            y(c === k || "string" === typeof c || "number" === typeof c || "object" === typeof c && ".sv" in c);
            "object" === typeof a && (".value" in a && a[".value"] !== k) && (a = a[".value"]);
            if ("object" !== typeof a || ".sv" in a) return new gc(a, c);
            if (a instanceof Array) {
                var d = N;
                cc(a, function(b, c) {
                    if (C(a, c) && "." !== c.substring(0, 1)) {
                        var e = Q(b);
                        if (e.N() || !e.f()) d = d.H(c, e);
                    }
                });
                return d.za(c);
            }
            var e = [], f = {}, h = l;
            bc(a, function(b, c) {
                if ("string" !== typeof c || "." !== c.substring(0, 1)) {
                    var d = Q(a[c]);
                    d.f() || (h = h || d.j() !== k, e.push({
                        name: c,
                        ia: d.j()
                    }), f[c] = d);
                }
            });
            var i = nc(e, f, l);
            if (h) {
                var m = nc(e, f, j);
                return new lc(i, m, c);
            }
            return new O(i, c);
        }
        var oc = Math.log(2);
        function qc(a) {
            this.count = parseInt(Math.log(a + 1) / oc);
            this.$c = this.count - 1;
            this.wd = a + 1 & parseInt(Array(this.count + 1).join("1"), 2);
        }
        function nc(a, b, c) {
            function d(d, f) {
                var h = n - d, p = n;
                n -= d;
                var q = a[h].name, h = new $a(c ? a[h] : q, b[q], f, k, e(h + 1, p));
                i ? i.left = h : m = h;
                i = h;
            }
            function e(d, f) {
                var h = f - d;
                if (0 == h) return k;
                if (1 == h) {
                    var h = a[d].name, i = c ? a[d] : h;
                    return new $a(i, b[h], l, k, k);
                }
                var i = parseInt(h / 2) + d, m = e(d, i), n = e(i + 1, f), h = a[i].name, i = c ? a[i] : h;
                return new $a(i, b[h], l, m, n);
            }
            var f = c ? ic : jc;
            a.sort(f);
            var h, f = new qc(a.length), i = k, m = k, n = a.length;
            for (h = 0; h < f.count; ++h) {
                var p = !(f.wd & 1 << f.$c);
                f.$c--;
                var q = Math.pow(2, f.count - (h + 1));
                p ? d(q, l) : (d(q, l), d(q, j));
            }
            h = m;
            f = c ? ic : kc;
            return h !== k ? new Ua(f, h) : new Ua(f);
        }
        function hc(a) {
            return "number" === typeof a ? "number:" + dc(a) : "string:" + a;
        }
        function R(a, b) {
            this.z = a;
            this.ec = b;
        }
        R.prototype.V = function() {
            z("Firebase.DataSnapshot.val", 0, 0, arguments.length);
            return this.z.V();
        };
        R.prototype.val = R.prototype.V;
        R.prototype.Ad = function() {
            z("Firebase.DataSnapshot.exportVal", 0, 0, arguments.length);
            return this.z.V(j);
        };
        R.prototype.exportVal = R.prototype.Ad;
        R.prototype.F = function(a) {
            z("Firebase.DataSnapshot.child", 0, 1, arguments.length);
            ha(a) && (a = String(a));
            Ia("Firebase.DataSnapshot.child", a);
            var b = new J(a), c = this.ec.F(b);
            return new R(this.z.Q(b), c);
        };
        R.prototype.child = R.prototype.F;
        R.prototype.Cc = function(a) {
            z("Firebase.DataSnapshot.hasChild", 1, 1, arguments.length);
            Ia("Firebase.DataSnapshot.hasChild", a);
            var b = new J(a);
            return !this.z.Q(b).f();
        };
        R.prototype.hasChild = R.prototype.Cc;
        R.prototype.j = function() {
            z("Firebase.DataSnapshot.getPriority", 0, 0, arguments.length);
            return this.z.j();
        };
        R.prototype.getPriority = R.prototype.j;
        R.prototype.forEach = function(a) {
            z("Firebase.DataSnapshot.forEach", 1, 1, arguments.length);
            B("Firebase.DataSnapshot.forEach", 1, a, l);
            if (this.z.N()) return l;
            var b = this;
            return this.z.w(function(c, d) {
                return a(new R(d, b.ec.F(c)));
            });
        };
        R.prototype.forEach = R.prototype.forEach;
        R.prototype.nb = function() {
            z("Firebase.DataSnapshot.hasChildren", 0, 0, arguments.length);
            return this.z.N() ? l : !this.z.f();
        };
        R.prototype.hasChildren = R.prototype.nb;
        R.prototype.name = function() {
            z("Firebase.DataSnapshot.name", 0, 0, arguments.length);
            return this.ec.name();
        };
        R.prototype.name = R.prototype.name;
        R.prototype.Ub = function() {
            z("Firebase.DataSnapshot.numChildren", 0, 0, arguments.length);
            return this.z.Ub();
        };
        R.prototype.numChildren = R.prototype.Ub;
        R.prototype.Nc = function() {
            z("Firebase.DataSnapshot.ref", 0, 0, arguments.length);
            return this.ec;
        };
        R.prototype.ref = R.prototype.Nc;
        function rc(a) {
            y("array" == fa(a) && 0 < a.length);
            this.vd = a;
            this.sb = {};
        }
        rc.prototype.Ac = function() {};
        rc.prototype.Xc = function(a) {
            for (var b = this.sb[a] || [], c = 0; c < b.length; c++) b[c].X.apply(b[c].T, Array.prototype.slice.call(arguments, 1));
        };
        rc.prototype.Xa = function(a, b, c) {
            sc(this, a);
            this.sb[a] = this.sb[a] || [];
            this.sb[a].push({
                X: b,
                T: c
            });
            (a = this.Ac(a)) && b.apply(c, a);
        };
        rc.prototype.ub = function(a, b, c) {
            sc(this, a);
            for (var a = this.sb[a] || [], d = 0; d < a.length; d++) if (a[d].X === b && (!c || c === a[d].T)) {
                a.splice(d, 1);
                break;
            }
        };
        function sc(a, b) {
            var c = a.vd, d;
            a: {
                d = function(a) {
                    return a === b;
                };
                for (var e = c.length, f = u(c) ? c.split("") : c, h = 0; h < e; h++) if (h in f && d.call(aa, f[h])) {
                    d = h;
                    break a;
                }
                d = -1;
            }
            y(0 > d ? k : u(c) ? c.charAt(d) : c[d], "Unknown event: " + b);
        }
        function tc() {
            rc.call(this, [ "visible" ]);
            var a, b;
            "undefined" !== typeof document && "undefined" !== typeof document.addEventListener && ("undefined" !== typeof document.hidden ? (b = "visibilitychange", 
            a = "hidden") : "undefined" !== typeof document.mozHidden ? (b = "mozvisibilitychange", 
            a = "mozHidden") : "undefined" !== typeof document.msHidden ? (b = "msvisibilitychange", 
            a = "msHidden") : "undefined" !== typeof document.webkitHidden && (b = "webkitvisibilitychange", 
            a = "webkitHidden"));
            this.gb = j;
            if (b) {
                var c = this;
                document.addEventListener(b, function() {
                    var b = !document[a];
                    if (b !== c.gb) {
                        c.gb = b;
                        c.Xc("visible", b);
                    }
                }, l);
            }
        }
        la(tc, rc);
        ea(tc);
        tc.prototype.Ac = function(a) {
            y("visible" === a);
            return [ this.gb ];
        };
        function uc(a) {
            this.Jc = a;
            this.ac = [];
            this.Qa = 0;
            this.tc = -1;
            this.Ka = k;
        }
        function cc(a, b) {
            for (var c in a) b.call(aa, a[c], c, a);
        }
        function vc(a) {
            var b = {}, c;
            for (c in a) b[c] = a[c];
            return b;
        }
        function wc() {
            this.jb = {};
        }
        function xc(a, b, c) {
            s(c) || (c = 1);
            C(a.jb, b) || (a.jb[b] = 0);
            a.jb[b] += c;
        }
        wc.prototype.get = function() {
            return vc(this.jb);
        };
        function yc(a) {
            this.xd = a;
            this.Qb = k;
        }
        yc.prototype.get = function() {
            var a = this.xd.get(), b = vc(a);
            if (this.Qb) for (var c in this.Qb) b[c] -= this.Qb[c];
            this.Qb = a;
            return b;
        };
        function zc(a, b) {
            this.Sc = {};
            this.kc = new yc(a);
            this.u = b;
            setTimeout(v(this.kd, this), 10 + 6e4 * Math.random());
        }
        zc.prototype.kd = function() {
            var a = this.kc.get(), b = {}, c = l, d;
            for (d in a) 0 < a[d] && C(this.Sc, d) && (b[d] = a[d], c = j);
            c && (a = this.u, a.P && (b = {
                c: b
            }, a.e("reportStats", b), a.Ga("s", b)));
            setTimeout(v(this.kd, this), 6e5 * Math.random());
        };
        var Ac = {}, Bc = {};
        function Cc(a) {
            a = a.toString();
            Ac[a] || (Ac[a] = new wc());
            return Ac[a];
        }
        function Dc() {
            this.set = {};
        }
        r = Dc.prototype;
        r.add = function(a, b) {
            this.set[a] = b !== k ? b : j;
        };
        r.contains = function(a) {
            return C(this.set, a);
        };
        r.get = function(a) {
            return this.contains(a) ? this.set[a] : aa;
        };
        r.remove = function(a) {
            delete this.set[a];
        };
        r.f = function() {
            var a;
            a: {
                for (a in this.set) {
                    a = l;
                    break a;
                }
                a = j;
            }
            return a;
        };
        r.count = function() {
            var a = 0, b;
            for (b in this.set) a++;
            return a;
        };
        function Ec(a, b) {
            for (var c in a.set) C(a.set, c) && b(c, a.set[c]);
        }
        r.keys = function() {
            var a = [], b;
            for (b in this.set) C(this.set, b) && a.push(b);
            return a;
        };
        var Fc = "pLPCommand", Gc = "pRTLPCB";
        function Hc(a, b, c) {
            this.uc = a;
            this.e = Ub(a);
            this.Xd = b;
            this.$ = Cc(b);
            this.jc = c;
            this.kb = l;
            this.Lb = function(a) {
                b.host !== b.fa && (a.ns = b.Sb);
                var c = [], f;
                for (f in a) a.hasOwnProperty(f) && c.push(f + "=" + a[f]);
                return (b.hc ? "https://" : "http://") + b.fa + "/.lp?" + c.join("&");
            };
        }
        var Ic, Jc;
        Hc.prototype.open = function(a, b) {
            function c() {
                if (!d.Ja) {
                    d.ka = new Kc(function(a, b, c, e, f) {
                        xc(d.$, "bytes_received", w(arguments).length);
                        if (d.ka) if (d.ba && (clearTimeout(d.ba), d.ba = k), d.kb = j, "start" == a) d.id = b, 
                        d.jd = c; else if ("close" === a) if (b) {
                            d.ka.ic = l;
                            var h = d.fd;
                            h.tc = b;
                            h.Ka = function() {
                                d.Fa();
                            };
                            h.tc < h.Qa && (h.Ka(), h.Ka = k);
                        } else d.Fa(); else g(Error("Unrecognized command received: " + a));
                    }, function(a, b) {
                        xc(d.$, "bytes_received", w(arguments).length);
                        var c = d.fd;
                        for (c.ac[a] = b; c.ac[c.Qa]; ) {
                            var e = c.ac[c.Qa];
                            delete c.ac[c.Qa];
                            for (var f = 0; f < e.length; ++f) if (e[f]) {
                                var h = c;
                                fc(function() {
                                    h.Jc(e[f]);
                                });
                            }
                            if (c.Qa === c.tc) {
                                c.Ka && (clearTimeout(c.Ka), c.Ka(), c.Ka = k);
                                break;
                            }
                            c.Qa++;
                        }
                    }, function() {
                        d.Fa();
                    }, d.Lb);
                    var a = {
                        start: "t"
                    };
                    a.ser = Math.floor(1e8 * Math.random());
                    d.ka.mc && (a.cb = d.ka.mc);
                    a.v = "5";
                    d.jc && (a.s = d.jc);
                    a = d.Lb(a);
                    d.e("Connecting via long-poll to " + a);
                    Lc(d.ka, a, function() {});
                }
            }
            this.Zc = 0;
            this.R = b;
            this.fd = new uc(a);
            this.Ja = l;
            var d = this;
            this.ba = setTimeout(function() {
                d.e("Timed out trying to connect.");
                d.Fa();
                d.ba = k;
            }, 3e4);
            if ("complete" === document.readyState) c(); else {
                var e = l, f = function() {
                    document.body ? e || (e = j, c()) : setTimeout(f, 10);
                };
                document.addEventListener ? (document.addEventListener("DOMContentLoaded", f, l), 
                window.addEventListener("load", f, l)) : document.attachEvent && (document.attachEvent("onreadystatechange", function() {
                    "complete" === document.readyState && f();
                }, l), window.attachEvent("onload", f, l));
            }
        };
        Hc.prototype.start = function() {
            var a = this.ka, b = this.jd;
            a.Gd = this.id;
            a.Hd = b;
            for (a.pc = j; Mc(a); ) ;
            a = this.id;
            b = this.jd;
            this.Wa = document.createElement("iframe");
            var c = {
                dframe: "t"
            };
            c.id = a;
            c.pw = b;
            a = this.Lb(c);
            this.Wa.src = a;
            this.Wa.style.display = "none";
            document.body.appendChild(this.Wa);
        };
        Hc.isAvailable = function() {
            return !Jc && !("object" === typeof window && window.chrome && window.chrome.extension && !/^chrome/.test(window.location.href)) && !("object" === typeof Windows && "object" === typeof Windows.Wd) && (Ic || j);
        };
        Hc.prototype.Ib = function() {
            this.Ja = j;
            this.ka && (this.ka.close(), this.ka = k);
            this.Wa && (document.body.removeChild(this.Wa), this.Wa = k);
            this.ba && (clearTimeout(this.ba), this.ba = k);
        };
        Hc.prototype.Fa = function() {
            this.Ja || (this.e("Longpoll is closing itself"), this.Ib(), this.R && (this.R(this.kb), 
            this.R = k));
        };
        Hc.prototype.close = function() {
            this.Ja || (this.e("Longpoll is being closed."), this.Ib());
        };
        Hc.prototype.send = function(a) {
            a = w(a);
            xc(this.$, "bytes_sent", a.length);
            for (var a = ta(a), a = Mb(a, j), a = ac(a, 1840), b = 0; b < a.length; b++) {
                var c = this.ka;
                c.Cb.push({
                    Qd: this.Zc,
                    Vd: a.length,
                    ad: a[b]
                });
                c.pc && Mc(c);
                this.Zc++;
            }
        };
        function Kc(a, b, c, d) {
            this.Lb = d;
            this.ha = c;
            this.Lc = new Dc();
            this.Cb = [];
            this.vc = Math.floor(1e8 * Math.random());
            this.ic = j;
            this.mc = Nb();
            window[Fc + this.mc] = a;
            window[Gc + this.mc] = b;
            a = document.createElement("iframe");
            a.style.display = "none";
            if (document.body) {
                document.body.appendChild(a);
                try {
                    a.contentWindow.document || L("No IE domain setting required");
                } catch (e) {
                    a.src = "javascript:void((function(){document.open();document.domain='" + document.domain + "';document.close();})())";
                }
            } else g("Document body has not initialized. Wait to initialize Firebase until after the document is ready.");
            a.contentDocument ? a.Aa = a.contentDocument : a.contentWindow ? a.Aa = a.contentWindow.document : a.document && (a.Aa = a.document);
            this.Y = a;
            a = "";
            this.Y.src && "javascript:" === this.Y.src.substr(0, 11) && (a = '<script>document.domain="' + document.domain + '";</script>');
            a = "<html><body>" + a + "</body></html>";
            try {
                this.Y.Aa.open(), this.Y.Aa.write(a), this.Y.Aa.close();
            } catch (f) {
                L("frame writing exception"), f.stack && L(f.stack), L(f);
            }
        }
        Kc.prototype.close = function() {
            this.pc = l;
            if (this.Y) {
                this.Y.Aa.body.innerHTML = "";
                var a = this;
                setTimeout(function() {
                    a.Y !== k && (document.body.removeChild(a.Y), a.Y = k);
                }, 0);
            }
            var b = this.ha;
            b && (this.ha = k, b());
        };
        function Mc(a) {
            if (a.pc && a.ic && a.Lc.count() < (0 < a.Cb.length ? 2 : 1)) {
                a.vc++;
                var b = {};
                b.id = a.Gd;
                b.pw = a.Hd;
                b.ser = a.vc;
                for (var b = a.Lb(b), c = "", d = 0; 0 < a.Cb.length; ) if (1870 >= a.Cb[0].ad.length + 30 + c.length) {
                    var e = a.Cb.shift(), c = c + "&seg" + d + "=" + e.Qd + "&ts" + d + "=" + e.Vd + "&d" + d + "=" + e.ad;
                    d++;
                } else break;
                var b = b + c, f = a.vc;
                a.Lc.add(f);
                var h = function() {
                    a.Lc.remove(f);
                    Mc(a);
                }, i = setTimeout(h, 25e3);
                Lc(a, b, function() {
                    clearTimeout(i);
                    h();
                });
                return j;
            }
            return l;
        }
        function Lc(a, b, c) {
            setTimeout(function() {
                try {
                    if (a.ic) {
                        var d = a.Y.Aa.createElement("script");
                        d.type = "text/javascript";
                        d.async = j;
                        d.src = b;
                        d.onload = d.onreadystatechange = function() {
                            var a = d.readyState;
                            if (!a || "loaded" === a || "complete" === a) d.onload = d.onreadystatechange = k, 
                            d.parentNode && d.parentNode.removeChild(d), c();
                        };
                        d.onerror = function() {
                            L("Long-poll script failed to load: " + b);
                            a.ic = l;
                            a.close();
                        };
                        a.Y.Aa.body.appendChild(d);
                    }
                } catch (e) {}
            }, 1);
        }
        var Nc = k;
        "undefined" !== typeof MozWebSocket ? Nc = MozWebSocket : "undefined" !== typeof WebSocket && (Nc = WebSocket);
        function S(a, b, c) {
            this.uc = a;
            this.e = Ub(this.uc);
            this.frames = this.qb = k;
            this.Uc = 0;
            this.$ = Cc(b);
            this.Pa = (b.hc ? "wss://" : "ws://") + b.fa + "/.ws?v=5";
            b.host !== b.fa && (this.Pa = this.Pa + "&ns=" + b.Sb);
            c && (this.Pa = this.Pa + "&s=" + c);
        }
        var Oc;
        S.prototype.open = function(a, b) {
            this.ha = b;
            this.Id = a;
            this.e("Websocket connecting to " + this.Pa);
            this.W = new Nc(this.Pa);
            this.kb = l;
            nb.set("previous_websocket_failure", j);
            var c = this;
            this.ba = setTimeout(function() {
                c.e("Websocket timed out trying to connect.");
                Pc(c);
                c.Fa();
            }, 3e4);
            this.W.onopen = function() {
                c.e("Websocket connected.");
                c.kb = j;
                Pc(c);
                nb.remove("previous_websocket_failure");
            };
            this.W.onclose = function() {
                c.e("Websocket connection was disconnected.");
                c.W = k;
                c.Fa();
            };
            this.W.onmessage = function(a) {
                if (c.W !== k) if (a = a.data, xc(c.$, "bytes_received", a.length), Qc(c), c.frames !== k) Rc(c, a); else {
                    a: {
                        y(c.frames === k, "We already have a frame buffer");
                        if (6 >= a.length) {
                            var b = Number(a);
                            if (!isNaN(b)) {
                                c.Uc = b;
                                c.frames = [];
                                a = k;
                                break a;
                            }
                        }
                        c.Uc = 1;
                        c.frames = [];
                    }
                    a !== k && Rc(c, a);
                }
            };
            this.W.onerror = function(a) {
                c.e("WebSocket error.  Closing connection.");
                a.data && c.e(a.data);
                c.Fa();
            };
        };
        S.prototype.start = function() {};
        S.isAvailable = function() {
            var a = l;
            if ("undefined" !== typeof navigator && navigator.userAgent) {
                var b = navigator.userAgent.match(/Android ([0-9]{0,}\.[0-9]{0,})/);
                b && 1 < b.length && 4.4 > parseFloat(b[1]) && (a = j);
            }
            return !a && Nc !== k && !Oc;
        };
        function Rc(a, b) {
            a.frames.push(b);
            if (a.frames.length == a.Uc) {
                var c = a.frames.join("");
                a.frames = k;
                c = sa(c);
                a.Id(c);
            }
        }
        S.prototype.send = function(a) {
            Qc(this);
            a = w(a);
            xc(this.$, "bytes_sent", a.length);
            a = ac(a, 16384);
            1 < a.length && this.W.send(String(a.length));
            for (var b = 0; b < a.length; b++) this.W.send(a[b]);
        };
        S.prototype.Ib = function() {
            this.Ja = j;
            Pc(this);
            this.qb && (clearInterval(this.qb), this.qb = k);
            this.W && (this.W.close(), this.W = k);
        };
        S.prototype.Fa = function() {
            this.Ja || (this.e("WebSocket is closing itself"), this.Ib(), this.ha && (this.ha(this.kb), 
            this.ha = k));
        };
        S.prototype.close = function() {
            this.Ja || (this.e("WebSocket is being closed"), this.Ib());
        };
        function Qc(a) {
            clearInterval(a.qb);
            a.qb = setInterval(function() {
                a.W && a.W.send("0");
                Qc(a);
            }, 45e3);
        }
        function Pc(a) {
            a.ba && (clearTimeout(a.ba), a.ba = k);
        }
        function Sc() {
            var a = [];
            S && S.isAvailable() && !nb.get("previous_websocket_failure") ? a.push(S) : bc(Tc, function(b, c) {
                c && c.isAvailable() && a.push(c);
            });
            this.lc = a;
        }
        var Tc = [ Hc, {
            isAvailable: o(l)
        }, S ];
        function Uc(a, b, c, d, e, f) {
            this.id = a;
            this.e = Ub("c:" + this.id + ":");
            this.Jc = c;
            this.xb = d;
            this.R = e;
            this.Ic = f;
            this.K = b;
            this.$b = [];
            this.Yc = 0;
            this.Wc = new Sc();
            this.wa = 0;
            this.e("Connection created");
            Vc(this);
        }
        function Vc(a) {
            var b;
            var c = a.Wc;
            0 < c.lc.length ? b = c.lc[0] : g(Error("No transports available"));
            a.L = new b("c:" + a.id + ":" + a.Yc++, a.K);
            var d = Wc(a, a.L), e = Xc(a, a.L);
            a.Jb = a.L;
            a.Hb = a.L;
            a.A = k;
            setTimeout(function() {
                a.L && a.L.open(d, e);
            }, 0);
        }
        function Xc(a, b) {
            return function(c) {
                b === a.L ? (a.L = k, !c && 0 === a.wa ? (a.e("Realtime connection failed."), "s-" === a.K.fa.substr(0, 2) && (nb.remove("host:" + a.K.host), 
                a.K.fa = a.K.host)) : 1 === a.wa && a.e("Realtime connection lost."), a.close()) : b === a.A ? (c = a.A, 
                a.A = k, (a.Jb === c || a.Hb === c) && a.close()) : a.e("closing an old connection");
            };
        }
        function Wc(a, b) {
            return function(c) {
                if (2 != a.wa) if (b === a.Hb) {
                    var d = $b("t", c), c = $b("d", c);
                    if ("c" == d) {
                        if (d = $b("t", c), "d" in c) if (c = c.d, "h" === d) {
                            var d = c.ts, e = c.v, f = c.h;
                            a.jc = c.s;
                            qb(a.K, f);
                            if (0 == a.wa && (a.L.start(), c = a.L, a.e("Realtime connection established."), 
                            a.L = c, a.wa = 1, a.xb && (a.xb(d), a.xb = k), "5" !== e && M("Protocol version mismatch detected"), 
                            c = 1 < a.Wc.lc.length ? a.Wc.lc[1] : k)) a.A = new c("c:" + a.id + ":" + a.Yc++, a.K, a.jc), 
                            a.A.open(Wc(a, a.A), Xc(a, a.A));
                        } else if ("n" === d) {
                            a.e("recvd end transmission on primary");
                            a.Hb = a.A;
                            for (c = 0; c < a.$b.length; ++c) a.Xb(a.$b[c]);
                            a.$b = [];
                            Yc(a);
                        } else "s" === d ? (a.e("Connection shutdown command received. Shutting down..."), 
                        a.Ic && (a.Ic(c), a.Ic = k), a.R = k, a.close()) : "r" === d ? (a.e("Reset packet received.  New host: " + c), 
                        qb(a.K, c), 1 === a.wa ? a.close() : ($c(a), Vc(a))) : "e" === d ? Vb("Server Error: " + c) : Vb("Unknown control packet command: " + d);
                    } else "d" == d && a.Xb(c);
                } else b === a.A ? (d = $b("t", c), c = $b("d", c), "c" == d ? "t" in c && (c = c.t, 
                "a" === c ? (a.A.start(), a.e("sending client ack on secondary"), a.A.send({
                    t: "c",
                    d: {
                        t: "a",
                        d: {}
                    }
                }), a.e("Ending transmission on primary"), a.L.send({
                    t: "c",
                    d: {
                        t: "n",
                        d: {}
                    }
                }), a.Jb = a.A, Yc(a)) : "r" === c && (a.e("Got a reset on secondary, closing it"), 
                a.A.close(), (a.Jb === a.A || a.Hb === a.A) && a.close())) : "d" == d ? a.$b.push(c) : g(Error("Unknown protocol layer: " + d))) : a.e("message on old connection");
            };
        }
        Uc.prototype.od = function(a) {
            a = {
                t: "d",
                d: a
            };
            1 !== this.wa && g("Connection is not connected");
            this.Jb.send(a);
        };
        function Yc(a) {
            a.Jb === a.A && a.Hb === a.A && (a.e("cleaning up and promoting a connection: " + a.A.uc), 
            a.L = a.A, a.A = k);
        }
        Uc.prototype.Xb = function(a) {
            this.Jc(a);
        };
        Uc.prototype.close = function() {
            2 !== this.wa && (this.e("Closing realtime connection."), this.wa = 2, $c(this), 
            this.R && (this.R(), this.R = k));
        };
        function $c(a) {
            a.e("Shutting down all connections");
            a.L && (a.L.close(), a.L = k);
            a.A && (a.A.close(), a.A = k);
        }
        function ad() {
            rc.call(this, [ "online" ]);
            this.yb = j;
            if ("undefined" !== typeof window && "undefined" !== typeof window.addEventListener) {
                var a = this;
                window.addEventListener("online", function() {
                    a.yb || a.Xc("online", j);
                    a.yb = j;
                }, l);
                window.addEventListener("offline", function() {
                    a.yb && a.Xc("online", l);
                    a.yb = l;
                }, l);
            }
        }
        la(ad, rc);
        ea(ad);
        ad.prototype.Ac = function(a) {
            y("online" === a);
            return [ this.yb ];
        };
        function bd(a, b, c, d, e, f) {
            this.id = cd++;
            this.e = Ub("p:" + this.id + ":");
            this.Na = j;
            this.ga = {};
            this.U = [];
            this.zb = 0;
            this.wb = [];
            this.P = l;
            this.qa = 1e3;
            this.Rb = 3e5;
            this.Yb = b || da;
            this.Wb = c || da;
            this.vb = d || da;
            this.Kc = e || da;
            this.Bc = f || da;
            this.K = a;
            this.Oc = k;
            this.Gb = {};
            this.Pd = 0;
            this.rb = this.Fc = k;
            dd(this, 0);
            tc.mb().Xa("visible", this.Kd, this);
            -1 === a.host.indexOf("fblocal") && ad.mb().Xa("online", this.Jd, this);
        }
        var cd = 0, ed = 0;
        r = bd.prototype;
        r.Ga = function(a, b, c) {
            var d = ++this.Pd, a = {
                r: d,
                a: a,
                b: b
            };
            this.e(w(a));
            y(this.P, "sendRequest_ call when we're not connected not allowed.");
            this.ja.od(a);
            c && (this.Gb[d] = c);
        };
        function fd(a, b, c, d, e) {
            a.e("Listen on " + b + " for " + c);
            var f = {
                p: b
            }, d = wb(d, function(a) {
                return Ka(a);
            });
            "{}" !== c && (f.q = d);
            f.h = a.Bc(b);
            a.Ga("l", f, function(d) {
                a.e("listen response", d);
                d = d.s;
                "ok" !== d && gd(a, b, c);
                e && e(d);
            });
        }
        r.hb = function(a, b, c) {
            this.Ha = {
                yd: a,
                bd: l,
                X: b,
                Nb: c
            };
            this.e("Authenticating using credential: " + this.Ha);
            hd(this);
            if (!(b = 40 == a.length)) a: {
                var d;
                try {
                    var e = a.split(".");
                    if (3 !== e.length) {
                        b = l;
                        break a;
                    }
                    var f;
                    b: {
                        try {
                            if ("undefined" !== typeof atob) {
                                f = atob(e[1]);
                                break b;
                            }
                        } catch (h) {
                            L("base64DecodeIfNativeSupport failed: ", h);
                        }
                        f = k;
                    }
                    f !== k && (d = sa(f));
                } catch (i) {
                    L("isAdminAuthToken_ failed", i);
                }
                b = "object" === typeof d && wa(d, "admin") === j;
            }
            b && (this.e("Admin auth credential detected.  Reducing max reconnect time."), this.Rb = 3e4);
        };
        r.Kb = function(a) {
            delete this.Ha;
            this.vb(l);
            this.P && this.Ga("unauth", {}, function(b) {
                a(b.s);
            });
        };
        function hd(a) {
            var b = a.Ha;
            a.P && b && a.Ga("auth", {
                cred: b.yd
            }, function(c) {
                var d = c.s, c = c.d || "error";
                "ok" !== d && a.Ha === b && delete a.Ha;
                a.vb("ok" === d);
                b.bd ? "ok" !== d && b.Nb && b.Nb(d, c) : (b.bd = j, b.X && b.X(d, c));
            });
        }
        function id(a, b, c, d) {
            b = b.toString();
            gd(a, b, c) && a.P && (a.e("Unlisten on " + b + " for " + c), b = {
                p: b
            }, d = wb(d, function(a) {
                return Ka(a);
            }), "{}" !== c && (b.q = d), a.Ga("u", b));
        }
        function jd(a, b, c, d) {
            a.P ? kd(a, "o", b, c, d) : a.wb.push({
                Mc: b,
                action: "o",
                data: c,
                C: d
            });
        }
        r.Hc = function(a, b) {
            this.P ? kd(this, "oc", a, k, b) : this.wb.push({
                Mc: a,
                action: "oc",
                data: k,
                C: b
            });
        };
        function kd(a, b, c, d, e) {
            c = {
                p: c,
                d: d
            };
            a.e("onDisconnect " + b, c);
            a.Ga(b, c, function(a) {
                e && setTimeout(function() {
                    e(a.s);
                }, 0);
            });
        }
        r.put = function(a, b, c, d) {
            ld(this, "p", a, b, c, d);
        };
        function ld(a, b, c, d, e, f) {
            c = {
                p: c,
                d: d
            };
            s(f) && (c.h = f);
            a.U.push({
                action: b,
                ld: c,
                C: e
            });
            a.zb++;
            b = a.U.length - 1;
            a.P && md(a, b);
        }
        function md(a, b) {
            var c = a.U[b].action, d = a.U[b].ld, e = a.U[b].C;
            a.U[b].Md = a.P;
            a.Ga(c, d, function(d) {
                a.e(c + " response", d);
                delete a.U[b];
                a.zb--;
                0 === a.zb && (a.U = []);
                e && e(d.s);
            });
        }
        r.Xb = function(a) {
            if ("r" in a) {
                this.e("from server: " + w(a));
                var b = a.r, c = this.Gb[b];
                c && (delete this.Gb[b], c(a.b));
            } else "error" in a && g("A server-side error has occurred: " + a.error), "a" in a && (b = a.a, 
            a = a.b, this.e("handleServerMessage", b, a), "d" === b ? this.Yb(a.p, a.d) : "m" === b ? this.Yb(a.p, a.d, j) : "c" === b ? (b = a.p, 
            a = (a = a.q) ? wb(a, function(a) {
                return La(a);
            }).join("$") : "{}", (a = gd(this, b, a)) && a.C && a.C("permission_denied")) : "ac" === b ? (b = a.s, 
            a = a.d, c = this.Ha, delete this.Ha, c && c.Nb && c.Nb(b, a), this.vb(l)) : "sd" === b ? this.Oc ? this.Oc(a) : "msg" in a && "undefined" !== typeof console && console.log("FIREBASE: " + a.msg.replace("\n", "\nFIREBASE: ")) : Vb("Unrecognized action received from server: " + w(b) + "\nAre you using the latest client?"));
        };
        r.xb = function(a) {
            this.e("connection ready");
            this.P = j;
            this.rb = new Date().getTime();
            this.Kc({
                serverTimeOffset: a - new Date().getTime()
            });
            hd(this);
            for (var b in this.ga) for (var c in this.ga[b]) a = this.ga[b][c], fd(this, b, c, a.Za, a.C);
            for (b = 0; b < this.U.length; b++) this.U[b] && md(this, b);
            for (;this.wb.length; ) b = this.wb.shift(), kd(this, b.action, b.Mc, b.data, b.C);
            this.Wb(j);
        };
        function dd(a, b) {
            y(!a.ja, "Scheduling a connect when we're already connected/ing?");
            a.Sa && clearTimeout(a.Sa);
            a.Sa = setTimeout(function() {
                a.Sa = k;
                if (a.Na) {
                    a.e("Making a connection attempt");
                    a.Fc = new Date().getTime();
                    a.rb = k;
                    var b = v(a.Xb, a), d = v(a.xb, a), e = v(a.gd, a), f = a.id + ":" + ed++;
                    a.ja = new Uc(f, a.K, b, d, e, function(b) {
                        M(b + " (" + a.K.toString() + ")");
                        a.Na = l;
                    });
                }
            }, b);
        }
        r.Kd = function(a) {
            a && (!this.gb && this.qa === this.Rb) && (this.e("Window became visible.  Reducing delay."), 
            this.qa = 1e3, this.ja || dd(this, 0));
            this.gb = a;
        };
        r.Jd = function(a) {
            a ? (this.e("Browser went online.  Reconnecting."), this.qa = 1e3, this.Na = j, 
            this.ja || dd(this, 0)) : (this.e("Browser went offline.  Killing connection; don't reconnect."), 
            this.Na = l, this.ja && this.ja.close());
        };
        r.gd = function() {
            this.e("data client disconnected");
            this.P = l;
            this.ja = k;
            for (var a = 0; a < this.U.length; a++) {
                var b = this.U[a];
                b && ("h" in b.ld && b.Md) && (b.C && b.C("disconnect"), delete this.U[a], this.zb--);
            }
            0 === this.zb && (this.U = []);
            if (this.Na) this.gb ? this.rb && (3e4 < new Date().getTime() - this.rb && (this.qa = 1e3), 
            this.rb = k) : (this.e("Window isn't visible.  Delaying reconnect."), this.qa = this.Rb, 
            this.Fc = new Date().getTime()), a = Math.max(0, this.qa - (new Date().getTime() - this.Fc)), 
            a *= Math.random(), this.e("Trying to reconnect in " + a + "ms"), dd(this, a), this.qa = Math.min(this.Rb, 1.3 * this.qa); else for (var c in this.Gb) delete this.Gb[c];
            this.Wb(l);
        };
        r.Ia = function() {
            this.Na = l;
            this.ja ? this.ja.close() : (this.Sa && (clearTimeout(this.Sa), this.Sa = k), this.P && this.gd());
        };
        r.ab = function() {
            this.Na = j;
            this.qa = 1e3;
            this.P || dd(this, 0);
        };
        function gd(a, b, c) {
            b = new J(b).toString();
            c || (c = "{}");
            var d = a.ga[b][c];
            delete a.ga[b][c];
            return d;
        }
        function nd() {
            this.o = this.D = k;
        }
        function od(a, b, c) {
            if (b.f()) a.D = c, a.o = k; else if (a.D !== k) a.D = a.D.ya(b, c); else {
                a.o == k && (a.o = new Dc());
                var d = E(b);
                a.o.contains(d) || a.o.add(d, new nd());
                a = a.o.get(d);
                b = Ma(b);
                od(a, b, c);
            }
        }
        function pd(a, b) {
            if (b.f()) return a.D = k, a.o = k, j;
            if (a.D !== k) {
                if (a.D.N()) return l;
                var c = a.D;
                a.D = k;
                c.w(function(b, c) {
                    od(a, new J(b), c);
                });
                return pd(a, b);
            }
            return a.o !== k ? (c = E(b), b = Ma(b), a.o.contains(c) && pd(a.o.get(c), b) && a.o.remove(c), 
            a.o.f() ? (a.o = k, j) : l) : j;
        }
        function qd(a, b, c) {
            a.D !== k ? c(b, a.D) : a.w(function(a, e) {
                var f = new J(b.toString() + "/" + a);
                qd(e, f, c);
            });
        }
        nd.prototype.w = function(a) {
            this.o !== k && Ec(this.o, function(b, c) {
                a(b, c);
            });
        };
        function rd() {
            this.ra = N;
        }
        function T(a, b) {
            return a.ra.Q(b);
        }
        function U(a, b, c) {
            a.ra = a.ra.ya(b, c);
        }
        rd.prototype.toString = function() {
            return this.ra.toString();
        };
        function sd() {
            this.sa = new rd();
            this.I = new rd();
            this.ma = new rd();
            this.Bb = new Pa();
        }
        function td(a, b) {
            for (var c = T(a.sa, b), d = T(a.I, b), e = K(a.Bb, b), f = l, h = e; h !== k; ) {
                if (h.k() !== k) {
                    f = j;
                    break;
                }
                h = h.parent();
            }
            if (f) return l;
            c = ud(c, d, e);
            return c !== d ? (U(a.I, b, c), j) : l;
        }
        function ud(a, b, c) {
            if (c.f()) return a;
            if (c.k() !== k) return b;
            a = a || N;
            c.w(function(d) {
                var d = d.name(), e = a.M(d), f = b.M(d), h = K(c, d), e = ud(e, f, h);
                a = a.H(d, e);
            });
            return a;
        }
        sd.prototype.set = function(a, b) {
            var c = this, d = [];
            vb(b, function(a) {
                var b = a.path, a = a.pa, h = Nb();
                Qa(K(c.Bb, b), h);
                U(c.I, b, a);
                d.push({
                    path: b,
                    Rd: h
                });
            });
            return d;
        };
        function vd(a, b) {
            vb(b, function(b) {
                var d = b.Rd, b = K(a.Bb, b.path), e = b.k();
                y(e !== k, "pendingPut should not be null.");
                e === d && Qa(b, k);
            });
        }
        function wd() {
            this.Ta = [];
        }
        function xd(a, b) {
            if (0 !== b.length) for (var c = 0; c < b.length; c++) a.Ta.push(b[c]);
        }
        wd.prototype.Eb = function() {
            for (var a = 0; a < this.Ta.length; a++) if (this.Ta[a]) {
                var b = this.Ta[a];
                this.Ta[a] = k;
                yd(b);
            }
            this.Ta = [];
        };
        function yd(a) {
            var b = a.X, c = a.pd, d = a.Db;
            fc(function() {
                b(c, d);
            });
        }
        function V(a, b, c, d) {
            this.type = a;
            this.ta = b;
            this.aa = c;
            this.Db = d;
        }
        function zd(a) {
            this.J = a;
            this.na = [];
            this.xc = new wd();
        }
        function Ad(a, b, c, d, e) {
            a.na.push({
                type: b,
                X: c,
                cancel: d,
                T: e
            });
            var d = [], f = Bd(a.i);
            a.pb && f.push(new V("value", a.i));
            for (var h = 0; h < f.length; h++) if (f[h].type === b) {
                var i = new H(a.J.n, a.J.path);
                f[h].aa && (i = i.F(f[h].aa));
                d.push({
                    X: e ? v(c, e) : c,
                    pd: new R(f[h].ta, i),
                    Db: f[h].Db
                });
            }
            xd(a.xc, d);
        }
        zd.prototype.cc = function(a, b) {
            b = this.dc(a, b);
            b != k && Cd(this, b);
        };
        function Cd(a, b) {
            for (var c = [], d = 0; d < b.length; d++) {
                var e = b[d], f = e.type, h = new H(a.J.n, a.J.path);
                b[d].aa && (h = h.F(b[d].aa));
                h = new R(b[d].ta, h);
                "value" === e.type && !h.nb() ? f += "(" + h.V() + ")" : "value" !== e.type && (f += " " + h.name());
                L(a.J.n.u.id + ": event:" + a.J.path + ":" + a.J.La() + ":" + f);
                for (f = 0; f < a.na.length; f++) {
                    var i = a.na[f];
                    b[d].type === i.type && c.push({
                        X: i.T ? v(i.X, i.T) : i.X,
                        pd: h,
                        Db: e.Db
                    });
                }
            }
            xd(a.xc, c);
        }
        zd.prototype.Eb = function() {
            this.xc.Eb();
        };
        function Bd(a) {
            var b = [];
            if (!a.N()) {
                var c = k;
                a.w(function(a, e) {
                    b.push(new V("child_added", e, a, c));
                    c = a;
                });
            }
            return b;
        }
        function Ed(a) {
            a.pb || (a.pb = j, Cd(a, [ new V("value", a.i) ]));
        }
        function Fd(a, b) {
            zd.call(this, a);
            this.i = b;
        }
        la(Fd, zd);
        Fd.prototype.dc = function(a, b) {
            this.i = a;
            this.pb && b != k && b.push(new V("value", this.i));
            return b;
        };
        Fd.prototype.lb = function() {
            return {};
        };
        function Gd(a, b) {
            this.Ob = a;
            this.Gc = b;
        }
        function Hd(a, b, c, d, e) {
            var f = a.Q(c), h = b.Q(c), d = new Gd(d, e), e = Id(d, c, f, h), h = !f.f() && !h.f() && f.j() !== h.j();
            if (e || h) {
                f = c;
                for (c = e; f.parent() !== k; ) {
                    var i = a.Q(f), e = b.Q(f), m = f.parent();
                    if (!d.Ob || K(d.Ob, m).k()) {
                        var n = b.Q(m), p = [], f = f.Z < f.m.length ? f.m[f.m.length - 1] : k;
                        i.f() ? (i = n.ea(f, e), p.push(new V("child_added", e, f, i))) : e.f() ? p.push(new V("child_removed", i, f)) : (i = n.ea(f, e), 
                        h && p.push(new V("child_moved", e, f, i)), c && p.push(new V("child_changed", e, f, i)));
                        d.Gc(m, n, p);
                    }
                    h && (h = l, c = j);
                    f = m;
                }
            }
        }
        function Id(a, b, c, d) {
            var e, f = [];
            c === d ? e = l : c.N() && d.N() ? e = c.k() !== d.k() : c.N() ? (Jd(a, b, N, d, f), 
            e = j) : d.N() ? (Jd(a, b, c, N, f), e = j) : e = Jd(a, b, c, d, f);
            e ? a.Gc(b, d, f) : c.j() !== d.j() && a.Gc(b, d, k);
            return e;
        }
        function Jd(a, b, c, d, e) {
            var f = l, h = !a.Ob || !K(a.Ob, b).f(), i = [], m = [], n = [], p = [], q = {}, t = {}, x, P, I, G;
            x = c.Ua();
            I = Za(x);
            P = d.Ua();
            for (G = Za(P); I !== k || G !== k; ) {
                c = I === k ? 1 : G === k ? -1 : I.key === G.key ? 0 : ic({
                    name: I.key,
                    ia: I.value.j()
                }, {
                    name: G.key,
                    ia: G.value.j()
                });
                if (0 > c) f = wa(q, I.key), s(f) ? (n.push({
                    zc: I,
                    Tc: i[f]
                }), i[f] = k) : (t[I.key] = m.length, m.push(I)), f = j, I = Za(x); else {
                    if (0 < c) f = wa(t, G.key), s(f) ? (n.push({
                        zc: m[f],
                        Tc: G
                    }), m[f] = k) : (q[G.key] = i.length, i.push(G)), f = j; else {
                        c = b.F(G.key);
                        if (c = Id(a, c, I.value, G.value)) p.push(G), f = j;
                        I.value.j() !== G.value.j() && (n.push({
                            zc: I,
                            Tc: G
                        }), f = j);
                        I = Za(x);
                    }
                    G = Za(P);
                }
                if (!h && f) return j;
            }
            for (h = 0; h < m.length; h++) if (q = m[h]) c = b.F(q.key), Id(a, c, q.value, N), 
            e.push(new V("child_removed", q.value, q.key));
            for (h = 0; h < i.length; h++) if (q = i[h]) c = b.F(q.key), m = d.ea(q.key, q.value), 
            Id(a, c, N, q.value), e.push(new V("child_added", q.value, q.key, m));
            for (h = 0; h < n.length; h++) q = n[h].zc, i = n[h].Tc, c = b.F(i.key), m = d.ea(i.key, i.value), 
            e.push(new V("child_moved", i.value, i.key, m)), (c = Id(a, c, q.value, i.value)) && p.push(i);
            for (h = 0; h < p.length; h++) a = p[h], m = d.ea(a.key, a.value), e.push(new V("child_changed", a.value, a.key, m));
            return f;
        }
        function Kd() {
            this.S = this.xa = k;
            this.set = {};
        }
        la(Kd, Dc);
        r = Kd.prototype;
        r.setActive = function(a) {
            this.xa = a;
        };
        function Ld(a) {
            return a.contains("default");
        }
        function Md(a) {
            return a.xa != k && Ld(a);
        }
        r.defaultView = function() {
            return Ld(this) ? this.get("default") : k;
        };
        r.path = ba("S");
        r.toString = function() {
            return wb(this.keys(), function(a) {
                return "default" === a ? "{}" : a;
            }).join("$");
        };
        r.Za = function() {
            var a = [];
            Ec(this, function(b, c) {
                a.push(c.J);
            });
            return a;
        };
        function Nd(a, b) {
            zd.call(this, a);
            this.i = N;
            this.dc(b, Bd(b));
        }
        la(Nd, zd);
        Nd.prototype.dc = function(a, b) {
            if (b === k) return b;
            var c = [], d = this.J;
            s(d.da) && (s(d.va) && d.va != k ? c.push(function(a, b) {
                var c = Xb(b, d.da);
                return 0 < c || 0 === c && 0 <= Yb(a, d.va);
            }) : c.push(function(a, b) {
                return 0 <= Xb(b, d.da);
            }));
            s(d.Ba) && (s(d.Ra) ? c.push(function(a, b) {
                var c = Xb(b, d.Ba);
                return 0 > c || 0 === c && 0 >= Yb(a, d.Ra);
            }) : c.push(function(a, b) {
                return 0 >= Xb(b, d.Ba);
            }));
            var e = k, f = k;
            if (s(this.J.Da)) if (s(this.J.da)) {
                if (e = Od(a, c, this.J.Da, l)) {
                    var h = a.M(e).j();
                    c.push(function(a, b) {
                        var c = Xb(b, h);
                        return 0 > c || 0 === c && 0 >= Yb(a, e);
                    });
                }
            } else if (f = Od(a, c, this.J.Da, j)) {
                var i = a.M(f).j();
                c.push(function(a, b) {
                    var c = Xb(b, i);
                    return 0 < c || 0 === c && 0 <= Yb(a, f);
                });
            }
            for (var m = [], n = [], p = [], q = [], t = 0; t < b.length; t++) {
                var x = b[t].aa, P = b[t].ta;
                switch (b[t].type) {
                  case "child_added":
                    Pd(c, x, P) && (this.i = this.i.H(x, P), n.push(b[t]));
                    break;

                  case "child_removed":
                    this.i.M(x).f() || (this.i = this.i.H(x, k), m.push(b[t]));
                    break;

                  case "child_changed":
                    !this.i.M(x).f() && Pd(c, x, P) && (this.i = this.i.H(x, P), q.push(b[t]));
                    break;

                  case "child_moved":
                    var I = !this.i.M(x).f(), G = Pd(c, x, P);
                    I ? G ? (this.i = this.i.H(x, P), p.push(b[t])) : (m.push(new V("child_removed", this.i.M(x), x)), 
                    this.i = this.i.H(x, k)) : G && (this.i = this.i.H(x, P), n.push(b[t]));
                }
            }
            var Zc = e || f;
            if (Zc) {
                var Dd = (t = f !== k) ? this.i.cd() : this.i.dd(), pc = l, bb = l, cb = this;
                (t ? a.yc : a.w).call(a, function(a, b) {
                    !bb && Dd === k && (bb = j);
                    if (bb && pc) return j;
                    pc ? (m.push(new V("child_removed", cb.i.M(a), a)), cb.i = cb.i.H(a, k)) : bb && (n.push(new V("child_added", b, a)), 
                    cb.i = cb.i.H(a, b));
                    Dd === a && (bb = j);
                    a === Zc && (pc = j);
                });
            }
            for (t = 0; t < n.length; t++) c = n[t], x = this.i.ea(c.aa, c.ta), m.push(new V("child_added", c.ta, c.aa, x));
            for (t = 0; t < p.length; t++) c = p[t], x = this.i.ea(c.aa, c.ta), m.push(new V("child_moved", c.ta, c.aa, x));
            for (t = 0; t < q.length; t++) c = q[t], x = this.i.ea(c.aa, c.ta), m.push(new V("child_changed", c.ta, c.aa, x));
            this.pb && 0 < m.length && m.push(new V("value", this.i));
            return m;
        };
        function Od(a, b, c, d) {
            if (a.N()) return k;
            var e = k;
            (d ? a.yc : a.w).call(a, function(a, d) {
                if (Pd(b, a, d) && (e = a, c--, 0 === c)) return j;
            });
            return e;
        }
        function Pd(a, b, c) {
            for (var d = 0; d < a.length; d++) if (!a[d](b, c.j())) return l;
            return j;
        }
        Nd.prototype.Cc = function(a) {
            return this.i.M(a) !== N;
        };
        Nd.prototype.lb = function(a, b, c) {
            var d = {};
            this.i.N() || this.i.w(function(a) {
                d[a] = 3;
            });
            var e = this.i, c = T(c, new J("")), f = new Pa();
            Qa(K(f, this.J.path), j);
            var b = N.ya(a, b), h = this;
            Hd(c, b, a, f, function(a, b, c) {
                c !== k && a.toString() === h.J.path.toString() && h.dc(b, c);
            });
            this.i.N() ? cc(d, function(a, b) {
                d[b] = 2;
            }) : (this.i.w(function(a) {
                C(d, a) || (d[a] = 1);
            }), cc(d, function(a, b) {
                h.i.M(b).f() && (d[b] = 2);
            }));
            this.i = e;
            return d;
        };
        function Qd(a, b) {
            this.u = a;
            this.g = b;
            this.Vb = b.ra;
            this.la = new Pa();
        }
        Qd.prototype.Mb = function(a, b, c, d, e) {
            var f = a.path, h = K(this.la, f), i = h.k();
            i === k ? (i = new Kd(), Qa(h, i)) : y(!i.f(), "We shouldn't be storing empty QueryMaps");
            var m = a.La();
            if (i.contains(m)) a = i.get(m), Ad(a, b, c, d, e); else {
                var n = this.g.ra.Q(f), n = a = "default" === a.La() ? new Fd(a, n) : new Nd(a, n);
                if (Md(i) || Rd(h)) i.add(m, n), i.S || (i.S = n.J.path); else {
                    var p, q;
                    i.f() || (p = i.toString(), q = i.Za());
                    i.add(m, n);
                    i.S || (i.S = n.J.path);
                    i.setActive(Sd(this, i));
                    p && q && id(this.u, i.path(), p, q);
                }
                Md(i) && Sa(h, function(a) {
                    if (a = a.k()) {
                        a.xa && a.xa();
                        a.xa = k;
                    }
                });
                Ad(a, b, c, d, e);
                (b = (b = Ta(K(this.la, f), function(a) {
                    var b;
                    if (b = a.k()) if (b = a.k().defaultView()) b = a.k().defaultView().pb;
                    if (b) return j;
                }, j)) || this.u === k && !T(this.g, f).f()) && Ed(a);
            }
            a.Eb();
        };
        function Td(a, b, c, d, e) {
            var f = a.get(b), h;
            if (h = f) {
                h = l;
                for (var i = f.na.length - 1; 0 <= i; i--) {
                    var m = f.na[i];
                    if ((!c || m.type === c) && (!d || m.X === d) && (!e || m.T === e)) if (f.na.splice(i, 1), 
                    h = j, c && d) break;
                }
                h = h && !(0 < f.na.length);
            }
            (c = h) && a.remove(b);
            return c;
        }
        Qd.prototype.fc = function(a, b, c, d) {
            var e = K(this.la, a.path).k();
            return e === k ? k : Ud(this, e, a, b, c, d);
        };
        function Ud(a, b, c, d, e, f) {
            var h = b.path(), h = K(a.la, h), c = c ? c.La() : k, i = [];
            c && "default" !== c ? Td(b, c, d, e, f) && i.push(c) : vb(b.keys(), function(a) {
                Td(b, a, d, e, f) && i.push(a);
            });
            b.f() && Qa(h, k);
            c = Rd(h);
            if (0 < i.length && !c) {
                for (var m = h, n = h.parent(), c = l; !c && n; ) {
                    var p = n.k();
                    if (p) {
                        y(!Md(p));
                        var q = m.name(), t = l;
                        Ec(p, function(a, b) {
                            t = b.Cc(q) || t;
                        });
                        t && (c = j);
                    }
                    m = n;
                    n = n.parent();
                }
                m = k;
                if (!Md(b)) {
                    n = b.xa;
                    b.xa = k;
                    var x = [], P = function(b) {
                        var c = b.k();
                        if (c && Ld(c)) x.push(c.path()), c.xa == k && c.setActive(Sd(a, c)); else {
                            if (c) {
                                c.xa != k || c.setActive(Sd(a, c));
                                var d = {};
                                Ec(c, function(a, b) {
                                    b.i.w(function(a) {
                                        C(d, a) || (d[a] = j, a = c.path().F(a), x.push(a));
                                    });
                                });
                            }
                            b.w(P);
                        }
                    };
                    P(h);
                    m = x;
                    n && n();
                }
                return c ? k : m;
            }
            return k;
        }
        function Vd(a, b, c) {
            Sa(K(a.la, b), function(a) {
                (a = a.k()) && Ec(a, function(a, b) {
                    Ed(b);
                });
            }, c, j);
        }
        function W(a, b, c) {
            function d(a) {
                do {
                    if (h[a.toString()]) return j;
                    a = a.parent();
                } while (a !== k);
                return l;
            }
            var e = a.Vb, f = a.g.ra;
            a.Vb = f;
            for (var h = {}, i = 0; i < c.length; i++) h[c[i].toString()] = j;
            Hd(e, f, b, a.la, function(c, e, f) {
                if (b.contains(c)) {
                    var h = d(c);
                    h && Vd(a, c, l);
                    a.cc(c, e, f);
                    h && Vd(a, c, j);
                } else a.cc(c, e, f);
            });
            d(b) && Vd(a, b, j);
            Wd(a, b);
        }
        function Wd(a, b) {
            var c = K(a.la, b);
            Sa(c, function(a) {
                (a = a.k()) && Ec(a, function(a, b) {
                    b.Eb();
                });
            }, j, j);
            Ta(c, function(a) {
                (a = a.k()) && Ec(a, function(a, b) {
                    b.Eb();
                });
            }, l);
        }
        Qd.prototype.cc = function(a, b, c) {
            a = K(this.la, a).k();
            a !== k && Ec(a, function(a, e) {
                e.cc(b, c);
            });
        };
        function Rd(a) {
            return Ta(a, function(a) {
                return a.k() && Md(a.k());
            });
        }
        function Sd(a, b) {
            if (a.u) {
                var c = a.u, d = b.path(), e = b.toString(), f = b.Za(), h, i = b.keys(), m = Ld(b), n = a.u, p = function(c) {
                    if ("ok" !== c) {
                        var d = "Unknown Error";
                        "too_big" === c ? d = "The data requested exceeds the maximum size that can be accessed with a single request." : "permission_denied" == c ? d = "Client doesn't have permission to access the desired data." : "unavailable" == c && (d = "The service is unavailable");
                        var e = Error(c + ": " + d);
                        e.code = c.toUpperCase();
                        M("on() or once() for " + b.path().toString() + " failed: " + e.toString());
                        b && (Ec(b, function(a, b) {
                            for (var c = 0; c < b.na.length; c++) {
                                var d = b.na[c];
                                d.cancel && (d.T ? v(d.cancel, d.T) : d.cancel)(e);
                            }
                        }), Ud(a, b));
                    } else h || (m ? Vd(a, b.path(), j) : vb(i, function(a) {
                        (a = b.get(a)) && Ed(a);
                    }), Wd(a, b.path()));
                }, q = b.toString(), t = b.path().toString();
                n.ga[t] = n.ga[t] || {};
                y(!n.ga[t][q], "listen() called twice for same path/queryId.");
                n.ga[t][q] = {
                    Za: b.Za(),
                    C: p
                };
                n.P && fd(n, t, q, b.Za(), p);
                return function() {
                    h = j;
                    id(c, d, e, f);
                };
            }
            return da;
        }
        Qd.prototype.lb = function(a, b, c, d) {
            var e = {};
            Ec(b, function(b, h) {
                var i = h.lb(a, c, d);
                cc(i, function(a, b) {
                    e[b] = 3 === a ? 3 : (wa(e, b) || a) === a ? a : 3;
                });
            });
            c.N() || c.w(function(a) {
                C(e, a) || (e[a] = 4);
            });
            return e;
        };
        function Xd(a, b, c, d, e) {
            var f = b.path(), b = a.lb(f, b, d, e), h = N, i = [];
            cc(b, function(b, n) {
                var p = new J(n);
                3 === b || 1 === b ? h = h.H(n, d.Q(p)) : (2 === b && i.push({
                    path: f.F(n),
                    pa: N
                }), i = i.concat(Yd(a, d.Q(p), K(c, p), e)));
            });
            return [ {
                path: f,
                pa: h
            } ].concat(i);
        }
        function Zd(a, b, c, d) {
            var e;
            a: {
                var f = K(a.la, b);
                e = f.parent();
                for (var h = []; e !== k; ) {
                    var i = e.k();
                    if (i !== k) {
                        if (Ld(i)) {
                            e = [ {
                                path: b,
                                pa: c
                            } ];
                            break a;
                        }
                        i = a.lb(b, i, c, d);
                        f = wa(i, f.name());
                        if (3 === f || 1 === f) {
                            e = [ {
                                path: b,
                                pa: c
                            } ];
                            break a;
                        }
                        2 === f && h.push({
                            path: b,
                            pa: N
                        });
                    }
                    f = e;
                    e = e.parent();
                }
                e = h;
            }
            if (1 == e.length && (!e[0].pa.f() || c.f())) return e;
            h = K(a.la, b);
            f = h.k();
            f !== k ? Ld(f) ? e.push({
                path: b,
                pa: c
            }) : e = e.concat(Xd(a, f, h, c, d)) : e = e.concat(Yd(a, c, h, d));
            return e;
        }
        function Yd(a, b, c, d) {
            var e = c.k();
            if (e !== k) return Ld(e) ? [ {
                path: c.path(),
                pa: b
            } ] : Xd(a, e, c, b, d);
            var f = [];
            c.w(function(c) {
                var e = b.N() ? N : b.M(c.name()), c = Yd(a, e, c, d);
                f = f.concat(c);
            });
            return f;
        }
        function $d(a, b) {
            if (!a || "object" !== typeof a) return a;
            y(".sv" in a, "Unexpected leaf node or priority contents");
            return b[a[".sv"]];
        }
        function ae(a, b) {
            var c = $d(a.j(), b), d;
            if (a.N()) {
                var e = $d(a.k(), b);
                return e !== a.k() || c !== a.j() ? new gc(e, c) : a;
            }
            d = a;
            c !== a.j() && (d = d.za(c));
            a.w(function(a, c) {
                var e = ae(c, b);
                e !== c && (d = d.H(a, e));
            });
            return d;
        }
        function be(a) {
            this.K = a;
            this.$ = Cc(a);
            this.u = new bd(this.K, v(this.Yb, this), v(this.Wb, this), v(this.vb, this), v(this.Kc, this), v(this.Bc, this));
            var b = v(function() {
                return new zc(this.$, this.u);
            }, this), a = a.toString();
            Bc[a] || (Bc[a] = b());
            this.qd = Bc[a];
            this.eb = new Pa();
            this.fb = new rd();
            this.g = new sd();
            this.G = new Qd(this.u, this.g.ma);
            this.Dc = new rd();
            this.Ec = new Qd(k, this.Dc);
            ce(this, "connected", l);
            ce(this, "authenticated", l);
            this.R = new nd();
            this.wc = 0;
        }
        r = be.prototype;
        r.toString = function() {
            return (this.K.hc ? "https://" : "http://") + this.K.host;
        };
        r.name = function() {
            return this.K.Sb;
        };
        function de(a) {
            a = T(a.Dc, new J(".info/serverTimeOffset")).V() || 0;
            return new Date().getTime() + a;
        }
        function ee(a) {
            a = a = {
                timestamp: de(a)
            };
            a.timestamp = a.timestamp || new Date().getTime();
            return a;
        }
        r.Yb = function(a, b, c) {
            this.wc++;
            var d, e, f = [];
            9 <= a.length && a.lastIndexOf(".priority") === a.length - 9 ? (d = new J(a.substring(0, a.length - 9)), 
            e = T(this.g.sa, d).za(b), f.push(d)) : c ? (d = new J(a), e = T(this.g.sa, d), 
            cc(b, function(a, b) {
                var c = new J(b);
                ".priority" === b ? e = e.za(a) : (e = e.ya(c, Q(a)), f.push(d.F(b)));
            })) : (d = new J(a), e = Q(b), f.push(d));
            a = Zd(this.G, d, e, this.g.I);
            b = l;
            for (c = 0; c < a.length; ++c) {
                var h = a[c], i = this.g, m = h.path;
                U(i.sa, m, h.pa);
                b = td(i, m) || b;
            }
            b && (d = fe(this, d));
            W(this.G, d, f);
        };
        r.Wb = function(a) {
            ce(this, "connected", a);
            if (a === l) {
                this.e("onDisconnectEvents");
                var b = this, c = [], d = ee(this), a = qd, e = new nd();
                qd(this.R, new J(""), function(a, b) {
                    od(e, a, ae(b, d));
                });
                a(e, new J(""), function(a, d) {
                    var e = Zd(b.G, a, d, b.g.I);
                    c.push.apply(c, b.g.set(a, e));
                    e = ge(b, a);
                    fe(b, e);
                    W(b.G, e, [ a ]);
                });
                vd(this.g, c);
                this.R = new nd();
            }
        };
        r.Kc = function(a) {
            var b = this;
            bc(a, function(a, d) {
                ce(b, d, a);
            });
        };
        r.Bc = function(a) {
            a = new J(a);
            return T(this.g.sa, a).hash();
        };
        r.vb = function(a) {
            ce(this, "authenticated", a);
        };
        function ce(a, b, c) {
            b = new J("/.info/" + b);
            U(a.Dc, b, Q(c));
            W(a.Ec, b, [ b ]);
        }
        r.hb = function(a, b, c) {
            "firebaseio-demo.com" === this.K.domain && M("FirebaseRef.auth() not supported on demo (*.firebaseio-demo.com) Firebases. Please use on production (*.firebaseio.com) Firebases only.");
            this.u.hb(a, function(a, c) {
                X(b, a, c);
            }, function(a, b) {
                M("auth() was canceled: " + b);
                if (c) {
                    var f = Error(b);
                    f.code = a.toUpperCase();
                    c(f);
                }
            });
        };
        r.Kb = function(a) {
            this.u.Kb(function(b) {
                X(a, b);
            });
        };
        r.bb = function(a, b, c, d) {
            this.e("set", {
                path: a.toString(),
                value: b,
                ia: c
            });
            var e = ee(this), b = Q(b, c), e = ae(b, e), e = Zd(this.G, a, e, this.g.I), f = this.g.set(a, e), h = this;
            this.u.put(a.toString(), b.V(j), function(b) {
                "ok" !== b && M("set at " + a + " failed: " + b);
                vd(h.g, f);
                td(h.g, a);
                var c = fe(h, a);
                W(h.G, c, []);
                X(d, b);
            });
            e = ge(this, a);
            fe(this, e);
            W(this.G, e, [ a ]);
        };
        r.update = function(a, b, c) {
            this.e("update", {
                path: a.toString(),
                value: b
            });
            var d = T(this.g.ma, a), e = j, f = [], h = ee(this), i = [], m;
            for (m in b) {
                var e = l, n = Q(b[m]), n = ae(n, h), d = d.H(m, n), p = a.F(m);
                f.push(p);
                n = Zd(this.G, p, n, this.g.I);
                i = i.concat(this.g.set(a, n));
            }
            if (e) L("update() called with empty data.  Don't do anything."), X(c, "ok"); else {
                var q = this;
                ld(this.u, "m", a.toString(), b, function(b) {
                    y("ok" === b || "permission_denied" === b, "merge at " + a + " failed.");
                    "ok" !== b && M("update at " + a + " failed: " + b);
                    vd(q.g, i);
                    td(q.g, a);
                    var d = fe(q, a);
                    W(q.G, d, []);
                    X(c, b);
                }, aa);
                b = ge(this, a);
                fe(this, b);
                W(q.G, b, f);
            }
        };
        r.Pc = function(a, b, c) {
            this.e("setPriority", {
                path: a.toString(),
                ia: b
            });
            var d = ee(this), d = $d(b, d), d = T(this.g.I, a).za(d), d = Zd(this.G, a, d, this.g.I), e = this.g.set(a, d), f = this;
            this.u.put(a.toString() + "/.priority", b, function(b) {
                "permission_denied" === b && M("setPriority at " + a + " failed: " + b);
                vd(f.g, e);
                td(f.g, a);
                var d = fe(f, a);
                W(f.G, d, []);
                X(c, b);
            });
            b = fe(this, a);
            W(f.G, b, []);
        };
        r.Hc = function(a, b) {
            var c = this;
            this.u.Hc(a.toString(), function(d) {
                "ok" === d && pd(c.R, a);
                X(b, d);
            });
        };
        function he(a, b, c, d) {
            var e = Q(c);
            jd(a.u, b.toString(), e.V(j), function(c) {
                "ok" === c && od(a.R, b, e);
                X(d, c);
            });
        }
        function ie(a) {
            xc(a.$, "deprecated_on_disconnect");
            a.qd.Sc.deprecated_on_disconnect = j;
        }
        r.Mb = function(a, b, c, d, e) {
            ".info" === E(a.path) ? this.Ec.Mb(a, b, c, d, e) : this.G.Mb(a, b, c, d, e);
        };
        r.fc = function(a, b, c, d) {
            if (".info" === E(a.path)) this.Ec.fc(a, b, c, d); else {
                b = this.G.fc(a, b, c, d);
                if (c = b !== k) {
                    for (var c = this.g, d = a.path, e = [], f = 0; f < b.length; ++f) e[f] = T(c.sa, b[f]);
                    U(c.sa, d, N);
                    for (f = 0; f < b.length; ++f) U(c.sa, b[f], e[f]);
                    c = td(c, d);
                }
                c && (y(this.g.ma.ra === this.G.Vb, "We should have raised any outstanding events by now.  Else, we'll blow them away."), 
                U(this.g.ma, a.path, T(this.g.I, a.path)), this.G.Vb = this.g.ma.ra);
            }
        };
        r.Ia = function() {
            this.u.Ia();
        };
        r.ab = function() {
            this.u.ab();
        };
        r.Qc = function(a) {
            if ("undefined" !== typeof console) {
                a ? (this.kc || (this.kc = new yc(this.$)), a = this.kc.get()) : a = this.$.get();
                var b = a, c = [], d = 0, e;
                for (e in b) c[d++] = e;
                var f = function(a, b) {
                    return Math.max(b.length, a);
                };
                if (c.reduce) e = c.reduce(f, 0); else {
                    var h = 0;
                    vb(c, function(a) {
                        h = f.call(aa, h, a);
                    });
                    e = h;
                }
                for (var i in a) {
                    b = a[i];
                    for (c = i.length; c < e + 2; c++) i += " ";
                    console.log(i + b);
                }
            }
        };
        r.Rc = function(a) {
            xc(this.$, a);
            this.qd.Sc[a] = j;
        };
        r.e = function() {
            L("r:" + this.u.id + ":", arguments);
        };
        function X(a, b, c) {
            a && fc(function() {
                if ("ok" == b) a(k, c); else {
                    var d = (b || "error").toUpperCase(), e = d;
                    c && (e += ": " + c);
                    e = Error(e);
                    e.code = d;
                    a(e);
                }
            });
        }
        function je(a, b) {
            var c = b || a.eb;
            b || ke(a, c);
            if (c.k() !== k) {
                var d = le(a, c);
                y(0 < d.length);
                if (xb(d, function(a) {
                    return 1 === a.status;
                })) {
                    for (var e = c.path(), f = 0; f < d.length; f++) y(1 === d[f].status, "tryToSendTransactionQueue_: items in queue should all be run."), 
                    d[f].status = 2, d[f].nd++;
                    c = T(a.g.I, e).hash();
                    U(a.g.I, e, T(a.g.ma, e));
                    for (var h = T(a.fb, e).V(j), i = Nb(), m = {}, n = 0; n < d.length; n++) d[n].qc && (m[d[n].path.toString()] = d[n].path);
                    var p = [], q;
                    for (q in m) p.push(m[q]);
                    for (f = 0; f < p.length; f++) Qa(K(a.g.Bb, p[f]), i);
                    a.u.put(e.toString(), h, function(b) {
                        a.e("transaction put response", {
                            path: e.toString(),
                            status: b
                        });
                        for (f = 0; f < p.length; f++) {
                            var c = K(a.g.Bb, p[f]), h = c.k();
                            y(h !== k, "sendTransactionQueue_: pendingPut should not be null.");
                            h === i && (Qa(c, k), U(a.g.I, p[f], T(a.g.sa, p[f])));
                        }
                        if ("ok" === b) {
                            b = [];
                            for (f = 0; f < d.length; f++) d[f].status = 3, d[f].C && (c = me(a, d[f].path), 
                            b.push(v(d[f].C, k, k, j, c))), d[f].nc();
                            ke(a, K(a.eb, e));
                            je(a);
                            for (f = 0; f < b.length; f++) fc(b[f]);
                        } else {
                            if ("datastale" === b) for (f = 0; f < d.length; f++) d[f].status = 4 === d[f].status ? 5 : 1; else {
                                M("transaction at " + e + " failed: " + b);
                                for (f = 0; f < d.length; f++) d[f].status = 5, d[f].oc = b;
                            }
                            b = fe(a, e);
                            W(a.G, b, [ e ]);
                        }
                    }, c);
                }
            } else c.nb() && c.w(function(b) {
                je(a, b);
            });
        }
        function fe(a, b) {
            var c = ne(a, b), d = c.path(), e = le(a, c);
            U(a.g.ma, d, T(a.g.I, d));
            U(a.fb, d, T(a.g.I, d));
            if (0 !== e.length) {
                for (var f = c = T(a.g.ma, d), h = [], i = 0; i < e.length; i++) {
                    var m = Na(d, e[i].path), n = l, p;
                    y(m !== k, "rerunTransactionsUnderNode_: relativePath should not be null.");
                    if (5 === e[i].status) n = j, p = e[i].oc; else if (1 === e[i].status) if (25 <= e[i].nd) n = j, 
                    p = "maxretry"; else {
                        var q = e[i].update(c.Q(m).V());
                        s(q) ? (Ba("transaction failed: Data returned ", q), q = Q(q), c = c.ya(m, q), e[i].qc && (f = f.ya(m, q))) : (n = j, 
                        p = "nodata");
                    }
                    n && (e[i].status = 3, setTimeout(e[i].nc, 0), e[i].C && (n = new H(a, e[i].path), 
                    m = new R(c.Q(m), n), "nodata" === p ? h.push(v(e[i].C, k, k, l, m)) : h.push(v(e[i].C, k, Error(p), l, m))));
                }
                p = T(a.g.I, d).j();
                c = c.za(p);
                f = f.za(p);
                U(a.fb, d, c);
                U(a.g.ma, d, f);
                ke(a, a.eb);
                for (i = 0; i < h.length; i++) fc(h[i]);
                je(a);
            }
            return d;
        }
        function ne(a, b) {
            for (var c, d = a.eb; (c = E(b)) !== k && d.k() === k; ) d = K(d, c), b = Ma(b);
            return d;
        }
        function le(a, b) {
            var c = [];
            oe(a, b, c);
            c.sort(function(a, b) {
                return a.hd - b.hd;
            });
            return c;
        }
        function oe(a, b, c) {
            var d = b.k();
            if (d !== k) for (var e = 0; e < d.length; e++) c.push(d[e]);
            b.w(function(b) {
                oe(a, b, c);
            });
        }
        function ke(a, b) {
            var c = b.k();
            if (c) {
                for (var d = 0, e = 0; e < c.length; e++) 3 !== c[e].status && (c[d] = c[e], d++);
                c.length = d;
                Qa(b, 0 < c.length ? c : k);
            }
            b.w(function(b) {
                ke(a, b);
            });
        }
        function ge(a, b) {
            var c = ne(a, b).path(), d = K(a.eb, b);
            Ta(d, function(a) {
                pe(a);
            });
            pe(d);
            Sa(d, function(a) {
                pe(a);
            });
            return c;
        }
        function pe(a) {
            var b = a.k();
            if (b !== k) {
                for (var c = [], d = -1, e = 0; e < b.length; e++) 4 !== b[e].status && (2 === b[e].status ? (y(d === e - 1, "All SENT items should be at beginning of queue."), 
                d = e, b[e].status = 4, b[e].oc = "set") : (y(1 === b[e].status), b[e].nc(), b[e].C && c.push(v(b[e].C, k, Error("set"), l, k))));
                -1 === d ? Qa(a, k) : b.length = d + 1;
                for (e = 0; e < c.length; e++) fc(c[e]);
            }
        }
        function me(a, b) {
            var c = new H(a, b);
            return new R(T(a.fb, b), c);
        }
        function Y() {
            this.$a = {};
        }
        ea(Y);
        Y.prototype.Ia = function() {
            for (var a in this.$a) this.$a[a].Ia();
        };
        Y.prototype.interrupt = Y.prototype.Ia;
        Y.prototype.ab = function() {
            for (var a in this.$a) this.$a[a].ab();
        };
        Y.prototype.resume = Y.prototype.ab;
        var Z = {
            Dd: function(a) {
                var b = O.prototype.hash;
                O.prototype.hash = a;
                var c = gc.prototype.hash;
                gc.prototype.hash = a;
                return function() {
                    O.prototype.hash = b;
                    gc.prototype.hash = c;
                };
            }
        };
        Z.hijackHash = Z.Dd;
        Z.La = function(a) {
            return a.La();
        };
        Z.queryIdentifier = Z.La;
        Z.Fd = function(a) {
            return a.n.u.ga;
        };
        Z.listens = Z.Fd;
        Z.Nd = function(a) {
            return a.n.u.ja;
        };
        Z.refConnection = Z.Nd;
        Z.sd = bd;
        Z.DataConnection = Z.sd;
        bd.prototype.sendRequest = bd.prototype.Ga;
        bd.prototype.interrupt = bd.prototype.Ia;
        Z.td = Uc;
        Z.RealTimeConnection = Z.td;
        Uc.prototype.sendRequest = Uc.prototype.od;
        Uc.prototype.close = Uc.prototype.close;
        Z.rd = pb;
        Z.ConnectionTarget = Z.rd;
        Z.Bd = function() {
            Ic = Oc = j;
        };
        Z.forceLongPolling = Z.Bd;
        Z.Cd = function() {
            Jc = j;
        };
        Z.forceWebSockets = Z.Cd;
        Z.Td = function(a, b) {
            a.n.u.Oc = b;
        };
        Z.setSecurityDebugCallback = Z.Td;
        Z.Qc = function(a, b) {
            a.n.Qc(b);
        };
        Z.stats = Z.Qc;
        Z.Rc = function(a, b) {
            a.n.Rc(b);
        };
        Z.statsIncrementCounter = Z.Rc;
        Z.wc = function(a) {
            return a.n.wc;
        };
        function $(a, b, c) {
            this.Fb = a;
            this.S = b;
            this.Ea = c;
        }
        $.prototype.cancel = function(a) {
            z("Firebase.onDisconnect().cancel", 0, 1, arguments.length);
            B("Firebase.onDisconnect().cancel", 1, a, j);
            this.Fb.Hc(this.S, a);
        };
        $.prototype.cancel = $.prototype.cancel;
        $.prototype.remove = function(a) {
            z("Firebase.onDisconnect().remove", 0, 1, arguments.length);
            D("Firebase.onDisconnect().remove", this.S);
            B("Firebase.onDisconnect().remove", 1, a, j);
            he(this.Fb, this.S, k, a);
        };
        $.prototype.remove = $.prototype.remove;
        $.prototype.set = function(a, b) {
            z("Firebase.onDisconnect().set", 1, 2, arguments.length);
            D("Firebase.onDisconnect().set", this.S);
            Aa("Firebase.onDisconnect().set", a, l);
            B("Firebase.onDisconnect().set", 2, b, j);
            he(this.Fb, this.S, a, b);
        };
        $.prototype.set = $.prototype.set;
        $.prototype.bb = function(a, b, c) {
            z("Firebase.onDisconnect().setWithPriority", 2, 3, arguments.length);
            D("Firebase.onDisconnect().setWithPriority", this.S);
            Aa("Firebase.onDisconnect().setWithPriority", a, l);
            Fa("Firebase.onDisconnect().setWithPriority", 2, b, l);
            B("Firebase.onDisconnect().setWithPriority", 3, c, j);
            (".length" === this.Ea || ".keys" === this.Ea) && g("Firebase.onDisconnect().setWithPriority failed: " + this.Ea + " is a read-only object.");
            var d = this.Fb, e = this.S, f = Q(a, b);
            jd(d.u, e.toString(), f.V(j), function(a) {
                "ok" === a && od(d.R, e, f);
                X(c, a);
            });
        };
        $.prototype.setWithPriority = $.prototype.bb;
        $.prototype.update = function(a, b) {
            z("Firebase.onDisconnect().update", 1, 2, arguments.length);
            D("Firebase.onDisconnect().update", this.S);
            Ea("Firebase.onDisconnect().update", a);
            B("Firebase.onDisconnect().update", 2, b, j);
            var c = this.Fb, d = this.S, e = j, f;
            for (f in a) e = l;
            if (e) L("onDisconnect().update() called with empty data.  Don't do anything."), 
            X(b, j); else {
                e = c.u;
                f = d.toString();
                var h = function(e) {
                    if ("ok" === e) for (var f in a) {
                        var h = Q(a[f]);
                        od(c.R, d.F(f), h);
                    }
                    X(b, e);
                };
                e.P ? kd(e, "om", f, a, h) : e.wb.push({
                    Mc: f,
                    action: "om",
                    data: a,
                    C: h
                });
            }
        };
        $.prototype.update = $.prototype.update;
        var qe, re = 0, se = [];
        qe = function(a) {
            var b = a === re;
            re = a;
            for (var c = Array(8), d = 7; 0 <= d; d--) c[d] = "-0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ_abcdefghijklmnopqrstuvwxyz".charAt(a % 64), 
            a = Math.floor(a / 64);
            y(0 === a);
            a = c.join("");
            if (b) {
                for (d = 11; 0 <= d && 63 === se[d]; d--) se[d] = 0;
                se[d]++;
            } else for (d = 0; 12 > d; d++) se[d] = Math.floor(64 * Math.random());
            for (d = 0; 12 > d; d++) a += "-0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ_abcdefghijklmnopqrstuvwxyz".charAt(se[d]);
            y(20 === a.length, "NextPushId: Length should be 20.");
            return a;
        };
        function H() {
            var a, b, c;
            if (arguments[0] instanceof be) c = arguments[0], a = arguments[1]; else {
                z("new Firebase", 1, 2, arguments.length);
                var d = arguments[0];
                b = a = "";
                var e = j, f = "";
                if (u(d)) {
                    var h = d.indexOf("//");
                    if (0 <= h) var i = d.substring(0, h - 1), d = d.substring(h + 2);
                    h = d.indexOf("/");
                    -1 === h && (h = d.length);
                    a = d.substring(0, h);
                    var d = d.substring(h + 1), m = a.split(".");
                    if (3 == m.length) {
                        h = m[2].indexOf(":");
                        e = 0 <= h ? "https" === i : j;
                        if ("firebase" === m[1]) Wb(a + " is no longer supported. Please use <YOUR FIREBASE>.firebaseio.com instead"); else {
                            b = m[0];
                            f = "";
                            d = ("/" + d).split("/");
                            for (i = 0; i < d.length; i++) if (0 < d[i].length) {
                                h = d[i];
                                try {
                                    h = decodeURIComponent(h.replace(/\+/g, " "));
                                } catch (n) {}
                                f += "/" + h;
                            }
                        }
                        b = b.toLowerCase();
                    } else b = k;
                }
                e || "undefined" !== typeof window && (window.location && window.location.protocol && -1 !== window.location.protocol.indexOf("https:")) && M("Insecure Firebase access from a secure page. Please use https in calls to new Firebase().");
                a = new pb(a, e, b);
                b = new J(f);
                e = b.toString();
                if (!(d = !u(a.host))) if (!(d = 0 === a.host.length)) if (!(d = !za(a.Sb))) if (d = 0 !== e.length) e && (e = e.replace(/^\/*\.info(\/|$)/, "/")), 
                d = !(u(e) && 0 !== e.length && !ya.test(e));
                d && g(Error(A("new Firebase", 1, l) + 'must be a valid firebase URL and the path can\'t contain ".", "#", "$", "[", or "]".'));
                arguments[1] ? arguments[1] instanceof Y ? c = arguments[1] : g(Error("Expected a valid Firebase.Context for second argument to new Firebase()")) : c = Y.mb();
                e = a.toString();
                d = wa(c.$a, e);
                d || (d = new be(a), c.$a[e] = d);
                c = d;
                a = b;
            }
            F.call(this, c, a);
        }
        la(H, F);
        var te = H, ue = [ "Firebase" ], ve = ca;
        !(ue[0] in ve) && ve.execScript && ve.execScript("var " + ue[0]);
        for (var we; ue.length && (we = ue.shift()); ) !ue.length && s(te) ? ve[we] = te : ve = ve[we] ? ve[we] : ve[we] = {};
        H.prototype.name = function() {
            z("Firebase.name", 0, 0, arguments.length);
            return this.path.f() ? k : this.path.Z < this.path.m.length ? this.path.m[this.path.m.length - 1] : k;
        };
        H.prototype.name = H.prototype.name;
        H.prototype.F = function(a) {
            z("Firebase.child", 1, 1, arguments.length);
            if (ha(a)) a = String(a); else if (!(a instanceof J)) if (E(this.path) === k) {
                var b = a;
                b && (b = b.replace(/^\/*\.info(\/|$)/, "/"));
                Ia("Firebase.child", b);
            } else Ia("Firebase.child", a);
            return new H(this.n, this.path.F(a));
        };
        H.prototype.child = H.prototype.F;
        H.prototype.parent = function() {
            z("Firebase.parent", 0, 0, arguments.length);
            var a = this.path.parent();
            return a === k ? k : new H(this.n, a);
        };
        H.prototype.parent = H.prototype.parent;
        H.prototype.root = function() {
            z("Firebase.ref", 0, 0, arguments.length);
            for (var a = this; a.parent() !== k; ) a = a.parent();
            return a;
        };
        H.prototype.root = H.prototype.root;
        H.prototype.toString = function() {
            z("Firebase.toString", 0, 0, arguments.length);
            var a;
            if (this.parent() === k) a = this.n.toString(); else {
                a = this.parent().toString() + "/";
                var b = this.name();
                a += encodeURIComponent(String(b));
            }
            return a;
        };
        H.prototype.toString = H.prototype.toString;
        H.prototype.set = function(a, b) {
            z("Firebase.set", 1, 2, arguments.length);
            D("Firebase.set", this.path);
            Aa("Firebase.set", a, l);
            B("Firebase.set", 2, b, j);
            return this.n.bb(this.path, a, k, b);
        };
        H.prototype.set = H.prototype.set;
        H.prototype.update = function(a, b) {
            z("Firebase.update", 1, 2, arguments.length);
            D("Firebase.update", this.path);
            Ea("Firebase.update", a);
            B("Firebase.update", 2, b, j);
            C(a, ".priority") && g(Error("update() does not currently support updating .priority."));
            return this.n.update(this.path, a, b);
        };
        H.prototype.update = H.prototype.update;
        H.prototype.bb = function(a, b, c) {
            z("Firebase.setWithPriority", 2, 3, arguments.length);
            D("Firebase.setWithPriority", this.path);
            Aa("Firebase.setWithPriority", a, l);
            Fa("Firebase.setWithPriority", 2, b, l);
            B("Firebase.setWithPriority", 3, c, j);
            (".length" === this.name() || ".keys" === this.name()) && g("Firebase.setWithPriority failed: " + this.name() + " is a read-only object.");
            return this.n.bb(this.path, a, b, c);
        };
        H.prototype.setWithPriority = H.prototype.bb;
        H.prototype.remove = function(a) {
            z("Firebase.remove", 0, 1, arguments.length);
            D("Firebase.remove", this.path);
            B("Firebase.remove", 1, a, j);
            this.set(k, a);
        };
        H.prototype.remove = H.prototype.remove;
        H.prototype.transaction = function(a, b, c) {
            function d() {}
            z("Firebase.transaction", 1, 3, arguments.length);
            D("Firebase.transaction", this.path);
            B("Firebase.transaction", 1, a, l);
            B("Firebase.transaction", 2, b, j);
            s(c) && "boolean" != typeof c && g(Error(A("Firebase.transaction", 3, j) + "must be a boolean."));
            (".length" === this.name() || ".keys" === this.name()) && g("Firebase.transaction failed: " + this.name() + " is a read-only object.");
            "undefined" === typeof c && (c = j);
            var e = this.n, f = this.path, h = c;
            e.e("transaction on " + f);
            var i = new H(e, f);
            i.Xa("value", d);
            var h = {
                path: f,
                update: a,
                C: b,
                status: k,
                hd: Nb(),
                qc: h,
                nd: 0,
                nc: function() {
                    i.ub("value", d);
                },
                oc: k
            }, m = h.update(T(e.fb, f).V());
            if (s(m)) {
                Ba("transaction failed: Data returned ", m);
                h.status = 1;
                var n = K(e.eb, f), p = n.k() || [];
                p.push(h);
                Qa(n, p);
                p = "object" === typeof m && m !== k && C(m, ".priority") ? m[".priority"] : T(e.g.I, f).j();
                n = ee(e);
                m = Q(m, p);
                m = ae(m, n);
                U(e.fb, f, m);
                h.qc && (U(e.g.ma, f, m), W(e.G, f, [ f ]));
                je(e);
            } else h.nc(), h.C && (e = me(e, f), h.C(k, l, e));
        };
        H.prototype.transaction = H.prototype.transaction;
        H.prototype.Pc = function(a, b) {
            z("Firebase.setPriority", 1, 2, arguments.length);
            D("Firebase.setPriority", this.path);
            Fa("Firebase.setPriority", 1, a, l);
            B("Firebase.setPriority", 2, b, j);
            this.n.Pc(this.path, a, b);
        };
        H.prototype.setPriority = H.prototype.Pc;
        H.prototype.push = function(a, b) {
            z("Firebase.push", 0, 2, arguments.length);
            D("Firebase.push", this.path);
            Aa("Firebase.push", a, j);
            B("Firebase.push", 2, b, j);
            var c = de(this.n), c = qe(c), c = this.F(c);
            "undefined" !== typeof a && a !== k && c.set(a, b);
            return c;
        };
        H.prototype.push = H.prototype.push;
        H.prototype.ha = function() {
            return new $(this.n, this.path, this.name());
        };
        H.prototype.onDisconnect = H.prototype.ha;
        H.prototype.Od = function() {
            M("FirebaseRef.removeOnDisconnect() being deprecated. Please use FirebaseRef.onDisconnect().remove() instead.");
            this.ha().remove();
            ie(this.n);
        };
        H.prototype.removeOnDisconnect = H.prototype.Od;
        H.prototype.Sd = function(a) {
            M("FirebaseRef.setOnDisconnect(value) being deprecated. Please use FirebaseRef.onDisconnect().set(value) instead.");
            this.ha().set(a);
            ie(this.n);
        };
        H.prototype.setOnDisconnect = H.prototype.Sd;
        H.prototype.hb = function(a, b, c) {
            z("Firebase.auth", 1, 3, arguments.length);
            u(a) || g(Error(A("Firebase.auth", 1, l) + "must be a valid credential (a string)."));
            B("Firebase.auth", 2, b, j);
            B("Firebase.auth", 3, b, j);
            this.n.hb(a, b, c);
        };
        H.prototype.auth = H.prototype.hb;
        H.prototype.Kb = function(a) {
            z("Firebase.unauth", 0, 1, arguments.length);
            B("Firebase.unauth", 1, a, j);
            this.n.Kb(a);
        };
        H.prototype.unauth = H.prototype.Kb;
        H.goOffline = function() {
            z("Firebase.goOffline", 0, 0, arguments.length);
            Y.mb().Ia();
        };
        H.goOnline = function() {
            z("Firebase.goOnline", 0, 0, arguments.length);
            Y.mb().ab();
        };
        function Tb(a, b) {
            y(!b || a === j || a === l, "Can't turn on custom loggers persistently.");
            a === j ? ("undefined" !== typeof console && ("function" === typeof console.log ? Rb = v(console.log, console) : "object" === typeof console.log && (Rb = function(a) {
                console.log(a);
            })), b && ob.set("logging_enabled", j)) : a ? Rb = a : (Rb = k, ob.remove("logging_enabled"));
        }
        H.enableLogging = Tb;
        H.ServerValue = {
            TIMESTAMP: {
                ".sv": "timestamp"
            }
        };
        H.INTERNAL = Z;
        H.Context = Y;
    }).bind(this)();
}.bind(this));

require.register("app/vendor/handlebars.js", function(exports, require, module) {
    /*!
    
     handlebars v1.3.0
    
    Copyright (C) 2011 by Yehuda Katz
    
    Permission is hereby granted, free of charge, to any person obtaining a copy
    of this software and associated documentation files (the "Software"), to deal
    in the Software without restriction, including without limitation the rights
    to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
    copies of the Software, and to permit persons to whom the Software is
    furnished to do so, subject to the following conditions:
    
    The above copyright notice and this permission notice shall be included in
    all copies or substantial portions of the Software.
    
    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
    THE SOFTWARE.
    
    @license
    */
    /* exported Handlebars */
    var Handlebars = function() {
        // handlebars/safe-string.js
        var __module4__ = function() {
            "use strict";
            var __exports__;
            // Build out our basic SafeString type
            function SafeString(string) {
                this.string = string;
            }
            SafeString.prototype.toString = function() {
                return "" + this.string;
            };
            __exports__ = SafeString;
            return __exports__;
        }();
        // handlebars/utils.js
        var __module3__ = function(__dependency1__) {
            "use strict";
            var __exports__ = {};
            /*jshint -W004 */
            var SafeString = __dependency1__;
            var escape = {
                "&": "&amp;",
                "<": "&lt;",
                ">": "&gt;",
                '"': "&quot;",
                "'": "&#x27;",
                "`": "&#x60;"
            };
            var badChars = /[&<>"'`]/g;
            var possible = /[&<>"'`]/;
            function escapeChar(chr) {
                return escape[chr] || "&amp;";
            }
            function extend(obj, value) {
                for (var key in value) {
                    if (Object.prototype.hasOwnProperty.call(value, key)) {
                        obj[key] = value[key];
                    }
                }
            }
            __exports__.extend = extend;
            var toString = Object.prototype.toString;
            __exports__.toString = toString;
            // Sourced from lodash
            // https://github.com/bestiejs/lodash/blob/master/LICENSE.txt
            var isFunction = function(value) {
                return typeof value === "function";
            };
            // fallback for older versions of Chrome and Safari
            if (isFunction(/x/)) {
                isFunction = function(value) {
                    return typeof value === "function" && toString.call(value) === "[object Function]";
                };
            }
            var isFunction;
            __exports__.isFunction = isFunction;
            var isArray = Array.isArray || function(value) {
                return value && typeof value === "object" ? toString.call(value) === "[object Array]" : false;
            };
            __exports__.isArray = isArray;
            function escapeExpression(string) {
                // don't escape SafeStrings, since they're already safe
                if (string instanceof SafeString) {
                    return string.toString();
                } else if (!string && string !== 0) {
                    return "";
                }
                // Force a string conversion as this will be done by the append regardless and
                // the regex test will do this transparently behind the scenes, causing issues if
                // an object's to string has escaped characters in it.
                string = "" + string;
                if (!possible.test(string)) {
                    return string;
                }
                return string.replace(badChars, escapeChar);
            }
            __exports__.escapeExpression = escapeExpression;
            function isEmpty(value) {
                if (!value && value !== 0) {
                    return true;
                } else if (isArray(value) && value.length === 0) {
                    return true;
                } else {
                    return false;
                }
            }
            __exports__.isEmpty = isEmpty;
            return __exports__;
        }(__module4__);
        // handlebars/exception.js
        var __module5__ = function() {
            "use strict";
            var __exports__;
            var errorProps = [ "description", "fileName", "lineNumber", "message", "name", "number", "stack" ];
            function Exception(message, node) {
                var line;
                if (node && node.firstLine) {
                    line = node.firstLine;
                    message += " - " + line + ":" + node.firstColumn;
                }
                var tmp = Error.prototype.constructor.call(this, message);
                // Unfortunately errors are not enumerable in Chrome (at least), so `for prop in tmp` doesn't work.
                for (var idx = 0; idx < errorProps.length; idx++) {
                    this[errorProps[idx]] = tmp[errorProps[idx]];
                }
                if (line) {
                    this.lineNumber = line;
                    this.column = node.firstColumn;
                }
            }
            Exception.prototype = new Error();
            __exports__ = Exception;
            return __exports__;
        }();
        // handlebars/base.js
        var __module2__ = function(__dependency1__, __dependency2__) {
            "use strict";
            var __exports__ = {};
            var Utils = __dependency1__;
            var Exception = __dependency2__;
            var VERSION = "1.3.0";
            __exports__.VERSION = VERSION;
            var COMPILER_REVISION = 4;
            __exports__.COMPILER_REVISION = COMPILER_REVISION;
            var REVISION_CHANGES = {
                1: "<= 1.0.rc.2",
                // 1.0.rc.2 is actually rev2 but doesn't report it
                2: "== 1.0.0-rc.3",
                3: "== 1.0.0-rc.4",
                4: ">= 1.0.0"
            };
            __exports__.REVISION_CHANGES = REVISION_CHANGES;
            var isArray = Utils.isArray, isFunction = Utils.isFunction, toString = Utils.toString, objectType = "[object Object]";
            function HandlebarsEnvironment(helpers, partials) {
                this.helpers = helpers || {};
                this.partials = partials || {};
                registerDefaultHelpers(this);
            }
            __exports__.HandlebarsEnvironment = HandlebarsEnvironment;
            HandlebarsEnvironment.prototype = {
                constructor: HandlebarsEnvironment,
                logger: logger,
                log: log,
                registerHelper: function(name, fn, inverse) {
                    if (toString.call(name) === objectType) {
                        if (inverse || fn) {
                            throw new Exception("Arg not supported with multiple helpers");
                        }
                        Utils.extend(this.helpers, name);
                    } else {
                        if (inverse) {
                            fn.not = inverse;
                        }
                        this.helpers[name] = fn;
                    }
                },
                registerPartial: function(name, str) {
                    if (toString.call(name) === objectType) {
                        Utils.extend(this.partials, name);
                    } else {
                        this.partials[name] = str;
                    }
                }
            };
            function registerDefaultHelpers(instance) {
                instance.registerHelper("helperMissing", function(arg) {
                    if (arguments.length === 2) {
                        return undefined;
                    } else {
                        throw new Exception("Missing helper: '" + arg + "'");
                    }
                });
                instance.registerHelper("blockHelperMissing", function(context, options) {
                    var inverse = options.inverse || function() {}, fn = options.fn;
                    if (isFunction(context)) {
                        context = context.call(this);
                    }
                    if (context === true) {
                        return fn(this);
                    } else if (context === false || context == null) {
                        return inverse(this);
                    } else if (isArray(context)) {
                        if (context.length > 0) {
                            return instance.helpers.each(context, options);
                        } else {
                            return inverse(this);
                        }
                    } else {
                        return fn(context);
                    }
                });
                instance.registerHelper("each", function(context, options) {
                    var fn = options.fn, inverse = options.inverse;
                    var i = 0, ret = "", data;
                    if (isFunction(context)) {
                        context = context.call(this);
                    }
                    if (options.data) {
                        data = createFrame(options.data);
                    }
                    if (context && typeof context === "object") {
                        if (isArray(context)) {
                            for (var j = context.length; i < j; i++) {
                                if (data) {
                                    data.index = i;
                                    data.first = i === 0;
                                    data.last = i === context.length - 1;
                                }
                                ret = ret + fn(context[i], {
                                    data: data
                                });
                            }
                        } else {
                            for (var key in context) {
                                if (context.hasOwnProperty(key)) {
                                    if (data) {
                                        data.key = key;
                                        data.index = i;
                                        data.first = i === 0;
                                    }
                                    ret = ret + fn(context[key], {
                                        data: data
                                    });
                                    i++;
                                }
                            }
                        }
                    }
                    if (i === 0) {
                        ret = inverse(this);
                    }
                    return ret;
                });
                instance.registerHelper("if", function(conditional, options) {
                    if (isFunction(conditional)) {
                        conditional = conditional.call(this);
                    }
                    // Default behavior is to render the positive path if the value is truthy and not empty.
                    // The `includeZero` option may be set to treat the condtional as purely not empty based on the
                    // behavior of isEmpty. Effectively this determines if 0 is handled by the positive path or negative.
                    if (!options.hash.includeZero && !conditional || Utils.isEmpty(conditional)) {
                        return options.inverse(this);
                    } else {
                        return options.fn(this);
                    }
                });
                instance.registerHelper("unless", function(conditional, options) {
                    return instance.helpers["if"].call(this, conditional, {
                        fn: options.inverse,
                        inverse: options.fn,
                        hash: options.hash
                    });
                });
                instance.registerHelper("with", function(context, options) {
                    if (isFunction(context)) {
                        context = context.call(this);
                    }
                    if (!Utils.isEmpty(context)) return options.fn(context);
                });
                instance.registerHelper("log", function(context, options) {
                    var level = options.data && options.data.level != null ? parseInt(options.data.level, 10) : 1;
                    instance.log(level, context);
                });
            }
            var logger = {
                methodMap: {
                    0: "debug",
                    1: "info",
                    2: "warn",
                    3: "error"
                },
                // State enum
                DEBUG: 0,
                INFO: 1,
                WARN: 2,
                ERROR: 3,
                level: 3,
                // can be overridden in the host environment
                log: function(level, obj) {
                    if (logger.level <= level) {
                        var method = logger.methodMap[level];
                        if (typeof console !== "undefined" && console[method]) {
                            console[method].call(console, obj);
                        }
                    }
                }
            };
            __exports__.logger = logger;
            function log(level, obj) {
                logger.log(level, obj);
            }
            __exports__.log = log;
            var createFrame = function(object) {
                var obj = {};
                Utils.extend(obj, object);
                return obj;
            };
            __exports__.createFrame = createFrame;
            return __exports__;
        }(__module3__, __module5__);
        // handlebars/runtime.js
        var __module6__ = function(__dependency1__, __dependency2__, __dependency3__) {
            "use strict";
            var __exports__ = {};
            var Utils = __dependency1__;
            var Exception = __dependency2__;
            var COMPILER_REVISION = __dependency3__.COMPILER_REVISION;
            var REVISION_CHANGES = __dependency3__.REVISION_CHANGES;
            function checkRevision(compilerInfo) {
                var compilerRevision = compilerInfo && compilerInfo[0] || 1, currentRevision = COMPILER_REVISION;
                if (compilerRevision !== currentRevision) {
                    if (compilerRevision < currentRevision) {
                        var runtimeVersions = REVISION_CHANGES[currentRevision], compilerVersions = REVISION_CHANGES[compilerRevision];
                        throw new Exception("Template was precompiled with an older version of Handlebars than the current runtime. " + "Please update your precompiler to a newer version (" + runtimeVersions + ") or downgrade your runtime to an older version (" + compilerVersions + ").");
                    } else {
                        // Use the embedded version info since the runtime doesn't know about this revision yet
                        throw new Exception("Template was precompiled with a newer version of Handlebars than the current runtime. " + "Please update your runtime to a newer version (" + compilerInfo[1] + ").");
                    }
                }
            }
            __exports__.checkRevision = checkRevision;
            // TODO: Remove this line and break up compilePartial
            function template(templateSpec, env) {
                if (!env) {
                    throw new Exception("No environment passed to template");
                }
                // Note: Using env.VM references rather than local var references throughout this section to allow
                // for external users to override these as psuedo-supported APIs.
                var invokePartialWrapper = function(partial, name, context, helpers, partials, data) {
                    var result = env.VM.invokePartial.apply(this, arguments);
                    if (result != null) {
                        return result;
                    }
                    if (env.compile) {
                        var options = {
                            helpers: helpers,
                            partials: partials,
                            data: data
                        };
                        partials[name] = env.compile(partial, {
                            data: data !== undefined
                        }, env);
                        return partials[name](context, options);
                    } else {
                        throw new Exception("The partial " + name + " could not be compiled when running in runtime-only mode");
                    }
                };
                // Just add water
                var container = {
                    escapeExpression: Utils.escapeExpression,
                    invokePartial: invokePartialWrapper,
                    programs: [],
                    program: function(i, fn, data) {
                        var programWrapper = this.programs[i];
                        if (data) {
                            programWrapper = program(i, fn, data);
                        } else if (!programWrapper) {
                            programWrapper = this.programs[i] = program(i, fn);
                        }
                        return programWrapper;
                    },
                    merge: function(param, common) {
                        var ret = param || common;
                        if (param && common && param !== common) {
                            ret = {};
                            Utils.extend(ret, common);
                            Utils.extend(ret, param);
                        }
                        return ret;
                    },
                    programWithDepth: env.VM.programWithDepth,
                    noop: env.VM.noop,
                    compilerInfo: null
                };
                return function(context, options) {
                    options = options || {};
                    var namespace = options.partial ? options : env, helpers, partials;
                    if (!options.partial) {
                        helpers = options.helpers;
                        partials = options.partials;
                    }
                    var result = templateSpec.call(container, namespace, context, helpers, partials, options.data);
                    if (!options.partial) {
                        env.VM.checkRevision(container.compilerInfo);
                    }
                    return result;
                };
            }
            __exports__.template = template;
            function programWithDepth(i, fn, data) {
                var args = Array.prototype.slice.call(arguments, 3);
                var prog = function(context, options) {
                    options = options || {};
                    return fn.apply(this, [ context, options.data || data ].concat(args));
                };
                prog.program = i;
                prog.depth = args.length;
                return prog;
            }
            __exports__.programWithDepth = programWithDepth;
            function program(i, fn, data) {
                var prog = function(context, options) {
                    options = options || {};
                    return fn(context, options.data || data);
                };
                prog.program = i;
                prog.depth = 0;
                return prog;
            }
            __exports__.program = program;
            function invokePartial(partial, name, context, helpers, partials, data) {
                var options = {
                    partial: true,
                    helpers: helpers,
                    partials: partials,
                    data: data
                };
                if (partial === undefined) {
                    throw new Exception("The partial " + name + " could not be found");
                } else if (partial instanceof Function) {
                    return partial(context, options);
                }
            }
            __exports__.invokePartial = invokePartial;
            function noop() {
                return "";
            }
            __exports__.noop = noop;
            return __exports__;
        }(__module3__, __module5__, __module2__);
        // handlebars.runtime.js
        var __module1__ = function(__dependency1__, __dependency2__, __dependency3__, __dependency4__, __dependency5__) {
            "use strict";
            var __exports__;
            /*globals Handlebars: true */
            var base = __dependency1__;
            // Each of these augment the Handlebars object. No need to setup here.
            // (This is done to easily share code between commonjs and browse envs)
            var SafeString = __dependency2__;
            var Exception = __dependency3__;
            var Utils = __dependency4__;
            var runtime = __dependency5__;
            // For compatibility and usage outside of module systems, make the Handlebars object a namespace
            var create = function() {
                var hb = new base.HandlebarsEnvironment();
                Utils.extend(hb, base);
                hb.SafeString = SafeString;
                hb.Exception = Exception;
                hb.Utils = Utils;
                hb.VM = runtime;
                hb.template = function(spec) {
                    return runtime.template(spec, hb);
                };
                return hb;
            };
            var Handlebars = create();
            Handlebars.create = create;
            __exports__ = Handlebars;
            return __exports__;
        }(__module2__, __module4__, __module5__, __module3__, __module6__);
        // handlebars/compiler/ast.js
        var __module7__ = function(__dependency1__) {
            "use strict";
            var __exports__;
            var Exception = __dependency1__;
            function LocationInfo(locInfo) {
                locInfo = locInfo || {};
                this.firstLine = locInfo.first_line;
                this.firstColumn = locInfo.first_column;
                this.lastColumn = locInfo.last_column;
                this.lastLine = locInfo.last_line;
            }
            var AST = {
                ProgramNode: function(statements, inverseStrip, inverse, locInfo) {
                    var inverseLocationInfo, firstInverseNode;
                    if (arguments.length === 3) {
                        locInfo = inverse;
                        inverse = null;
                    } else if (arguments.length === 2) {
                        locInfo = inverseStrip;
                        inverseStrip = null;
                    }
                    LocationInfo.call(this, locInfo);
                    this.type = "program";
                    this.statements = statements;
                    this.strip = {};
                    if (inverse) {
                        firstInverseNode = inverse[0];
                        if (firstInverseNode) {
                            inverseLocationInfo = {
                                first_line: firstInverseNode.firstLine,
                                last_line: firstInverseNode.lastLine,
                                last_column: firstInverseNode.lastColumn,
                                first_column: firstInverseNode.firstColumn
                            };
                            this.inverse = new AST.ProgramNode(inverse, inverseStrip, inverseLocationInfo);
                        } else {
                            this.inverse = new AST.ProgramNode(inverse, inverseStrip);
                        }
                        this.strip.right = inverseStrip.left;
                    } else if (inverseStrip) {
                        this.strip.left = inverseStrip.right;
                    }
                },
                MustacheNode: function(rawParams, hash, open, strip, locInfo) {
                    LocationInfo.call(this, locInfo);
                    this.type = "mustache";
                    this.strip = strip;
                    // Open may be a string parsed from the parser or a passed boolean flag
                    if (open != null && open.charAt) {
                        // Must use charAt to support IE pre-10
                        var escapeFlag = open.charAt(3) || open.charAt(2);
                        this.escaped = escapeFlag !== "{" && escapeFlag !== "&";
                    } else {
                        this.escaped = !!open;
                    }
                    if (rawParams instanceof AST.SexprNode) {
                        this.sexpr = rawParams;
                    } else {
                        // Support old AST API
                        this.sexpr = new AST.SexprNode(rawParams, hash);
                    }
                    this.sexpr.isRoot = true;
                    // Support old AST API that stored this info in MustacheNode
                    this.id = this.sexpr.id;
                    this.params = this.sexpr.params;
                    this.hash = this.sexpr.hash;
                    this.eligibleHelper = this.sexpr.eligibleHelper;
                    this.isHelper = this.sexpr.isHelper;
                },
                SexprNode: function(rawParams, hash, locInfo) {
                    LocationInfo.call(this, locInfo);
                    this.type = "sexpr";
                    this.hash = hash;
                    var id = this.id = rawParams[0];
                    var params = this.params = rawParams.slice(1);
                    // a mustache is an eligible helper if:
                    // * its id is simple (a single part, not `this` or `..`)
                    var eligibleHelper = this.eligibleHelper = id.isSimple;
                    // a mustache is definitely a helper if:
                    // * it is an eligible helper, and
                    // * it has at least one parameter or hash segment
                    this.isHelper = eligibleHelper && (params.length || hash);
                },
                PartialNode: function(partialName, context, strip, locInfo) {
                    LocationInfo.call(this, locInfo);
                    this.type = "partial";
                    this.partialName = partialName;
                    this.context = context;
                    this.strip = strip;
                },
                BlockNode: function(mustache, program, inverse, close, locInfo) {
                    LocationInfo.call(this, locInfo);
                    if (mustache.sexpr.id.original !== close.path.original) {
                        throw new Exception(mustache.sexpr.id.original + " doesn't match " + close.path.original, this);
                    }
                    this.type = "block";
                    this.mustache = mustache;
                    this.program = program;
                    this.inverse = inverse;
                    this.strip = {
                        left: mustache.strip.left,
                        right: close.strip.right
                    };
                    (program || inverse).strip.left = mustache.strip.right;
                    (inverse || program).strip.right = close.strip.left;
                    if (inverse && !program) {
                        this.isInverse = true;
                    }
                },
                ContentNode: function(string, locInfo) {
                    LocationInfo.call(this, locInfo);
                    this.type = "content";
                    this.string = string;
                },
                HashNode: function(pairs, locInfo) {
                    LocationInfo.call(this, locInfo);
                    this.type = "hash";
                    this.pairs = pairs;
                },
                IdNode: function(parts, locInfo) {
                    LocationInfo.call(this, locInfo);
                    this.type = "ID";
                    var original = "", dig = [], depth = 0;
                    for (var i = 0, l = parts.length; i < l; i++) {
                        var part = parts[i].part;
                        original += (parts[i].separator || "") + part;
                        if (part === ".." || part === "." || part === "this") {
                            if (dig.length > 0) {
                                throw new Exception("Invalid path: " + original, this);
                            } else if (part === "..") {
                                depth++;
                            } else {
                                this.isScoped = true;
                            }
                        } else {
                            dig.push(part);
                        }
                    }
                    this.original = original;
                    this.parts = dig;
                    this.string = dig.join(".");
                    this.depth = depth;
                    // an ID is simple if it only has one part, and that part is not
                    // `..` or `this`.
                    this.isSimple = parts.length === 1 && !this.isScoped && depth === 0;
                    this.stringModeValue = this.string;
                },
                PartialNameNode: function(name, locInfo) {
                    LocationInfo.call(this, locInfo);
                    this.type = "PARTIAL_NAME";
                    this.name = name.original;
                },
                DataNode: function(id, locInfo) {
                    LocationInfo.call(this, locInfo);
                    this.type = "DATA";
                    this.id = id;
                },
                StringNode: function(string, locInfo) {
                    LocationInfo.call(this, locInfo);
                    this.type = "STRING";
                    this.original = this.string = this.stringModeValue = string;
                },
                IntegerNode: function(integer, locInfo) {
                    LocationInfo.call(this, locInfo);
                    this.type = "INTEGER";
                    this.original = this.integer = integer;
                    this.stringModeValue = Number(integer);
                },
                BooleanNode: function(bool, locInfo) {
                    LocationInfo.call(this, locInfo);
                    this.type = "BOOLEAN";
                    this.bool = bool;
                    this.stringModeValue = bool === "true";
                },
                CommentNode: function(comment, locInfo) {
                    LocationInfo.call(this, locInfo);
                    this.type = "comment";
                    this.comment = comment;
                }
            };
            // Must be exported as an object rather than the root of the module as the jison lexer
            // most modify the object to operate properly.
            __exports__ = AST;
            return __exports__;
        }(__module5__);
        // handlebars/compiler/parser.js
        var __module9__ = function() {
            "use strict";
            var __exports__;
            /* jshint ignore:start */
            /* Jison generated parser */
            var handlebars = function() {
                var parser = {
                    trace: function trace() {},
                    yy: {},
                    symbols_: {
                        error: 2,
                        root: 3,
                        statements: 4,
                        EOF: 5,
                        program: 6,
                        simpleInverse: 7,
                        statement: 8,
                        openInverse: 9,
                        closeBlock: 10,
                        openBlock: 11,
                        mustache: 12,
                        partial: 13,
                        CONTENT: 14,
                        COMMENT: 15,
                        OPEN_BLOCK: 16,
                        sexpr: 17,
                        CLOSE: 18,
                        OPEN_INVERSE: 19,
                        OPEN_ENDBLOCK: 20,
                        path: 21,
                        OPEN: 22,
                        OPEN_UNESCAPED: 23,
                        CLOSE_UNESCAPED: 24,
                        OPEN_PARTIAL: 25,
                        partialName: 26,
                        partial_option0: 27,
                        sexpr_repetition0: 28,
                        sexpr_option0: 29,
                        dataName: 30,
                        param: 31,
                        STRING: 32,
                        INTEGER: 33,
                        BOOLEAN: 34,
                        OPEN_SEXPR: 35,
                        CLOSE_SEXPR: 36,
                        hash: 37,
                        hash_repetition_plus0: 38,
                        hashSegment: 39,
                        ID: 40,
                        EQUALS: 41,
                        DATA: 42,
                        pathSegments: 43,
                        SEP: 44,
                        $accept: 0,
                        $end: 1
                    },
                    terminals_: {
                        2: "error",
                        5: "EOF",
                        14: "CONTENT",
                        15: "COMMENT",
                        16: "OPEN_BLOCK",
                        18: "CLOSE",
                        19: "OPEN_INVERSE",
                        20: "OPEN_ENDBLOCK",
                        22: "OPEN",
                        23: "OPEN_UNESCAPED",
                        24: "CLOSE_UNESCAPED",
                        25: "OPEN_PARTIAL",
                        32: "STRING",
                        33: "INTEGER",
                        34: "BOOLEAN",
                        35: "OPEN_SEXPR",
                        36: "CLOSE_SEXPR",
                        40: "ID",
                        41: "EQUALS",
                        42: "DATA",
                        44: "SEP"
                    },
                    productions_: [ 0, [ 3, 2 ], [ 3, 1 ], [ 6, 2 ], [ 6, 3 ], [ 6, 2 ], [ 6, 1 ], [ 6, 1 ], [ 6, 0 ], [ 4, 1 ], [ 4, 2 ], [ 8, 3 ], [ 8, 3 ], [ 8, 1 ], [ 8, 1 ], [ 8, 1 ], [ 8, 1 ], [ 11, 3 ], [ 9, 3 ], [ 10, 3 ], [ 12, 3 ], [ 12, 3 ], [ 13, 4 ], [ 7, 2 ], [ 17, 3 ], [ 17, 1 ], [ 31, 1 ], [ 31, 1 ], [ 31, 1 ], [ 31, 1 ], [ 31, 1 ], [ 31, 3 ], [ 37, 1 ], [ 39, 3 ], [ 26, 1 ], [ 26, 1 ], [ 26, 1 ], [ 30, 2 ], [ 21, 1 ], [ 43, 3 ], [ 43, 1 ], [ 27, 0 ], [ 27, 1 ], [ 28, 0 ], [ 28, 2 ], [ 29, 0 ], [ 29, 1 ], [ 38, 1 ], [ 38, 2 ] ],
                    performAction: function anonymous(yytext, yyleng, yylineno, yy, yystate, $$, _$) {
                        var $0 = $$.length - 1;
                        switch (yystate) {
                          case 1:
                            return new yy.ProgramNode($$[$0 - 1], this._$);
                            break;

                          case 2:
                            return new yy.ProgramNode([], this._$);
                            break;

                          case 3:
                            this.$ = new yy.ProgramNode([], $$[$0 - 1], $$[$0], this._$);
                            break;

                          case 4:
                            this.$ = new yy.ProgramNode($$[$0 - 2], $$[$0 - 1], $$[$0], this._$);
                            break;

                          case 5:
                            this.$ = new yy.ProgramNode($$[$0 - 1], $$[$0], [], this._$);
                            break;

                          case 6:
                            this.$ = new yy.ProgramNode($$[$0], this._$);
                            break;

                          case 7:
                            this.$ = new yy.ProgramNode([], this._$);
                            break;

                          case 8:
                            this.$ = new yy.ProgramNode([], this._$);
                            break;

                          case 9:
                            this.$ = [ $$[$0] ];
                            break;

                          case 10:
                            $$[$0 - 1].push($$[$0]);
                            this.$ = $$[$0 - 1];
                            break;

                          case 11:
                            this.$ = new yy.BlockNode($$[$0 - 2], $$[$0 - 1].inverse, $$[$0 - 1], $$[$0], this._$);
                            break;

                          case 12:
                            this.$ = new yy.BlockNode($$[$0 - 2], $$[$0 - 1], $$[$0 - 1].inverse, $$[$0], this._$);
                            break;

                          case 13:
                            this.$ = $$[$0];
                            break;

                          case 14:
                            this.$ = $$[$0];
                            break;

                          case 15:
                            this.$ = new yy.ContentNode($$[$0], this._$);
                            break;

                          case 16:
                            this.$ = new yy.CommentNode($$[$0], this._$);
                            break;

                          case 17:
                            this.$ = new yy.MustacheNode($$[$0 - 1], null, $$[$0 - 2], stripFlags($$[$0 - 2], $$[$0]), this._$);
                            break;

                          case 18:
                            this.$ = new yy.MustacheNode($$[$0 - 1], null, $$[$0 - 2], stripFlags($$[$0 - 2], $$[$0]), this._$);
                            break;

                          case 19:
                            this.$ = {
                                path: $$[$0 - 1],
                                strip: stripFlags($$[$0 - 2], $$[$0])
                            };
                            break;

                          case 20:
                            this.$ = new yy.MustacheNode($$[$0 - 1], null, $$[$0 - 2], stripFlags($$[$0 - 2], $$[$0]), this._$);
                            break;

                          case 21:
                            this.$ = new yy.MustacheNode($$[$0 - 1], null, $$[$0 - 2], stripFlags($$[$0 - 2], $$[$0]), this._$);
                            break;

                          case 22:
                            this.$ = new yy.PartialNode($$[$0 - 2], $$[$0 - 1], stripFlags($$[$0 - 3], $$[$0]), this._$);
                            break;

                          case 23:
                            this.$ = stripFlags($$[$0 - 1], $$[$0]);
                            break;

                          case 24:
                            this.$ = new yy.SexprNode([ $$[$0 - 2] ].concat($$[$0 - 1]), $$[$0], this._$);
                            break;

                          case 25:
                            this.$ = new yy.SexprNode([ $$[$0] ], null, this._$);
                            break;

                          case 26:
                            this.$ = $$[$0];
                            break;

                          case 27:
                            this.$ = new yy.StringNode($$[$0], this._$);
                            break;

                          case 28:
                            this.$ = new yy.IntegerNode($$[$0], this._$);
                            break;

                          case 29:
                            this.$ = new yy.BooleanNode($$[$0], this._$);
                            break;

                          case 30:
                            this.$ = $$[$0];
                            break;

                          case 31:
                            $$[$0 - 1].isHelper = true;
                            this.$ = $$[$0 - 1];
                            break;

                          case 32:
                            this.$ = new yy.HashNode($$[$0], this._$);
                            break;

                          case 33:
                            this.$ = [ $$[$0 - 2], $$[$0] ];
                            break;

                          case 34:
                            this.$ = new yy.PartialNameNode($$[$0], this._$);
                            break;

                          case 35:
                            this.$ = new yy.PartialNameNode(new yy.StringNode($$[$0], this._$), this._$);
                            break;

                          case 36:
                            this.$ = new yy.PartialNameNode(new yy.IntegerNode($$[$0], this._$));
                            break;

                          case 37:
                            this.$ = new yy.DataNode($$[$0], this._$);
                            break;

                          case 38:
                            this.$ = new yy.IdNode($$[$0], this._$);
                            break;

                          case 39:
                            $$[$0 - 2].push({
                                part: $$[$0],
                                separator: $$[$0 - 1]
                            });
                            this.$ = $$[$0 - 2];
                            break;

                          case 40:
                            this.$ = [ {
                                part: $$[$0]
                            } ];
                            break;

                          case 43:
                            this.$ = [];
                            break;

                          case 44:
                            $$[$0 - 1].push($$[$0]);
                            break;

                          case 47:
                            this.$ = [ $$[$0] ];
                            break;

                          case 48:
                            $$[$0 - 1].push($$[$0]);
                            break;
                        }
                    },
                    table: [ {
                        3: 1,
                        4: 2,
                        5: [ 1, 3 ],
                        8: 4,
                        9: 5,
                        11: 6,
                        12: 7,
                        13: 8,
                        14: [ 1, 9 ],
                        15: [ 1, 10 ],
                        16: [ 1, 12 ],
                        19: [ 1, 11 ],
                        22: [ 1, 13 ],
                        23: [ 1, 14 ],
                        25: [ 1, 15 ]
                    }, {
                        1: [ 3 ]
                    }, {
                        5: [ 1, 16 ],
                        8: 17,
                        9: 5,
                        11: 6,
                        12: 7,
                        13: 8,
                        14: [ 1, 9 ],
                        15: [ 1, 10 ],
                        16: [ 1, 12 ],
                        19: [ 1, 11 ],
                        22: [ 1, 13 ],
                        23: [ 1, 14 ],
                        25: [ 1, 15 ]
                    }, {
                        1: [ 2, 2 ]
                    }, {
                        5: [ 2, 9 ],
                        14: [ 2, 9 ],
                        15: [ 2, 9 ],
                        16: [ 2, 9 ],
                        19: [ 2, 9 ],
                        20: [ 2, 9 ],
                        22: [ 2, 9 ],
                        23: [ 2, 9 ],
                        25: [ 2, 9 ]
                    }, {
                        4: 20,
                        6: 18,
                        7: 19,
                        8: 4,
                        9: 5,
                        11: 6,
                        12: 7,
                        13: 8,
                        14: [ 1, 9 ],
                        15: [ 1, 10 ],
                        16: [ 1, 12 ],
                        19: [ 1, 21 ],
                        20: [ 2, 8 ],
                        22: [ 1, 13 ],
                        23: [ 1, 14 ],
                        25: [ 1, 15 ]
                    }, {
                        4: 20,
                        6: 22,
                        7: 19,
                        8: 4,
                        9: 5,
                        11: 6,
                        12: 7,
                        13: 8,
                        14: [ 1, 9 ],
                        15: [ 1, 10 ],
                        16: [ 1, 12 ],
                        19: [ 1, 21 ],
                        20: [ 2, 8 ],
                        22: [ 1, 13 ],
                        23: [ 1, 14 ],
                        25: [ 1, 15 ]
                    }, {
                        5: [ 2, 13 ],
                        14: [ 2, 13 ],
                        15: [ 2, 13 ],
                        16: [ 2, 13 ],
                        19: [ 2, 13 ],
                        20: [ 2, 13 ],
                        22: [ 2, 13 ],
                        23: [ 2, 13 ],
                        25: [ 2, 13 ]
                    }, {
                        5: [ 2, 14 ],
                        14: [ 2, 14 ],
                        15: [ 2, 14 ],
                        16: [ 2, 14 ],
                        19: [ 2, 14 ],
                        20: [ 2, 14 ],
                        22: [ 2, 14 ],
                        23: [ 2, 14 ],
                        25: [ 2, 14 ]
                    }, {
                        5: [ 2, 15 ],
                        14: [ 2, 15 ],
                        15: [ 2, 15 ],
                        16: [ 2, 15 ],
                        19: [ 2, 15 ],
                        20: [ 2, 15 ],
                        22: [ 2, 15 ],
                        23: [ 2, 15 ],
                        25: [ 2, 15 ]
                    }, {
                        5: [ 2, 16 ],
                        14: [ 2, 16 ],
                        15: [ 2, 16 ],
                        16: [ 2, 16 ],
                        19: [ 2, 16 ],
                        20: [ 2, 16 ],
                        22: [ 2, 16 ],
                        23: [ 2, 16 ],
                        25: [ 2, 16 ]
                    }, {
                        17: 23,
                        21: 24,
                        30: 25,
                        40: [ 1, 28 ],
                        42: [ 1, 27 ],
                        43: 26
                    }, {
                        17: 29,
                        21: 24,
                        30: 25,
                        40: [ 1, 28 ],
                        42: [ 1, 27 ],
                        43: 26
                    }, {
                        17: 30,
                        21: 24,
                        30: 25,
                        40: [ 1, 28 ],
                        42: [ 1, 27 ],
                        43: 26
                    }, {
                        17: 31,
                        21: 24,
                        30: 25,
                        40: [ 1, 28 ],
                        42: [ 1, 27 ],
                        43: 26
                    }, {
                        21: 33,
                        26: 32,
                        32: [ 1, 34 ],
                        33: [ 1, 35 ],
                        40: [ 1, 28 ],
                        43: 26
                    }, {
                        1: [ 2, 1 ]
                    }, {
                        5: [ 2, 10 ],
                        14: [ 2, 10 ],
                        15: [ 2, 10 ],
                        16: [ 2, 10 ],
                        19: [ 2, 10 ],
                        20: [ 2, 10 ],
                        22: [ 2, 10 ],
                        23: [ 2, 10 ],
                        25: [ 2, 10 ]
                    }, {
                        10: 36,
                        20: [ 1, 37 ]
                    }, {
                        4: 38,
                        8: 4,
                        9: 5,
                        11: 6,
                        12: 7,
                        13: 8,
                        14: [ 1, 9 ],
                        15: [ 1, 10 ],
                        16: [ 1, 12 ],
                        19: [ 1, 11 ],
                        20: [ 2, 7 ],
                        22: [ 1, 13 ],
                        23: [ 1, 14 ],
                        25: [ 1, 15 ]
                    }, {
                        7: 39,
                        8: 17,
                        9: 5,
                        11: 6,
                        12: 7,
                        13: 8,
                        14: [ 1, 9 ],
                        15: [ 1, 10 ],
                        16: [ 1, 12 ],
                        19: [ 1, 21 ],
                        20: [ 2, 6 ],
                        22: [ 1, 13 ],
                        23: [ 1, 14 ],
                        25: [ 1, 15 ]
                    }, {
                        17: 23,
                        18: [ 1, 40 ],
                        21: 24,
                        30: 25,
                        40: [ 1, 28 ],
                        42: [ 1, 27 ],
                        43: 26
                    }, {
                        10: 41,
                        20: [ 1, 37 ]
                    }, {
                        18: [ 1, 42 ]
                    }, {
                        18: [ 2, 43 ],
                        24: [ 2, 43 ],
                        28: 43,
                        32: [ 2, 43 ],
                        33: [ 2, 43 ],
                        34: [ 2, 43 ],
                        35: [ 2, 43 ],
                        36: [ 2, 43 ],
                        40: [ 2, 43 ],
                        42: [ 2, 43 ]
                    }, {
                        18: [ 2, 25 ],
                        24: [ 2, 25 ],
                        36: [ 2, 25 ]
                    }, {
                        18: [ 2, 38 ],
                        24: [ 2, 38 ],
                        32: [ 2, 38 ],
                        33: [ 2, 38 ],
                        34: [ 2, 38 ],
                        35: [ 2, 38 ],
                        36: [ 2, 38 ],
                        40: [ 2, 38 ],
                        42: [ 2, 38 ],
                        44: [ 1, 44 ]
                    }, {
                        21: 45,
                        40: [ 1, 28 ],
                        43: 26
                    }, {
                        18: [ 2, 40 ],
                        24: [ 2, 40 ],
                        32: [ 2, 40 ],
                        33: [ 2, 40 ],
                        34: [ 2, 40 ],
                        35: [ 2, 40 ],
                        36: [ 2, 40 ],
                        40: [ 2, 40 ],
                        42: [ 2, 40 ],
                        44: [ 2, 40 ]
                    }, {
                        18: [ 1, 46 ]
                    }, {
                        18: [ 1, 47 ]
                    }, {
                        24: [ 1, 48 ]
                    }, {
                        18: [ 2, 41 ],
                        21: 50,
                        27: 49,
                        40: [ 1, 28 ],
                        43: 26
                    }, {
                        18: [ 2, 34 ],
                        40: [ 2, 34 ]
                    }, {
                        18: [ 2, 35 ],
                        40: [ 2, 35 ]
                    }, {
                        18: [ 2, 36 ],
                        40: [ 2, 36 ]
                    }, {
                        5: [ 2, 11 ],
                        14: [ 2, 11 ],
                        15: [ 2, 11 ],
                        16: [ 2, 11 ],
                        19: [ 2, 11 ],
                        20: [ 2, 11 ],
                        22: [ 2, 11 ],
                        23: [ 2, 11 ],
                        25: [ 2, 11 ]
                    }, {
                        21: 51,
                        40: [ 1, 28 ],
                        43: 26
                    }, {
                        8: 17,
                        9: 5,
                        11: 6,
                        12: 7,
                        13: 8,
                        14: [ 1, 9 ],
                        15: [ 1, 10 ],
                        16: [ 1, 12 ],
                        19: [ 1, 11 ],
                        20: [ 2, 3 ],
                        22: [ 1, 13 ],
                        23: [ 1, 14 ],
                        25: [ 1, 15 ]
                    }, {
                        4: 52,
                        8: 4,
                        9: 5,
                        11: 6,
                        12: 7,
                        13: 8,
                        14: [ 1, 9 ],
                        15: [ 1, 10 ],
                        16: [ 1, 12 ],
                        19: [ 1, 11 ],
                        20: [ 2, 5 ],
                        22: [ 1, 13 ],
                        23: [ 1, 14 ],
                        25: [ 1, 15 ]
                    }, {
                        14: [ 2, 23 ],
                        15: [ 2, 23 ],
                        16: [ 2, 23 ],
                        19: [ 2, 23 ],
                        20: [ 2, 23 ],
                        22: [ 2, 23 ],
                        23: [ 2, 23 ],
                        25: [ 2, 23 ]
                    }, {
                        5: [ 2, 12 ],
                        14: [ 2, 12 ],
                        15: [ 2, 12 ],
                        16: [ 2, 12 ],
                        19: [ 2, 12 ],
                        20: [ 2, 12 ],
                        22: [ 2, 12 ],
                        23: [ 2, 12 ],
                        25: [ 2, 12 ]
                    }, {
                        14: [ 2, 18 ],
                        15: [ 2, 18 ],
                        16: [ 2, 18 ],
                        19: [ 2, 18 ],
                        20: [ 2, 18 ],
                        22: [ 2, 18 ],
                        23: [ 2, 18 ],
                        25: [ 2, 18 ]
                    }, {
                        18: [ 2, 45 ],
                        21: 56,
                        24: [ 2, 45 ],
                        29: 53,
                        30: 60,
                        31: 54,
                        32: [ 1, 57 ],
                        33: [ 1, 58 ],
                        34: [ 1, 59 ],
                        35: [ 1, 61 ],
                        36: [ 2, 45 ],
                        37: 55,
                        38: 62,
                        39: 63,
                        40: [ 1, 64 ],
                        42: [ 1, 27 ],
                        43: 26
                    }, {
                        40: [ 1, 65 ]
                    }, {
                        18: [ 2, 37 ],
                        24: [ 2, 37 ],
                        32: [ 2, 37 ],
                        33: [ 2, 37 ],
                        34: [ 2, 37 ],
                        35: [ 2, 37 ],
                        36: [ 2, 37 ],
                        40: [ 2, 37 ],
                        42: [ 2, 37 ]
                    }, {
                        14: [ 2, 17 ],
                        15: [ 2, 17 ],
                        16: [ 2, 17 ],
                        19: [ 2, 17 ],
                        20: [ 2, 17 ],
                        22: [ 2, 17 ],
                        23: [ 2, 17 ],
                        25: [ 2, 17 ]
                    }, {
                        5: [ 2, 20 ],
                        14: [ 2, 20 ],
                        15: [ 2, 20 ],
                        16: [ 2, 20 ],
                        19: [ 2, 20 ],
                        20: [ 2, 20 ],
                        22: [ 2, 20 ],
                        23: [ 2, 20 ],
                        25: [ 2, 20 ]
                    }, {
                        5: [ 2, 21 ],
                        14: [ 2, 21 ],
                        15: [ 2, 21 ],
                        16: [ 2, 21 ],
                        19: [ 2, 21 ],
                        20: [ 2, 21 ],
                        22: [ 2, 21 ],
                        23: [ 2, 21 ],
                        25: [ 2, 21 ]
                    }, {
                        18: [ 1, 66 ]
                    }, {
                        18: [ 2, 42 ]
                    }, {
                        18: [ 1, 67 ]
                    }, {
                        8: 17,
                        9: 5,
                        11: 6,
                        12: 7,
                        13: 8,
                        14: [ 1, 9 ],
                        15: [ 1, 10 ],
                        16: [ 1, 12 ],
                        19: [ 1, 11 ],
                        20: [ 2, 4 ],
                        22: [ 1, 13 ],
                        23: [ 1, 14 ],
                        25: [ 1, 15 ]
                    }, {
                        18: [ 2, 24 ],
                        24: [ 2, 24 ],
                        36: [ 2, 24 ]
                    }, {
                        18: [ 2, 44 ],
                        24: [ 2, 44 ],
                        32: [ 2, 44 ],
                        33: [ 2, 44 ],
                        34: [ 2, 44 ],
                        35: [ 2, 44 ],
                        36: [ 2, 44 ],
                        40: [ 2, 44 ],
                        42: [ 2, 44 ]
                    }, {
                        18: [ 2, 46 ],
                        24: [ 2, 46 ],
                        36: [ 2, 46 ]
                    }, {
                        18: [ 2, 26 ],
                        24: [ 2, 26 ],
                        32: [ 2, 26 ],
                        33: [ 2, 26 ],
                        34: [ 2, 26 ],
                        35: [ 2, 26 ],
                        36: [ 2, 26 ],
                        40: [ 2, 26 ],
                        42: [ 2, 26 ]
                    }, {
                        18: [ 2, 27 ],
                        24: [ 2, 27 ],
                        32: [ 2, 27 ],
                        33: [ 2, 27 ],
                        34: [ 2, 27 ],
                        35: [ 2, 27 ],
                        36: [ 2, 27 ],
                        40: [ 2, 27 ],
                        42: [ 2, 27 ]
                    }, {
                        18: [ 2, 28 ],
                        24: [ 2, 28 ],
                        32: [ 2, 28 ],
                        33: [ 2, 28 ],
                        34: [ 2, 28 ],
                        35: [ 2, 28 ],
                        36: [ 2, 28 ],
                        40: [ 2, 28 ],
                        42: [ 2, 28 ]
                    }, {
                        18: [ 2, 29 ],
                        24: [ 2, 29 ],
                        32: [ 2, 29 ],
                        33: [ 2, 29 ],
                        34: [ 2, 29 ],
                        35: [ 2, 29 ],
                        36: [ 2, 29 ],
                        40: [ 2, 29 ],
                        42: [ 2, 29 ]
                    }, {
                        18: [ 2, 30 ],
                        24: [ 2, 30 ],
                        32: [ 2, 30 ],
                        33: [ 2, 30 ],
                        34: [ 2, 30 ],
                        35: [ 2, 30 ],
                        36: [ 2, 30 ],
                        40: [ 2, 30 ],
                        42: [ 2, 30 ]
                    }, {
                        17: 68,
                        21: 24,
                        30: 25,
                        40: [ 1, 28 ],
                        42: [ 1, 27 ],
                        43: 26
                    }, {
                        18: [ 2, 32 ],
                        24: [ 2, 32 ],
                        36: [ 2, 32 ],
                        39: 69,
                        40: [ 1, 70 ]
                    }, {
                        18: [ 2, 47 ],
                        24: [ 2, 47 ],
                        36: [ 2, 47 ],
                        40: [ 2, 47 ]
                    }, {
                        18: [ 2, 40 ],
                        24: [ 2, 40 ],
                        32: [ 2, 40 ],
                        33: [ 2, 40 ],
                        34: [ 2, 40 ],
                        35: [ 2, 40 ],
                        36: [ 2, 40 ],
                        40: [ 2, 40 ],
                        41: [ 1, 71 ],
                        42: [ 2, 40 ],
                        44: [ 2, 40 ]
                    }, {
                        18: [ 2, 39 ],
                        24: [ 2, 39 ],
                        32: [ 2, 39 ],
                        33: [ 2, 39 ],
                        34: [ 2, 39 ],
                        35: [ 2, 39 ],
                        36: [ 2, 39 ],
                        40: [ 2, 39 ],
                        42: [ 2, 39 ],
                        44: [ 2, 39 ]
                    }, {
                        5: [ 2, 22 ],
                        14: [ 2, 22 ],
                        15: [ 2, 22 ],
                        16: [ 2, 22 ],
                        19: [ 2, 22 ],
                        20: [ 2, 22 ],
                        22: [ 2, 22 ],
                        23: [ 2, 22 ],
                        25: [ 2, 22 ]
                    }, {
                        5: [ 2, 19 ],
                        14: [ 2, 19 ],
                        15: [ 2, 19 ],
                        16: [ 2, 19 ],
                        19: [ 2, 19 ],
                        20: [ 2, 19 ],
                        22: [ 2, 19 ],
                        23: [ 2, 19 ],
                        25: [ 2, 19 ]
                    }, {
                        36: [ 1, 72 ]
                    }, {
                        18: [ 2, 48 ],
                        24: [ 2, 48 ],
                        36: [ 2, 48 ],
                        40: [ 2, 48 ]
                    }, {
                        41: [ 1, 71 ]
                    }, {
                        21: 56,
                        30: 60,
                        31: 73,
                        32: [ 1, 57 ],
                        33: [ 1, 58 ],
                        34: [ 1, 59 ],
                        35: [ 1, 61 ],
                        40: [ 1, 28 ],
                        42: [ 1, 27 ],
                        43: 26
                    }, {
                        18: [ 2, 31 ],
                        24: [ 2, 31 ],
                        32: [ 2, 31 ],
                        33: [ 2, 31 ],
                        34: [ 2, 31 ],
                        35: [ 2, 31 ],
                        36: [ 2, 31 ],
                        40: [ 2, 31 ],
                        42: [ 2, 31 ]
                    }, {
                        18: [ 2, 33 ],
                        24: [ 2, 33 ],
                        36: [ 2, 33 ],
                        40: [ 2, 33 ]
                    } ],
                    defaultActions: {
                        3: [ 2, 2 ],
                        16: [ 2, 1 ],
                        50: [ 2, 42 ]
                    },
                    parseError: function parseError(str, hash) {
                        throw new Error(str);
                    },
                    parse: function parse(input) {
                        var self = this, stack = [ 0 ], vstack = [ null ], lstack = [], table = this.table, yytext = "", yylineno = 0, yyleng = 0, recovering = 0, TERROR = 2, EOF = 1;
                        this.lexer.setInput(input);
                        this.lexer.yy = this.yy;
                        this.yy.lexer = this.lexer;
                        this.yy.parser = this;
                        if (typeof this.lexer.yylloc == "undefined") this.lexer.yylloc = {};
                        var yyloc = this.lexer.yylloc;
                        lstack.push(yyloc);
                        var ranges = this.lexer.options && this.lexer.options.ranges;
                        if (typeof this.yy.parseError === "function") this.parseError = this.yy.parseError;
                        function popStack(n) {
                            stack.length = stack.length - 2 * n;
                            vstack.length = vstack.length - n;
                            lstack.length = lstack.length - n;
                        }
                        function lex() {
                            var token;
                            token = self.lexer.lex() || 1;
                            if (typeof token !== "number") {
                                token = self.symbols_[token] || token;
                            }
                            return token;
                        }
                        var symbol, preErrorSymbol, state, action, a, r, yyval = {}, p, len, newState, expected;
                        while (true) {
                            state = stack[stack.length - 1];
                            if (this.defaultActions[state]) {
                                action = this.defaultActions[state];
                            } else {
                                if (symbol === null || typeof symbol == "undefined") {
                                    symbol = lex();
                                }
                                action = table[state] && table[state][symbol];
                            }
                            if (typeof action === "undefined" || !action.length || !action[0]) {
                                var errStr = "";
                                if (!recovering) {
                                    expected = [];
                                    for (p in table[state]) if (this.terminals_[p] && p > 2) {
                                        expected.push("'" + this.terminals_[p] + "'");
                                    }
                                    if (this.lexer.showPosition) {
                                        errStr = "Parse error on line " + (yylineno + 1) + ":\n" + this.lexer.showPosition() + "\nExpecting " + expected.join(", ") + ", got '" + (this.terminals_[symbol] || symbol) + "'";
                                    } else {
                                        errStr = "Parse error on line " + (yylineno + 1) + ": Unexpected " + (symbol == 1 ? "end of input" : "'" + (this.terminals_[symbol] || symbol) + "'");
                                    }
                                    this.parseError(errStr, {
                                        text: this.lexer.match,
                                        token: this.terminals_[symbol] || symbol,
                                        line: this.lexer.yylineno,
                                        loc: yyloc,
                                        expected: expected
                                    });
                                }
                            }
                            if (action[0] instanceof Array && action.length > 1) {
                                throw new Error("Parse Error: multiple actions possible at state: " + state + ", token: " + symbol);
                            }
                            switch (action[0]) {
                              case 1:
                                stack.push(symbol);
                                vstack.push(this.lexer.yytext);
                                lstack.push(this.lexer.yylloc);
                                stack.push(action[1]);
                                symbol = null;
                                if (!preErrorSymbol) {
                                    yyleng = this.lexer.yyleng;
                                    yytext = this.lexer.yytext;
                                    yylineno = this.lexer.yylineno;
                                    yyloc = this.lexer.yylloc;
                                    if (recovering > 0) recovering--;
                                } else {
                                    symbol = preErrorSymbol;
                                    preErrorSymbol = null;
                                }
                                break;

                              case 2:
                                len = this.productions_[action[1]][1];
                                yyval.$ = vstack[vstack.length - len];
                                yyval._$ = {
                                    first_line: lstack[lstack.length - (len || 1)].first_line,
                                    last_line: lstack[lstack.length - 1].last_line,
                                    first_column: lstack[lstack.length - (len || 1)].first_column,
                                    last_column: lstack[lstack.length - 1].last_column
                                };
                                if (ranges) {
                                    yyval._$.range = [ lstack[lstack.length - (len || 1)].range[0], lstack[lstack.length - 1].range[1] ];
                                }
                                r = this.performAction.call(yyval, yytext, yyleng, yylineno, this.yy, action[1], vstack, lstack);
                                if (typeof r !== "undefined") {
                                    return r;
                                }
                                if (len) {
                                    stack = stack.slice(0, -1 * len * 2);
                                    vstack = vstack.slice(0, -1 * len);
                                    lstack = lstack.slice(0, -1 * len);
                                }
                                stack.push(this.productions_[action[1]][0]);
                                vstack.push(yyval.$);
                                lstack.push(yyval._$);
                                newState = table[stack[stack.length - 2]][stack[stack.length - 1]];
                                stack.push(newState);
                                break;

                              case 3:
                                return true;
                            }
                        }
                        return true;
                    }
                };
                function stripFlags(open, close) {
                    return {
                        left: open.charAt(2) === "~",
                        right: close.charAt(0) === "~" || close.charAt(1) === "~"
                    };
                }
                /* Jison generated lexer */
                var lexer = function() {
                    var lexer = {
                        EOF: 1,
                        parseError: function parseError(str, hash) {
                            if (this.yy.parser) {
                                this.yy.parser.parseError(str, hash);
                            } else {
                                throw new Error(str);
                            }
                        },
                        setInput: function(input) {
                            this._input = input;
                            this._more = this._less = this.done = false;
                            this.yylineno = this.yyleng = 0;
                            this.yytext = this.matched = this.match = "";
                            this.conditionStack = [ "INITIAL" ];
                            this.yylloc = {
                                first_line: 1,
                                first_column: 0,
                                last_line: 1,
                                last_column: 0
                            };
                            if (this.options.ranges) this.yylloc.range = [ 0, 0 ];
                            this.offset = 0;
                            return this;
                        },
                        input: function() {
                            var ch = this._input[0];
                            this.yytext += ch;
                            this.yyleng++;
                            this.offset++;
                            this.match += ch;
                            this.matched += ch;
                            var lines = ch.match(/(?:\r\n?|\n).*/g);
                            if (lines) {
                                this.yylineno++;
                                this.yylloc.last_line++;
                            } else {
                                this.yylloc.last_column++;
                            }
                            if (this.options.ranges) this.yylloc.range[1]++;
                            this._input = this._input.slice(1);
                            return ch;
                        },
                        unput: function(ch) {
                            var len = ch.length;
                            var lines = ch.split(/(?:\r\n?|\n)/g);
                            this._input = ch + this._input;
                            this.yytext = this.yytext.substr(0, this.yytext.length - len - 1);
                            //this.yyleng -= len;
                            this.offset -= len;
                            var oldLines = this.match.split(/(?:\r\n?|\n)/g);
                            this.match = this.match.substr(0, this.match.length - 1);
                            this.matched = this.matched.substr(0, this.matched.length - 1);
                            if (lines.length - 1) this.yylineno -= lines.length - 1;
                            var r = this.yylloc.range;
                            this.yylloc = {
                                first_line: this.yylloc.first_line,
                                last_line: this.yylineno + 1,
                                first_column: this.yylloc.first_column,
                                last_column: lines ? (lines.length === oldLines.length ? this.yylloc.first_column : 0) + oldLines[oldLines.length - lines.length].length - lines[0].length : this.yylloc.first_column - len
                            };
                            if (this.options.ranges) {
                                this.yylloc.range = [ r[0], r[0] + this.yyleng - len ];
                            }
                            return this;
                        },
                        more: function() {
                            this._more = true;
                            return this;
                        },
                        less: function(n) {
                            this.unput(this.match.slice(n));
                        },
                        pastInput: function() {
                            var past = this.matched.substr(0, this.matched.length - this.match.length);
                            return (past.length > 20 ? "..." : "") + past.substr(-20).replace(/\n/g, "");
                        },
                        upcomingInput: function() {
                            var next = this.match;
                            if (next.length < 20) {
                                next += this._input.substr(0, 20 - next.length);
                            }
                            return (next.substr(0, 20) + (next.length > 20 ? "..." : "")).replace(/\n/g, "");
                        },
                        showPosition: function() {
                            var pre = this.pastInput();
                            var c = new Array(pre.length + 1).join("-");
                            return pre + this.upcomingInput() + "\n" + c + "^";
                        },
                        next: function() {
                            if (this.done) {
                                return this.EOF;
                            }
                            if (!this._input) this.done = true;
                            var token, match, tempMatch, index, col, lines;
                            if (!this._more) {
                                this.yytext = "";
                                this.match = "";
                            }
                            var rules = this._currentRules();
                            for (var i = 0; i < rules.length; i++) {
                                tempMatch = this._input.match(this.rules[rules[i]]);
                                if (tempMatch && (!match || tempMatch[0].length > match[0].length)) {
                                    match = tempMatch;
                                    index = i;
                                    if (!this.options.flex) break;
                                }
                            }
                            if (match) {
                                lines = match[0].match(/(?:\r\n?|\n).*/g);
                                if (lines) this.yylineno += lines.length;
                                this.yylloc = {
                                    first_line: this.yylloc.last_line,
                                    last_line: this.yylineno + 1,
                                    first_column: this.yylloc.last_column,
                                    last_column: lines ? lines[lines.length - 1].length - lines[lines.length - 1].match(/\r?\n?/)[0].length : this.yylloc.last_column + match[0].length
                                };
                                this.yytext += match[0];
                                this.match += match[0];
                                this.matches = match;
                                this.yyleng = this.yytext.length;
                                if (this.options.ranges) {
                                    this.yylloc.range = [ this.offset, this.offset += this.yyleng ];
                                }
                                this._more = false;
                                this._input = this._input.slice(match[0].length);
                                this.matched += match[0];
                                token = this.performAction.call(this, this.yy, this, rules[index], this.conditionStack[this.conditionStack.length - 1]);
                                if (this.done && this._input) this.done = false;
                                if (token) return token; else return;
                            }
                            if (this._input === "") {
                                return this.EOF;
                            } else {
                                return this.parseError("Lexical error on line " + (this.yylineno + 1) + ". Unrecognized text.\n" + this.showPosition(), {
                                    text: "",
                                    token: null,
                                    line: this.yylineno
                                });
                            }
                        },
                        lex: function lex() {
                            var r = this.next();
                            if (typeof r !== "undefined") {
                                return r;
                            } else {
                                return this.lex();
                            }
                        },
                        begin: function begin(condition) {
                            this.conditionStack.push(condition);
                        },
                        popState: function popState() {
                            return this.conditionStack.pop();
                        },
                        _currentRules: function _currentRules() {
                            return this.conditions[this.conditionStack[this.conditionStack.length - 1]].rules;
                        },
                        topState: function() {
                            return this.conditionStack[this.conditionStack.length - 2];
                        },
                        pushState: function begin(condition) {
                            this.begin(condition);
                        }
                    };
                    lexer.options = {};
                    lexer.performAction = function anonymous(yy, yy_, $avoiding_name_collisions, YY_START) {
                        function strip(start, end) {
                            return yy_.yytext = yy_.yytext.substr(start, yy_.yyleng - end);
                        }
                        var YYSTATE = YY_START;
                        switch ($avoiding_name_collisions) {
                          case 0:
                            if (yy_.yytext.slice(-2) === "\\\\") {
                                strip(0, 1);
                                this.begin("mu");
                            } else if (yy_.yytext.slice(-1) === "\\") {
                                strip(0, 1);
                                this.begin("emu");
                            } else {
                                this.begin("mu");
                            }
                            if (yy_.yytext) return 14;
                            break;

                          case 1:
                            return 14;
                            break;

                          case 2:
                            this.popState();
                            return 14;
                            break;

                          case 3:
                            strip(0, 4);
                            this.popState();
                            return 15;
                            break;

                          case 4:
                            return 35;
                            break;

                          case 5:
                            return 36;
                            break;

                          case 6:
                            return 25;
                            break;

                          case 7:
                            return 16;
                            break;

                          case 8:
                            return 20;
                            break;

                          case 9:
                            return 19;
                            break;

                          case 10:
                            return 19;
                            break;

                          case 11:
                            return 23;
                            break;

                          case 12:
                            return 22;
                            break;

                          case 13:
                            this.popState();
                            this.begin("com");
                            break;

                          case 14:
                            strip(3, 5);
                            this.popState();
                            return 15;
                            break;

                          case 15:
                            return 22;
                            break;

                          case 16:
                            return 41;
                            break;

                          case 17:
                            return 40;
                            break;

                          case 18:
                            return 40;
                            break;

                          case 19:
                            return 44;
                            break;

                          case 20:
                            // ignore whitespace
                            break;

                          case 21:
                            this.popState();
                            return 24;
                            break;

                          case 22:
                            this.popState();
                            return 18;
                            break;

                          case 23:
                            yy_.yytext = strip(1, 2).replace(/\\"/g, '"');
                            return 32;
                            break;

                          case 24:
                            yy_.yytext = strip(1, 2).replace(/\\'/g, "'");
                            return 32;
                            break;

                          case 25:
                            return 42;
                            break;

                          case 26:
                            return 34;
                            break;

                          case 27:
                            return 34;
                            break;

                          case 28:
                            return 33;
                            break;

                          case 29:
                            return 40;
                            break;

                          case 30:
                            yy_.yytext = strip(1, 2);
                            return 40;
                            break;

                          case 31:
                            return "INVALID";
                            break;

                          case 32:
                            return 5;
                            break;
                        }
                    };
                    lexer.rules = [ /^(?:[^\x00]*?(?=(\{\{)))/, /^(?:[^\x00]+)/, /^(?:[^\x00]{2,}?(?=(\{\{|\\\{\{|\\\\\{\{|$)))/, /^(?:[\s\S]*?--\}\})/, /^(?:\()/, /^(?:\))/, /^(?:\{\{(~)?>)/, /^(?:\{\{(~)?#)/, /^(?:\{\{(~)?\/)/, /^(?:\{\{(~)?\^)/, /^(?:\{\{(~)?\s*else\b)/, /^(?:\{\{(~)?\{)/, /^(?:\{\{(~)?&)/, /^(?:\{\{!--)/, /^(?:\{\{![\s\S]*?\}\})/, /^(?:\{\{(~)?)/, /^(?:=)/, /^(?:\.\.)/, /^(?:\.(?=([=~}\s\/.)])))/, /^(?:[\/.])/, /^(?:\s+)/, /^(?:\}(~)?\}\})/, /^(?:(~)?\}\})/, /^(?:"(\\["]|[^"])*")/, /^(?:'(\\[']|[^'])*')/, /^(?:@)/, /^(?:true(?=([~}\s)])))/, /^(?:false(?=([~}\s)])))/, /^(?:-?[0-9]+(?=([~}\s)])))/, /^(?:([^\s!"#%-,\.\/;->@\[-\^`\{-~]+(?=([=~}\s\/.)]))))/, /^(?:\[[^\]]*\])/, /^(?:.)/, /^(?:$)/ ];
                    lexer.conditions = {
                        mu: {
                            rules: [ 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32 ],
                            inclusive: false
                        },
                        emu: {
                            rules: [ 2 ],
                            inclusive: false
                        },
                        com: {
                            rules: [ 3 ],
                            inclusive: false
                        },
                        INITIAL: {
                            rules: [ 0, 1, 32 ],
                            inclusive: true
                        }
                    };
                    return lexer;
                }();
                parser.lexer = lexer;
                function Parser() {
                    this.yy = {};
                }
                Parser.prototype = parser;
                parser.Parser = Parser;
                return new Parser();
            }();
            __exports__ = handlebars;
            /* jshint ignore:end */
            return __exports__;
        }();
        // handlebars/compiler/base.js
        var __module8__ = function(__dependency1__, __dependency2__) {
            "use strict";
            var __exports__ = {};
            var parser = __dependency1__;
            var AST = __dependency2__;
            __exports__.parser = parser;
            function parse(input) {
                // Just return if an already-compile AST was passed in.
                if (input.constructor === AST.ProgramNode) {
                    return input;
                }
                parser.yy = AST;
                return parser.parse(input);
            }
            __exports__.parse = parse;
            return __exports__;
        }(__module9__, __module7__);
        // handlebars/compiler/compiler.js
        var __module10__ = function(__dependency1__) {
            "use strict";
            var __exports__ = {};
            var Exception = __dependency1__;
            function Compiler() {}
            __exports__.Compiler = Compiler;
            // the foundHelper register will disambiguate helper lookup from finding a
            // function in a context. This is necessary for mustache compatibility, which
            // requires that context functions in blocks are evaluated by blockHelperMissing,
            // and then proceed as if the resulting value was provided to blockHelperMissing.
            Compiler.prototype = {
                compiler: Compiler,
                disassemble: function() {
                    var opcodes = this.opcodes, opcode, out = [], params, param;
                    for (var i = 0, l = opcodes.length; i < l; i++) {
                        opcode = opcodes[i];
                        if (opcode.opcode === "DECLARE") {
                            out.push("DECLARE " + opcode.name + "=" + opcode.value);
                        } else {
                            params = [];
                            for (var j = 0; j < opcode.args.length; j++) {
                                param = opcode.args[j];
                                if (typeof param === "string") {
                                    param = '"' + param.replace("\n", "\\n") + '"';
                                }
                                params.push(param);
                            }
                            out.push(opcode.opcode + " " + params.join(" "));
                        }
                    }
                    return out.join("\n");
                },
                equals: function(other) {
                    var len = this.opcodes.length;
                    if (other.opcodes.length !== len) {
                        return false;
                    }
                    for (var i = 0; i < len; i++) {
                        var opcode = this.opcodes[i], otherOpcode = other.opcodes[i];
                        if (opcode.opcode !== otherOpcode.opcode || opcode.args.length !== otherOpcode.args.length) {
                            return false;
                        }
                        for (var j = 0; j < opcode.args.length; j++) {
                            if (opcode.args[j] !== otherOpcode.args[j]) {
                                return false;
                            }
                        }
                    }
                    len = this.children.length;
                    if (other.children.length !== len) {
                        return false;
                    }
                    for (i = 0; i < len; i++) {
                        if (!this.children[i].equals(other.children[i])) {
                            return false;
                        }
                    }
                    return true;
                },
                guid: 0,
                compile: function(program, options) {
                    this.opcodes = [];
                    this.children = [];
                    this.depths = {
                        list: []
                    };
                    this.options = options;
                    // These changes will propagate to the other compiler components
                    var knownHelpers = this.options.knownHelpers;
                    this.options.knownHelpers = {
                        helperMissing: true,
                        blockHelperMissing: true,
                        each: true,
                        "if": true,
                        unless: true,
                        "with": true,
                        log: true
                    };
                    if (knownHelpers) {
                        for (var name in knownHelpers) {
                            this.options.knownHelpers[name] = knownHelpers[name];
                        }
                    }
                    return this.accept(program);
                },
                accept: function(node) {
                    var strip = node.strip || {}, ret;
                    if (strip.left) {
                        this.opcode("strip");
                    }
                    ret = this[node.type](node);
                    if (strip.right) {
                        this.opcode("strip");
                    }
                    return ret;
                },
                program: function(program) {
                    var statements = program.statements;
                    for (var i = 0, l = statements.length; i < l; i++) {
                        this.accept(statements[i]);
                    }
                    this.isSimple = l === 1;
                    this.depths.list = this.depths.list.sort(function(a, b) {
                        return a - b;
                    });
                    return this;
                },
                compileProgram: function(program) {
                    var result = new this.compiler().compile(program, this.options);
                    var guid = this.guid++, depth;
                    this.usePartial = this.usePartial || result.usePartial;
                    this.children[guid] = result;
                    for (var i = 0, l = result.depths.list.length; i < l; i++) {
                        depth = result.depths.list[i];
                        if (depth < 2) {
                            continue;
                        } else {
                            this.addDepth(depth - 1);
                        }
                    }
                    return guid;
                },
                block: function(block) {
                    var mustache = block.mustache, program = block.program, inverse = block.inverse;
                    if (program) {
                        program = this.compileProgram(program);
                    }
                    if (inverse) {
                        inverse = this.compileProgram(inverse);
                    }
                    var sexpr = mustache.sexpr;
                    var type = this.classifySexpr(sexpr);
                    if (type === "helper") {
                        this.helperSexpr(sexpr, program, inverse);
                    } else if (type === "simple") {
                        this.simpleSexpr(sexpr);
                        // now that the simple mustache is resolved, we need to
                        // evaluate it by executing `blockHelperMissing`
                        this.opcode("pushProgram", program);
                        this.opcode("pushProgram", inverse);
                        this.opcode("emptyHash");
                        this.opcode("blockValue");
                    } else {
                        this.ambiguousSexpr(sexpr, program, inverse);
                        // now that the simple mustache is resolved, we need to
                        // evaluate it by executing `blockHelperMissing`
                        this.opcode("pushProgram", program);
                        this.opcode("pushProgram", inverse);
                        this.opcode("emptyHash");
                        this.opcode("ambiguousBlockValue");
                    }
                    this.opcode("append");
                },
                hash: function(hash) {
                    var pairs = hash.pairs, pair, val;
                    this.opcode("pushHash");
                    for (var i = 0, l = pairs.length; i < l; i++) {
                        pair = pairs[i];
                        val = pair[1];
                        if (this.options.stringParams) {
                            if (val.depth) {
                                this.addDepth(val.depth);
                            }
                            this.opcode("getContext", val.depth || 0);
                            this.opcode("pushStringParam", val.stringModeValue, val.type);
                            if (val.type === "sexpr") {
                                // Subexpressions get evaluated and passed in
                                // in string params mode.
                                this.sexpr(val);
                            }
                        } else {
                            this.accept(val);
                        }
                        this.opcode("assignToHash", pair[0]);
                    }
                    this.opcode("popHash");
                },
                partial: function(partial) {
                    var partialName = partial.partialName;
                    this.usePartial = true;
                    if (partial.context) {
                        this.ID(partial.context);
                    } else {
                        this.opcode("push", "depth0");
                    }
                    this.opcode("invokePartial", partialName.name);
                    this.opcode("append");
                },
                content: function(content) {
                    this.opcode("appendContent", content.string);
                },
                mustache: function(mustache) {
                    this.sexpr(mustache.sexpr);
                    if (mustache.escaped && !this.options.noEscape) {
                        this.opcode("appendEscaped");
                    } else {
                        this.opcode("append");
                    }
                },
                ambiguousSexpr: function(sexpr, program, inverse) {
                    var id = sexpr.id, name = id.parts[0], isBlock = program != null || inverse != null;
                    this.opcode("getContext", id.depth);
                    this.opcode("pushProgram", program);
                    this.opcode("pushProgram", inverse);
                    this.opcode("invokeAmbiguous", name, isBlock);
                },
                simpleSexpr: function(sexpr) {
                    var id = sexpr.id;
                    if (id.type === "DATA") {
                        this.DATA(id);
                    } else if (id.parts.length) {
                        this.ID(id);
                    } else {
                        // Simplified ID for `this`
                        this.addDepth(id.depth);
                        this.opcode("getContext", id.depth);
                        this.opcode("pushContext");
                    }
                    this.opcode("resolvePossibleLambda");
                },
                helperSexpr: function(sexpr, program, inverse) {
                    var params = this.setupFullMustacheParams(sexpr, program, inverse), name = sexpr.id.parts[0];
                    if (this.options.knownHelpers[name]) {
                        this.opcode("invokeKnownHelper", params.length, name);
                    } else if (this.options.knownHelpersOnly) {
                        throw new Exception("You specified knownHelpersOnly, but used the unknown helper " + name, sexpr);
                    } else {
                        this.opcode("invokeHelper", params.length, name, sexpr.isRoot);
                    }
                },
                sexpr: function(sexpr) {
                    var type = this.classifySexpr(sexpr);
                    if (type === "simple") {
                        this.simpleSexpr(sexpr);
                    } else if (type === "helper") {
                        this.helperSexpr(sexpr);
                    } else {
                        this.ambiguousSexpr(sexpr);
                    }
                },
                ID: function(id) {
                    this.addDepth(id.depth);
                    this.opcode("getContext", id.depth);
                    var name = id.parts[0];
                    if (!name) {
                        this.opcode("pushContext");
                    } else {
                        this.opcode("lookupOnContext", id.parts[0]);
                    }
                    for (var i = 1, l = id.parts.length; i < l; i++) {
                        this.opcode("lookup", id.parts[i]);
                    }
                },
                DATA: function(data) {
                    this.options.data = true;
                    if (data.id.isScoped || data.id.depth) {
                        throw new Exception("Scoped data references are not supported: " + data.original, data);
                    }
                    this.opcode("lookupData");
                    var parts = data.id.parts;
                    for (var i = 0, l = parts.length; i < l; i++) {
                        this.opcode("lookup", parts[i]);
                    }
                },
                STRING: function(string) {
                    this.opcode("pushString", string.string);
                },
                INTEGER: function(integer) {
                    this.opcode("pushLiteral", integer.integer);
                },
                BOOLEAN: function(bool) {
                    this.opcode("pushLiteral", bool.bool);
                },
                comment: function() {},
                // HELPERS
                opcode: function(name) {
                    this.opcodes.push({
                        opcode: name,
                        args: [].slice.call(arguments, 1)
                    });
                },
                declare: function(name, value) {
                    this.opcodes.push({
                        opcode: "DECLARE",
                        name: name,
                        value: value
                    });
                },
                addDepth: function(depth) {
                    if (depth === 0) {
                        return;
                    }
                    if (!this.depths[depth]) {
                        this.depths[depth] = true;
                        this.depths.list.push(depth);
                    }
                },
                classifySexpr: function(sexpr) {
                    var isHelper = sexpr.isHelper;
                    var isEligible = sexpr.eligibleHelper;
                    var options = this.options;
                    // if ambiguous, we can possibly resolve the ambiguity now
                    if (isEligible && !isHelper) {
                        var name = sexpr.id.parts[0];
                        if (options.knownHelpers[name]) {
                            isHelper = true;
                        } else if (options.knownHelpersOnly) {
                            isEligible = false;
                        }
                    }
                    if (isHelper) {
                        return "helper";
                    } else if (isEligible) {
                        return "ambiguous";
                    } else {
                        return "simple";
                    }
                },
                pushParams: function(params) {
                    var i = params.length, param;
                    while (i--) {
                        param = params[i];
                        if (this.options.stringParams) {
                            if (param.depth) {
                                this.addDepth(param.depth);
                            }
                            this.opcode("getContext", param.depth || 0);
                            this.opcode("pushStringParam", param.stringModeValue, param.type);
                            if (param.type === "sexpr") {
                                // Subexpressions get evaluated and passed in
                                // in string params mode.
                                this.sexpr(param);
                            }
                        } else {
                            this[param.type](param);
                        }
                    }
                },
                setupFullMustacheParams: function(sexpr, program, inverse) {
                    var params = sexpr.params;
                    this.pushParams(params);
                    this.opcode("pushProgram", program);
                    this.opcode("pushProgram", inverse);
                    if (sexpr.hash) {
                        this.hash(sexpr.hash);
                    } else {
                        this.opcode("emptyHash");
                    }
                    return params;
                }
            };
            function precompile(input, options, env) {
                if (input == null || typeof input !== "string" && input.constructor !== env.AST.ProgramNode) {
                    throw new Exception("You must pass a string or Handlebars AST to Handlebars.precompile. You passed " + input);
                }
                options = options || {};
                if (!("data" in options)) {
                    options.data = true;
                }
                var ast = env.parse(input);
                var environment = new env.Compiler().compile(ast, options);
                return new env.JavaScriptCompiler().compile(environment, options);
            }
            __exports__.precompile = precompile;
            function compile(input, options, env) {
                if (input == null || typeof input !== "string" && input.constructor !== env.AST.ProgramNode) {
                    throw new Exception("You must pass a string or Handlebars AST to Handlebars.compile. You passed " + input);
                }
                options = options || {};
                if (!("data" in options)) {
                    options.data = true;
                }
                var compiled;
                function compileInput() {
                    var ast = env.parse(input);
                    var environment = new env.Compiler().compile(ast, options);
                    var templateSpec = new env.JavaScriptCompiler().compile(environment, options, undefined, true);
                    return env.template(templateSpec);
                }
                // Template is only compiled on first use and cached after that point.
                return function(context, options) {
                    if (!compiled) {
                        compiled = compileInput();
                    }
                    return compiled.call(this, context, options);
                };
            }
            __exports__.compile = compile;
            return __exports__;
        }(__module5__);
        // handlebars/compiler/javascript-compiler.js
        var __module11__ = function(__dependency1__, __dependency2__) {
            "use strict";
            var __exports__;
            var COMPILER_REVISION = __dependency1__.COMPILER_REVISION;
            var REVISION_CHANGES = __dependency1__.REVISION_CHANGES;
            var log = __dependency1__.log;
            var Exception = __dependency2__;
            function Literal(value) {
                this.value = value;
            }
            function JavaScriptCompiler() {}
            JavaScriptCompiler.prototype = {
                // PUBLIC API: You can override these methods in a subclass to provide
                // alternative compiled forms for name lookup and buffering semantics
                nameLookup: function(parent, name) {
                    var wrap, ret;
                    if (parent.indexOf("depth") === 0) {
                        wrap = true;
                    }
                    if (/^[0-9]+$/.test(name)) {
                        ret = parent + "[" + name + "]";
                    } else if (JavaScriptCompiler.isValidJavaScriptVariableName(name)) {
                        ret = parent + "." + name;
                    } else {
                        ret = parent + "['" + name + "']";
                    }
                    if (wrap) {
                        return "(" + parent + " && " + ret + ")";
                    } else {
                        return ret;
                    }
                },
                compilerInfo: function() {
                    var revision = COMPILER_REVISION, versions = REVISION_CHANGES[revision];
                    return "this.compilerInfo = [" + revision + ",'" + versions + "'];\n";
                },
                appendToBuffer: function(string) {
                    if (this.environment.isSimple) {
                        return "return " + string + ";";
                    } else {
                        return {
                            appendToBuffer: true,
                            content: string,
                            toString: function() {
                                return "buffer += " + string + ";";
                            }
                        };
                    }
                },
                initializeBuffer: function() {
                    return this.quotedString("");
                },
                namespace: "Handlebars",
                // END PUBLIC API
                compile: function(environment, options, context, asObject) {
                    this.environment = environment;
                    this.options = options || {};
                    log("debug", this.environment.disassemble() + "\n\n");
                    this.name = this.environment.name;
                    this.isChild = !!context;
                    this.context = context || {
                        programs: [],
                        environments: [],
                        aliases: {}
                    };
                    this.preamble();
                    this.stackSlot = 0;
                    this.stackVars = [];
                    this.registers = {
                        list: []
                    };
                    this.hashes = [];
                    this.compileStack = [];
                    this.inlineStack = [];
                    this.compileChildren(environment, options);
                    var opcodes = environment.opcodes, opcode;
                    this.i = 0;
                    for (var l = opcodes.length; this.i < l; this.i++) {
                        opcode = opcodes[this.i];
                        if (opcode.opcode === "DECLARE") {
                            this[opcode.name] = opcode.value;
                        } else {
                            this[opcode.opcode].apply(this, opcode.args);
                        }
                        // Reset the stripNext flag if it was not set by this operation.
                        if (opcode.opcode !== this.stripNext) {
                            this.stripNext = false;
                        }
                    }
                    // Flush any trailing content that might be pending.
                    this.pushSource("");
                    if (this.stackSlot || this.inlineStack.length || this.compileStack.length) {
                        throw new Exception("Compile completed with content left on stack");
                    }
                    return this.createFunctionContext(asObject);
                },
                preamble: function() {
                    var out = [];
                    if (!this.isChild) {
                        var namespace = this.namespace;
                        var copies = "helpers = this.merge(helpers, " + namespace + ".helpers);";
                        if (this.environment.usePartial) {
                            copies = copies + " partials = this.merge(partials, " + namespace + ".partials);";
                        }
                        if (this.options.data) {
                            copies = copies + " data = data || {};";
                        }
                        out.push(copies);
                    } else {
                        out.push("");
                    }
                    if (!this.environment.isSimple) {
                        out.push(", buffer = " + this.initializeBuffer());
                    } else {
                        out.push("");
                    }
                    // track the last context pushed into place to allow skipping the
                    // getContext opcode when it would be a noop
                    this.lastContext = 0;
                    this.source = out;
                },
                createFunctionContext: function(asObject) {
                    var locals = this.stackVars.concat(this.registers.list);
                    if (locals.length > 0) {
                        this.source[1] = this.source[1] + ", " + locals.join(", ");
                    }
                    // Generate minimizer alias mappings
                    if (!this.isChild) {
                        for (var alias in this.context.aliases) {
                            if (this.context.aliases.hasOwnProperty(alias)) {
                                this.source[1] = this.source[1] + ", " + alias + "=" + this.context.aliases[alias];
                            }
                        }
                    }
                    if (this.source[1]) {
                        this.source[1] = "var " + this.source[1].substring(2) + ";";
                    }
                    // Merge children
                    if (!this.isChild) {
                        this.source[1] += "\n" + this.context.programs.join("\n") + "\n";
                    }
                    if (!this.environment.isSimple) {
                        this.pushSource("return buffer;");
                    }
                    var params = this.isChild ? [ "depth0", "data" ] : [ "Handlebars", "depth0", "helpers", "partials", "data" ];
                    for (var i = 0, l = this.environment.depths.list.length; i < l; i++) {
                        params.push("depth" + this.environment.depths.list[i]);
                    }
                    // Perform a second pass over the output to merge content when possible
                    var source = this.mergeSource();
                    if (!this.isChild) {
                        source = this.compilerInfo() + source;
                    }
                    if (asObject) {
                        params.push(source);
                        return Function.apply(this, params);
                    } else {
                        var functionSource = "function " + (this.name || "") + "(" + params.join(",") + ") {\n  " + source + "}";
                        log("debug", functionSource + "\n\n");
                        return functionSource;
                    }
                },
                mergeSource: function() {
                    // WARN: We are not handling the case where buffer is still populated as the source should
                    // not have buffer append operations as their final action.
                    var source = "", buffer;
                    for (var i = 0, len = this.source.length; i < len; i++) {
                        var line = this.source[i];
                        if (line.appendToBuffer) {
                            if (buffer) {
                                buffer = buffer + "\n    + " + line.content;
                            } else {
                                buffer = line.content;
                            }
                        } else {
                            if (buffer) {
                                source += "buffer += " + buffer + ";\n  ";
                                buffer = undefined;
                            }
                            source += line + "\n  ";
                        }
                    }
                    return source;
                },
                // [blockValue]
                //
                // On stack, before: hash, inverse, program, value
                // On stack, after: return value of blockHelperMissing
                //
                // The purpose of this opcode is to take a block of the form
                // `{{#foo}}...{{/foo}}`, resolve the value of `foo`, and
                // replace it on the stack with the result of properly
                // invoking blockHelperMissing.
                blockValue: function() {
                    this.context.aliases.blockHelperMissing = "helpers.blockHelperMissing";
                    var params = [ "depth0" ];
                    this.setupParams(0, params);
                    this.replaceStack(function(current) {
                        params.splice(1, 0, current);
                        return "blockHelperMissing.call(" + params.join(", ") + ")";
                    });
                },
                // [ambiguousBlockValue]
                //
                // On stack, before: hash, inverse, program, value
                // Compiler value, before: lastHelper=value of last found helper, if any
                // On stack, after, if no lastHelper: same as [blockValue]
                // On stack, after, if lastHelper: value
                ambiguousBlockValue: function() {
                    this.context.aliases.blockHelperMissing = "helpers.blockHelperMissing";
                    var params = [ "depth0" ];
                    this.setupParams(0, params);
                    var current = this.topStack();
                    params.splice(1, 0, current);
                    this.pushSource("if (!" + this.lastHelper + ") { " + current + " = blockHelperMissing.call(" + params.join(", ") + "); }");
                },
                // [appendContent]
                //
                // On stack, before: ...
                // On stack, after: ...
                //
                // Appends the string value of `content` to the current buffer
                appendContent: function(content) {
                    if (this.pendingContent) {
                        content = this.pendingContent + content;
                    }
                    if (this.stripNext) {
                        content = content.replace(/^\s+/, "");
                    }
                    this.pendingContent = content;
                },
                // [strip]
                //
                // On stack, before: ...
                // On stack, after: ...
                //
                // Removes any trailing whitespace from the prior content node and flags
                // the next operation for stripping if it is a content node.
                strip: function() {
                    if (this.pendingContent) {
                        this.pendingContent = this.pendingContent.replace(/\s+$/, "");
                    }
                    this.stripNext = "strip";
                },
                // [append]
                //
                // On stack, before: value, ...
                // On stack, after: ...
                //
                // Coerces `value` to a String and appends it to the current buffer.
                //
                // If `value` is truthy, or 0, it is coerced into a string and appended
                // Otherwise, the empty string is appended
                append: function() {
                    // Force anything that is inlined onto the stack so we don't have duplication
                    // when we examine local
                    this.flushInline();
                    var local = this.popStack();
                    this.pushSource("if(" + local + " || " + local + " === 0) { " + this.appendToBuffer(local) + " }");
                    if (this.environment.isSimple) {
                        this.pushSource("else { " + this.appendToBuffer("''") + " }");
                    }
                },
                // [appendEscaped]
                //
                // On stack, before: value, ...
                // On stack, after: ...
                //
                // Escape `value` and append it to the buffer
                appendEscaped: function() {
                    this.context.aliases.escapeExpression = "this.escapeExpression";
                    this.pushSource(this.appendToBuffer("escapeExpression(" + this.popStack() + ")"));
                },
                // [getContext]
                //
                // On stack, before: ...
                // On stack, after: ...
                // Compiler value, after: lastContext=depth
                //
                // Set the value of the `lastContext` compiler value to the depth
                getContext: function(depth) {
                    if (this.lastContext !== depth) {
                        this.lastContext = depth;
                    }
                },
                // [lookupOnContext]
                //
                // On stack, before: ...
                // On stack, after: currentContext[name], ...
                //
                // Looks up the value of `name` on the current context and pushes
                // it onto the stack.
                lookupOnContext: function(name) {
                    this.push(this.nameLookup("depth" + this.lastContext, name, "context"));
                },
                // [pushContext]
                //
                // On stack, before: ...
                // On stack, after: currentContext, ...
                //
                // Pushes the value of the current context onto the stack.
                pushContext: function() {
                    this.pushStackLiteral("depth" + this.lastContext);
                },
                // [resolvePossibleLambda]
                //
                // On stack, before: value, ...
                // On stack, after: resolved value, ...
                //
                // If the `value` is a lambda, replace it on the stack by
                // the return value of the lambda
                resolvePossibleLambda: function() {
                    this.context.aliases.functionType = '"function"';
                    this.replaceStack(function(current) {
                        return "typeof " + current + " === functionType ? " + current + ".apply(depth0) : " + current;
                    });
                },
                // [lookup]
                //
                // On stack, before: value, ...
                // On stack, after: value[name], ...
                //
                // Replace the value on the stack with the result of looking
                // up `name` on `value`
                lookup: function(name) {
                    this.replaceStack(function(current) {
                        return current + " == null || " + current + " === false ? " + current + " : " + this.nameLookup(current, name, "context");
                    });
                },
                // [lookupData]
                //
                // On stack, before: ...
                // On stack, after: data, ...
                //
                // Push the data lookup operator
                lookupData: function() {
                    this.pushStackLiteral("data");
                },
                // [pushStringParam]
                //
                // On stack, before: ...
                // On stack, after: string, currentContext, ...
                //
                // This opcode is designed for use in string mode, which
                // provides the string value of a parameter along with its
                // depth rather than resolving it immediately.
                pushStringParam: function(string, type) {
                    this.pushStackLiteral("depth" + this.lastContext);
                    this.pushString(type);
                    // If it's a subexpression, the string result
                    // will be pushed after this opcode.
                    if (type !== "sexpr") {
                        if (typeof string === "string") {
                            this.pushString(string);
                        } else {
                            this.pushStackLiteral(string);
                        }
                    }
                },
                emptyHash: function() {
                    this.pushStackLiteral("{}");
                    if (this.options.stringParams) {
                        this.push("{}");
                        // hashContexts
                        this.push("{}");
                    }
                },
                pushHash: function() {
                    if (this.hash) {
                        this.hashes.push(this.hash);
                    }
                    this.hash = {
                        values: [],
                        types: [],
                        contexts: []
                    };
                },
                popHash: function() {
                    var hash = this.hash;
                    this.hash = this.hashes.pop();
                    if (this.options.stringParams) {
                        this.push("{" + hash.contexts.join(",") + "}");
                        this.push("{" + hash.types.join(",") + "}");
                    }
                    this.push("{\n    " + hash.values.join(",\n    ") + "\n  }");
                },
                // [pushString]
                //
                // On stack, before: ...
                // On stack, after: quotedString(string), ...
                //
                // Push a quoted version of `string` onto the stack
                pushString: function(string) {
                    this.pushStackLiteral(this.quotedString(string));
                },
                // [push]
                //
                // On stack, before: ...
                // On stack, after: expr, ...
                //
                // Push an expression onto the stack
                push: function(expr) {
                    this.inlineStack.push(expr);
                    return expr;
                },
                // [pushLiteral]
                //
                // On stack, before: ...
                // On stack, after: value, ...
                //
                // Pushes a value onto the stack. This operation prevents
                // the compiler from creating a temporary variable to hold
                // it.
                pushLiteral: function(value) {
                    this.pushStackLiteral(value);
                },
                // [pushProgram]
                //
                // On stack, before: ...
                // On stack, after: program(guid), ...
                //
                // Push a program expression onto the stack. This takes
                // a compile-time guid and converts it into a runtime-accessible
                // expression.
                pushProgram: function(guid) {
                    if (guid != null) {
                        this.pushStackLiteral(this.programExpression(guid));
                    } else {
                        this.pushStackLiteral(null);
                    }
                },
                // [invokeHelper]
                //
                // On stack, before: hash, inverse, program, params..., ...
                // On stack, after: result of helper invocation
                //
                // Pops off the helper's parameters, invokes the helper,
                // and pushes the helper's return value onto the stack.
                //
                // If the helper is not found, `helperMissing` is called.
                invokeHelper: function(paramSize, name, isRoot) {
                    this.context.aliases.helperMissing = "helpers.helperMissing";
                    this.useRegister("helper");
                    var helper = this.lastHelper = this.setupHelper(paramSize, name, true);
                    var nonHelper = this.nameLookup("depth" + this.lastContext, name, "context");
                    var lookup = "helper = " + helper.name + " || " + nonHelper;
                    if (helper.paramsInit) {
                        lookup += "," + helper.paramsInit;
                    }
                    this.push("(" + lookup + ",helper " + "? helper.call(" + helper.callParams + ") " + ": helperMissing.call(" + helper.helperMissingParams + "))");
                    // Always flush subexpressions. This is both to prevent the compounding size issue that
                    // occurs when the code has to be duplicated for inlining and also to prevent errors
                    // due to the incorrect options object being passed due to the shared register.
                    if (!isRoot) {
                        this.flushInline();
                    }
                },
                // [invokeKnownHelper]
                //
                // On stack, before: hash, inverse, program, params..., ...
                // On stack, after: result of helper invocation
                //
                // This operation is used when the helper is known to exist,
                // so a `helperMissing` fallback is not required.
                invokeKnownHelper: function(paramSize, name) {
                    var helper = this.setupHelper(paramSize, name);
                    this.push(helper.name + ".call(" + helper.callParams + ")");
                },
                // [invokeAmbiguous]
                //
                // On stack, before: hash, inverse, program, params..., ...
                // On stack, after: result of disambiguation
                //
                // This operation is used when an expression like `{{foo}}`
                // is provided, but we don't know at compile-time whether it
                // is a helper or a path.
                //
                // This operation emits more code than the other options,
                // and can be avoided by passing the `knownHelpers` and
                // `knownHelpersOnly` flags at compile-time.
                invokeAmbiguous: function(name, helperCall) {
                    this.context.aliases.functionType = '"function"';
                    this.useRegister("helper");
                    this.emptyHash();
                    var helper = this.setupHelper(0, name, helperCall);
                    var helperName = this.lastHelper = this.nameLookup("helpers", name, "helper");
                    var nonHelper = this.nameLookup("depth" + this.lastContext, name, "context");
                    var nextStack = this.nextStack();
                    if (helper.paramsInit) {
                        this.pushSource(helper.paramsInit);
                    }
                    this.pushSource("if (helper = " + helperName + ") { " + nextStack + " = helper.call(" + helper.callParams + "); }");
                    this.pushSource("else { helper = " + nonHelper + "; " + nextStack + " = typeof helper === functionType ? helper.call(" + helper.callParams + ") : helper; }");
                },
                // [invokePartial]
                //
                // On stack, before: context, ...
                // On stack after: result of partial invocation
                //
                // This operation pops off a context, invokes a partial with that context,
                // and pushes the result of the invocation back.
                invokePartial: function(name) {
                    var params = [ this.nameLookup("partials", name, "partial"), "'" + name + "'", this.popStack(), "helpers", "partials" ];
                    if (this.options.data) {
                        params.push("data");
                    }
                    this.context.aliases.self = "this";
                    this.push("self.invokePartial(" + params.join(", ") + ")");
                },
                // [assignToHash]
                //
                // On stack, before: value, hash, ...
                // On stack, after: hash, ...
                //
                // Pops a value and hash off the stack, assigns `hash[key] = value`
                // and pushes the hash back onto the stack.
                assignToHash: function(key) {
                    var value = this.popStack(), context, type;
                    if (this.options.stringParams) {
                        type = this.popStack();
                        context = this.popStack();
                    }
                    var hash = this.hash;
                    if (context) {
                        hash.contexts.push("'" + key + "': " + context);
                    }
                    if (type) {
                        hash.types.push("'" + key + "': " + type);
                    }
                    hash.values.push("'" + key + "': (" + value + ")");
                },
                // HELPERS
                compiler: JavaScriptCompiler,
                compileChildren: function(environment, options) {
                    var children = environment.children, child, compiler;
                    for (var i = 0, l = children.length; i < l; i++) {
                        child = children[i];
                        compiler = new this.compiler();
                        var index = this.matchExistingProgram(child);
                        if (index == null) {
                            this.context.programs.push("");
                            // Placeholder to prevent name conflicts for nested children
                            index = this.context.programs.length;
                            child.index = index;
                            child.name = "program" + index;
                            this.context.programs[index] = compiler.compile(child, options, this.context);
                            this.context.environments[index] = child;
                        } else {
                            child.index = index;
                            child.name = "program" + index;
                        }
                    }
                },
                matchExistingProgram: function(child) {
                    for (var i = 0, len = this.context.environments.length; i < len; i++) {
                        var environment = this.context.environments[i];
                        if (environment && environment.equals(child)) {
                            return i;
                        }
                    }
                },
                programExpression: function(guid) {
                    this.context.aliases.self = "this";
                    if (guid == null) {
                        return "self.noop";
                    }
                    var child = this.environment.children[guid], depths = child.depths.list, depth;
                    var programParams = [ child.index, child.name, "data" ];
                    for (var i = 0, l = depths.length; i < l; i++) {
                        depth = depths[i];
                        if (depth === 1) {
                            programParams.push("depth0");
                        } else {
                            programParams.push("depth" + (depth - 1));
                        }
                    }
                    return (depths.length === 0 ? "self.program(" : "self.programWithDepth(") + programParams.join(", ") + ")";
                },
                register: function(name, val) {
                    this.useRegister(name);
                    this.pushSource(name + " = " + val + ";");
                },
                useRegister: function(name) {
                    if (!this.registers[name]) {
                        this.registers[name] = true;
                        this.registers.list.push(name);
                    }
                },
                pushStackLiteral: function(item) {
                    return this.push(new Literal(item));
                },
                pushSource: function(source) {
                    if (this.pendingContent) {
                        this.source.push(this.appendToBuffer(this.quotedString(this.pendingContent)));
                        this.pendingContent = undefined;
                    }
                    if (source) {
                        this.source.push(source);
                    }
                },
                pushStack: function(item) {
                    this.flushInline();
                    var stack = this.incrStack();
                    if (item) {
                        this.pushSource(stack + " = " + item + ";");
                    }
                    this.compileStack.push(stack);
                    return stack;
                },
                replaceStack: function(callback) {
                    var prefix = "", inline = this.isInline(), stack, createdStack, usedLiteral;
                    // If we are currently inline then we want to merge the inline statement into the
                    // replacement statement via ','
                    if (inline) {
                        var top = this.popStack(true);
                        if (top instanceof Literal) {
                            // Literals do not need to be inlined
                            stack = top.value;
                            usedLiteral = true;
                        } else {
                            // Get or create the current stack name for use by the inline
                            createdStack = !this.stackSlot;
                            var name = !createdStack ? this.topStackName() : this.incrStack();
                            prefix = "(" + this.push(name) + " = " + top + "),";
                            stack = this.topStack();
                        }
                    } else {
                        stack = this.topStack();
                    }
                    var item = callback.call(this, stack);
                    if (inline) {
                        if (!usedLiteral) {
                            this.popStack();
                        }
                        if (createdStack) {
                            this.stackSlot--;
                        }
                        this.push("(" + prefix + item + ")");
                    } else {
                        // Prevent modification of the context depth variable. Through replaceStack
                        if (!/^stack/.test(stack)) {
                            stack = this.nextStack();
                        }
                        this.pushSource(stack + " = (" + prefix + item + ");");
                    }
                    return stack;
                },
                nextStack: function() {
                    return this.pushStack();
                },
                incrStack: function() {
                    this.stackSlot++;
                    if (this.stackSlot > this.stackVars.length) {
                        this.stackVars.push("stack" + this.stackSlot);
                    }
                    return this.topStackName();
                },
                topStackName: function() {
                    return "stack" + this.stackSlot;
                },
                flushInline: function() {
                    var inlineStack = this.inlineStack;
                    if (inlineStack.length) {
                        this.inlineStack = [];
                        for (var i = 0, len = inlineStack.length; i < len; i++) {
                            var entry = inlineStack[i];
                            if (entry instanceof Literal) {
                                this.compileStack.push(entry);
                            } else {
                                this.pushStack(entry);
                            }
                        }
                    }
                },
                isInline: function() {
                    return this.inlineStack.length;
                },
                popStack: function(wrapped) {
                    var inline = this.isInline(), item = (inline ? this.inlineStack : this.compileStack).pop();
                    if (!wrapped && item instanceof Literal) {
                        return item.value;
                    } else {
                        if (!inline) {
                            if (!this.stackSlot) {
                                throw new Exception("Invalid stack pop");
                            }
                            this.stackSlot--;
                        }
                        return item;
                    }
                },
                topStack: function(wrapped) {
                    var stack = this.isInline() ? this.inlineStack : this.compileStack, item = stack[stack.length - 1];
                    if (!wrapped && item instanceof Literal) {
                        return item.value;
                    } else {
                        return item;
                    }
                },
                quotedString: function(str) {
                    return '"' + str.replace(/\\/g, "\\\\").replace(/"/g, '\\"').replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/\u2028/g, "\\u2028").replace(/\u2029/g, "\\u2029") + '"';
                },
                setupHelper: function(paramSize, name, missingParams) {
                    var params = [], paramsInit = this.setupParams(paramSize, params, missingParams);
                    var foundHelper = this.nameLookup("helpers", name, "helper");
                    return {
                        params: params,
                        paramsInit: paramsInit,
                        name: foundHelper,
                        callParams: [ "depth0" ].concat(params).join(", "),
                        helperMissingParams: missingParams && [ "depth0", this.quotedString(name) ].concat(params).join(", ")
                    };
                },
                setupOptions: function(paramSize, params) {
                    var options = [], contexts = [], types = [], param, inverse, program;
                    options.push("hash:" + this.popStack());
                    if (this.options.stringParams) {
                        options.push("hashTypes:" + this.popStack());
                        options.push("hashContexts:" + this.popStack());
                    }
                    inverse = this.popStack();
                    program = this.popStack();
                    // Avoid setting fn and inverse if neither are set. This allows
                    // helpers to do a check for `if (options.fn)`
                    if (program || inverse) {
                        if (!program) {
                            this.context.aliases.self = "this";
                            program = "self.noop";
                        }
                        if (!inverse) {
                            this.context.aliases.self = "this";
                            inverse = "self.noop";
                        }
                        options.push("inverse:" + inverse);
                        options.push("fn:" + program);
                    }
                    for (var i = 0; i < paramSize; i++) {
                        param = this.popStack();
                        params.push(param);
                        if (this.options.stringParams) {
                            types.push(this.popStack());
                            contexts.push(this.popStack());
                        }
                    }
                    if (this.options.stringParams) {
                        options.push("contexts:[" + contexts.join(",") + "]");
                        options.push("types:[" + types.join(",") + "]");
                    }
                    if (this.options.data) {
                        options.push("data:data");
                    }
                    return options;
                },
                // the params and contexts arguments are passed in arrays
                // to fill in
                setupParams: function(paramSize, params, useRegister) {
                    var options = "{" + this.setupOptions(paramSize, params).join(",") + "}";
                    if (useRegister) {
                        this.useRegister("options");
                        params.push("options");
                        return "options=" + options;
                    } else {
                        params.push(options);
                        return "";
                    }
                }
            };
            var reservedWords = ("break else new var" + " case finally return void" + " catch for switch while" + " continue function this with" + " default if throw" + " delete in try" + " do instanceof typeof" + " abstract enum int short" + " boolean export interface static" + " byte extends long super" + " char final native synchronized" + " class float package throws" + " const goto private transient" + " debugger implements protected volatile" + " double import public let yield").split(" ");
            var compilerWords = JavaScriptCompiler.RESERVED_WORDS = {};
            for (var i = 0, l = reservedWords.length; i < l; i++) {
                compilerWords[reservedWords[i]] = true;
            }
            JavaScriptCompiler.isValidJavaScriptVariableName = function(name) {
                if (!JavaScriptCompiler.RESERVED_WORDS[name] && /^[a-zA-Z_$][0-9a-zA-Z_$]*$/.test(name)) {
                    return true;
                }
                return false;
            };
            __exports__ = JavaScriptCompiler;
            return __exports__;
        }(__module2__, __module5__);
        // handlebars.js
        var __module0__ = function(__dependency1__, __dependency2__, __dependency3__, __dependency4__, __dependency5__) {
            "use strict";
            var __exports__;
            /*globals Handlebars: true */
            var Handlebars = __dependency1__;
            // Compiler imports
            var AST = __dependency2__;
            var Parser = __dependency3__.parser;
            var parse = __dependency3__.parse;
            var Compiler = __dependency4__.Compiler;
            var compile = __dependency4__.compile;
            var precompile = __dependency4__.precompile;
            var JavaScriptCompiler = __dependency5__;
            var _create = Handlebars.create;
            var create = function() {
                var hb = _create();
                hb.compile = function(input, options) {
                    return compile(input, options, hb);
                };
                hb.precompile = function(input, options) {
                    return precompile(input, options, hb);
                };
                hb.AST = AST;
                hb.Compiler = Compiler;
                hb.JavaScriptCompiler = JavaScriptCompiler;
                hb.Parser = Parser;
                hb.parse = parse;
                return hb;
            };
            Handlebars = create();
            Handlebars.create = create;
            __exports__ = Handlebars;
            return __exports__;
        }(__module1__, __module7__, __module8__, __module10__, __module11__);
        return __module0__;
    }();
}.bind(this));

require.register("app/vendor/notify.js", function(exports, require, module) {
    (function(root, factory) {
        "use strict";
        if (typeof define === "function" && define.amd) {
            // AMD environment
            define("notify", [], function() {
                return factory(root, document);
            });
        } else {
            // Browser environment
            root.Notify = factory(root, document);
        }
    })(this, function(w, d) {
        "use strict";
        function Notify(title, options) {
            this.title = typeof title === "string" ? title : null;
            this.options = {
                icon: "",
                body: "",
                tag: "",
                notifyShow: null,
                notifyClose: null,
                notifyClick: null,
                notifyError: null,
                permissionGranted: null,
                permissionDenied: null
            };
            this.permission = null;
            if (!this.isSupported()) {
                return;
            }
            if (!this.title) {
                throw new Error("Notify(): first arg (title) must be a string.");
            }
            //User defined options for notification content
            if (typeof options === "object") {
                for (var i in options) {
                    if (options.hasOwnProperty(i)) {
                        this.options[i] = options[i];
                    }
                }
                //callback when notification is displayed
                if (typeof this.options.notifyShow === "function") {
                    this.onShowCallback = this.options.notifyShow;
                }
                //callback when notification is closed
                if (typeof this.options.notifyClose === "function") {
                    this.onCloseCallback = this.options.notifyClose;
                }
                //callback when notification is clicked
                if (typeof this.options.notifyClick === "function") {
                    this.onClickCallback = this.options.notifyClick;
                }
                //callback when notification throws error
                if (typeof this.options.notifyError === "function") {
                    this.onErrorCallback = this.options.notifyError;
                }
                //callback user grants permission for notification
                if (typeof this.options.permissionGranted === "function") {
                    this.onPermissionGrantedCallback = this.options.permissionGranted;
                }
                //callback user denies permission for notification
                if (typeof this.options.permissionDenied === "function") {
                    this.onPermissionDeniedCallback = this.options.permissionDenied;
                }
            }
        }
        Notify.prototype.needsPermission = function() {
            if ("Notification" in w && Notification.permission === "granted") {
                return false;
            }
            // mozNotification requests permission automatically
            // so we don't need to handle that in the lib
            if ("mozNotification" in navigator) {
                return false;
            }
            return true;
        };
        Notify.prototype.requestPermission = function() {
            var that = this;
            w.Notification.requestPermission(function(perm) {
                that.permission = perm;
                switch (that.permission) {
                  case "granted":
                    that.onPermissionGranted();
                    break;

                  case "denied":
                    that.onPermissionDenied();
                    break;
                }
            });
        };
        Notify.prototype.show = function() {
            if (!this.isSupported()) {
                return;
            }
            if ("Notification" in w) {
                this.myNotify = new Notification(this.title, {
                    body: this.options.body,
                    tag: this.options.tag,
                    icon: this.options.icon
                });
                this.myNotify.addEventListener("show", this, false);
                this.myNotify.addEventListener("error", this, false);
            } else {
                this.myNotify = navigator.mozNotification.createNotification(this.title, this.options.body);
                this.myNotify.show();
            }
            this.myNotify.addEventListener("close", this, false);
            this.myNotify.addEventListener("click", this, false);
        };
        Notify.prototype.onShowNotification = function() {
            if (this.onShowCallback) {
                this.onShowCallback();
            }
        };
        Notify.prototype.onCloseNotification = function() {
            if (this.onCloseCallback) {
                this.onCloseCallback();
            }
            this.destroy();
        };
        Notify.prototype.onClickNotification = function() {
            if (this.onClickCallback) {
                this.onClickCallback();
            }
        };
        Notify.prototype.onErrorNotification = function() {
            if (this.onErrorCallback) {
                this.onErrorCallback();
            }
            this.destroy();
        };
        Notify.prototype.onPermissionGranted = function() {
            if (this.onPermissionGrantedCallback) {
                this.onPermissionGrantedCallback();
            }
        };
        Notify.prototype.onPermissionDenied = function() {
            if (this.onPermissionDeniedCallback) {
                this.onPermissionDeniedCallback();
            }
        };
        Notify.prototype.destroy = function() {
            if ("Notification" in w) {
                this.myNotify.removeEventListener("show", this, false);
                this.myNotify.removeEventListener("error", this, false);
            }
            this.myNotify.removeEventListener("close", this, false);
            this.myNotify.removeEventListener("click", this, false);
        };
        Notify.prototype.isSupported = function() {
            if ("Notification" in w || "mozNotification" in navigator) {
                return true;
            }
            return false;
        };
        Notify.prototype.handleEvent = function(e) {
            switch (e.type) {
              case "show":
                this.onShowNotification(e);
                break;

              case "close":
                this.onCloseNotification(e);
                break;

              case "click":
                this.onClickNotification(e);
                break;

              case "error":
                this.onErrorNotification(e);
                break;
            }
        };
        return Notify;
    });
}.bind(this));

require.register("app/vendor/oauthpopup.js", function(exports, require, module) {
    /*!
     * jQuery OAuth via popup window plugin
     *
     * @author  Nobu Funaki @nobuf
     *
     * Dual licensed under the MIT and GPL licenses:
     *   http://www.opensource.org/licenses/mit-license.php
     *   http://www.gnu.org/licenses/gpl.html
     */
    (function($) {
        //  inspired by DISQUS
        $.oauthpopup = function(options) {
            if (!options || !options.path) {
                throw new Error("options.path must not be empty");
            }
            options = $.extend({
                windowName: "ConnectWithOAuth",
                windowOptions: "location=0,status=0,width=800,height=400",
                callback: function() {
                    window.location.reload();
                }
            }, options);
            var oauthWindow = window.open(options.path, options.windowName, options.windowOptions);
            var oauthInterval = window.setInterval(function() {
                if (oauthWindow.closed) {
                    window.clearInterval(oauthInterval);
                    options.callback();
                }
            }, 1e3);
        };
        //bind to element and pop oauth when clicked
        $.fn.oauthpopup = function(options) {
            $this = $(this);
            $this.click($.oauthpopup.bind(this, options));
        };
    })(Zepto);
}.bind(this));

require.register("app/vendor/peer.js", function(exports, require, module) {
    /*! peerjs.js build:0.3.7, development. Copyright(c) 2013 Michelle Bu <michelle@michellebu.com> */
    (function(exports) {
        var binaryFeatures = {};
        binaryFeatures.useBlobBuilder = function() {
            try {
                new Blob([]);
                return false;
            } catch (e) {
                return true;
            }
        }();
        binaryFeatures.useArrayBufferView = !binaryFeatures.useBlobBuilder && function() {
            try {
                return new Blob([ new Uint8Array([]) ]).size === 0;
            } catch (e) {
                return true;
            }
        }();
        exports.binaryFeatures = binaryFeatures;
        exports.BlobBuilder = window.WebKitBlobBuilder || window.MozBlobBuilder || window.MSBlobBuilder || window.BlobBuilder;
        function BufferBuilder() {
            this._pieces = [];
            this._parts = [];
        }
        BufferBuilder.prototype.append = function(data) {
            if (typeof data === "number") {
                this._pieces.push(data);
            } else {
                this.flush();
                this._parts.push(data);
            }
        };
        BufferBuilder.prototype.flush = function() {
            if (this._pieces.length > 0) {
                var buf = new Uint8Array(this._pieces);
                if (!binaryFeatures.useArrayBufferView) {
                    buf = buf.buffer;
                }
                this._parts.push(buf);
                this._pieces = [];
            }
        };
        BufferBuilder.prototype.getBuffer = function() {
            this.flush();
            if (binaryFeatures.useBlobBuilder) {
                var builder = new BlobBuilder();
                for (var i = 0, ii = this._parts.length; i < ii; i++) {
                    builder.append(this._parts[i]);
                }
                return builder.getBlob();
            } else {
                return new Blob(this._parts);
            }
        };
        exports.BinaryPack = {
            unpack: function(data) {
                var unpacker = new Unpacker(data);
                return unpacker.unpack();
            },
            pack: function(data) {
                var packer = new Packer();
                packer.pack(data);
                var buffer = packer.getBuffer();
                return buffer;
            }
        };
        function Unpacker(data) {
            // Data is ArrayBuffer
            this.index = 0;
            this.dataBuffer = data;
            this.dataView = new Uint8Array(this.dataBuffer);
            this.length = this.dataBuffer.byteLength;
        }
        Unpacker.prototype.unpack = function() {
            var type = this.unpack_uint8();
            if (type < 128) {
                var positive_fixnum = type;
                return positive_fixnum;
            } else if ((type ^ 224) < 32) {
                var negative_fixnum = (type ^ 224) - 32;
                return negative_fixnum;
            }
            var size;
            if ((size = type ^ 160) <= 15) {
                return this.unpack_raw(size);
            } else if ((size = type ^ 176) <= 15) {
                return this.unpack_string(size);
            } else if ((size = type ^ 144) <= 15) {
                return this.unpack_array(size);
            } else if ((size = type ^ 128) <= 15) {
                return this.unpack_map(size);
            }
            switch (type) {
              case 192:
                return null;

              case 193:
                return undefined;

              case 194:
                return false;

              case 195:
                return true;

              case 202:
                return this.unpack_float();

              case 203:
                return this.unpack_double();

              case 204:
                return this.unpack_uint8();

              case 205:
                return this.unpack_uint16();

              case 206:
                return this.unpack_uint32();

              case 207:
                return this.unpack_uint64();

              case 208:
                return this.unpack_int8();

              case 209:
                return this.unpack_int16();

              case 210:
                return this.unpack_int32();

              case 211:
                return this.unpack_int64();

              case 212:
                return undefined;

              case 213:
                return undefined;

              case 214:
                return undefined;

              case 215:
                return undefined;

              case 216:
                size = this.unpack_uint16();
                return this.unpack_string(size);

              case 217:
                size = this.unpack_uint32();
                return this.unpack_string(size);

              case 218:
                size = this.unpack_uint16();
                return this.unpack_raw(size);

              case 219:
                size = this.unpack_uint32();
                return this.unpack_raw(size);

              case 220:
                size = this.unpack_uint16();
                return this.unpack_array(size);

              case 221:
                size = this.unpack_uint32();
                return this.unpack_array(size);

              case 222:
                size = this.unpack_uint16();
                return this.unpack_map(size);

              case 223:
                size = this.unpack_uint32();
                return this.unpack_map(size);
            }
        };
        Unpacker.prototype.unpack_uint8 = function() {
            var byte = this.dataView[this.index] & 255;
            this.index++;
            return byte;
        };
        Unpacker.prototype.unpack_uint16 = function() {
            var bytes = this.read(2);
            var uint16 = (bytes[0] & 255) * 256 + (bytes[1] & 255);
            this.index += 2;
            return uint16;
        };
        Unpacker.prototype.unpack_uint32 = function() {
            var bytes = this.read(4);
            var uint32 = ((bytes[0] * 256 + bytes[1]) * 256 + bytes[2]) * 256 + bytes[3];
            this.index += 4;
            return uint32;
        };
        Unpacker.prototype.unpack_uint64 = function() {
            var bytes = this.read(8);
            var uint64 = ((((((bytes[0] * 256 + bytes[1]) * 256 + bytes[2]) * 256 + bytes[3]) * 256 + bytes[4]) * 256 + bytes[5]) * 256 + bytes[6]) * 256 + bytes[7];
            this.index += 8;
            return uint64;
        };
        Unpacker.prototype.unpack_int8 = function() {
            var uint8 = this.unpack_uint8();
            return uint8 < 128 ? uint8 : uint8 - (1 << 8);
        };
        Unpacker.prototype.unpack_int16 = function() {
            var uint16 = this.unpack_uint16();
            return uint16 < 32768 ? uint16 : uint16 - (1 << 16);
        };
        Unpacker.prototype.unpack_int32 = function() {
            var uint32 = this.unpack_uint32();
            return uint32 < Math.pow(2, 31) ? uint32 : uint32 - Math.pow(2, 32);
        };
        Unpacker.prototype.unpack_int64 = function() {
            var uint64 = this.unpack_uint64();
            return uint64 < Math.pow(2, 63) ? uint64 : uint64 - Math.pow(2, 64);
        };
        Unpacker.prototype.unpack_raw = function(size) {
            if (this.length < this.index + size) {
                throw new Error("BinaryPackFailure: index is out of range" + " " + this.index + " " + size + " " + this.length);
            }
            var buf = this.dataBuffer.slice(this.index, this.index + size);
            this.index += size;
            //buf = util.bufferToString(buf);
            return buf;
        };
        Unpacker.prototype.unpack_string = function(size) {
            var bytes = this.read(size);
            var i = 0, str = "", c, code;
            while (i < size) {
                c = bytes[i];
                if (c < 128) {
                    str += String.fromCharCode(c);
                    i++;
                } else if ((c ^ 192) < 32) {
                    code = (c ^ 192) << 6 | bytes[i + 1] & 63;
                    str += String.fromCharCode(code);
                    i += 2;
                } else {
                    code = (c & 15) << 12 | (bytes[i + 1] & 63) << 6 | bytes[i + 2] & 63;
                    str += String.fromCharCode(code);
                    i += 3;
                }
            }
            this.index += size;
            return str;
        };
        Unpacker.prototype.unpack_array = function(size) {
            var objects = new Array(size);
            for (var i = 0; i < size; i++) {
                objects[i] = this.unpack();
            }
            return objects;
        };
        Unpacker.prototype.unpack_map = function(size) {
            var map = {};
            for (var i = 0; i < size; i++) {
                var key = this.unpack();
                var value = this.unpack();
                map[key] = value;
            }
            return map;
        };
        Unpacker.prototype.unpack_float = function() {
            var uint32 = this.unpack_uint32();
            var sign = uint32 >> 31;
            var exp = (uint32 >> 23 & 255) - 127;
            var fraction = uint32 & 8388607 | 8388608;
            return (sign == 0 ? 1 : -1) * fraction * Math.pow(2, exp - 23);
        };
        Unpacker.prototype.unpack_double = function() {
            var h32 = this.unpack_uint32();
            var l32 = this.unpack_uint32();
            var sign = h32 >> 31;
            var exp = (h32 >> 20 & 2047) - 1023;
            var hfrac = h32 & 1048575 | 1048576;
            var frac = hfrac * Math.pow(2, exp - 20) + l32 * Math.pow(2, exp - 52);
            return (sign == 0 ? 1 : -1) * frac;
        };
        Unpacker.prototype.read = function(length) {
            var j = this.index;
            if (j + length <= this.length) {
                return this.dataView.subarray(j, j + length);
            } else {
                throw new Error("BinaryPackFailure: read index out of range");
            }
        };
        function Packer() {
            this.bufferBuilder = new BufferBuilder();
        }
        Packer.prototype.getBuffer = function() {
            return this.bufferBuilder.getBuffer();
        };
        Packer.prototype.pack = function(value) {
            var type = typeof value;
            if (type == "string") {
                this.pack_string(value);
            } else if (type == "number") {
                if (Math.floor(value) === value) {
                    this.pack_integer(value);
                } else {
                    this.pack_double(value);
                }
            } else if (type == "boolean") {
                if (value === true) {
                    this.bufferBuilder.append(195);
                } else if (value === false) {
                    this.bufferBuilder.append(194);
                }
            } else if (type == "undefined") {
                this.bufferBuilder.append(192);
            } else if (type == "object") {
                if (value === null) {
                    this.bufferBuilder.append(192);
                } else {
                    var constructor = value.constructor;
                    if (constructor == Array) {
                        this.pack_array(value);
                    } else if (constructor == Blob || constructor == File) {
                        this.pack_bin(value);
                    } else if (constructor == ArrayBuffer) {
                        if (binaryFeatures.useArrayBufferView) {
                            this.pack_bin(new Uint8Array(value));
                        } else {
                            this.pack_bin(value);
                        }
                    } else if ("BYTES_PER_ELEMENT" in value) {
                        if (binaryFeatures.useArrayBufferView) {
                            this.pack_bin(new Uint8Array(value.buffer));
                        } else {
                            this.pack_bin(value.buffer);
                        }
                    } else if (constructor == Object) {
                        this.pack_object(value);
                    } else if (constructor == Date) {
                        this.pack_string(value.toString());
                    } else if (typeof value.toBinaryPack == "function") {
                        this.bufferBuilder.append(value.toBinaryPack());
                    } else {
                        throw new Error('Type "' + constructor.toString() + '" not yet supported');
                    }
                }
            } else {
                throw new Error('Type "' + type + '" not yet supported');
            }
            this.bufferBuilder.flush();
        };
        Packer.prototype.pack_bin = function(blob) {
            var length = blob.length || blob.byteLength || blob.size;
            if (length <= 15) {
                this.pack_uint8(160 + length);
            } else if (length <= 65535) {
                this.bufferBuilder.append(218);
                this.pack_uint16(length);
            } else if (length <= 4294967295) {
                this.bufferBuilder.append(219);
                this.pack_uint32(length);
            } else {
                throw new Error("Invalid length");
                return;
            }
            this.bufferBuilder.append(blob);
        };
        Packer.prototype.pack_string = function(str) {
            var length = utf8Length(str);
            if (length <= 15) {
                this.pack_uint8(176 + length);
            } else if (length <= 65535) {
                this.bufferBuilder.append(216);
                this.pack_uint16(length);
            } else if (length <= 4294967295) {
                this.bufferBuilder.append(217);
                this.pack_uint32(length);
            } else {
                throw new Error("Invalid length");
                return;
            }
            this.bufferBuilder.append(str);
        };
        Packer.prototype.pack_array = function(ary) {
            var length = ary.length;
            if (length <= 15) {
                this.pack_uint8(144 + length);
            } else if (length <= 65535) {
                this.bufferBuilder.append(220);
                this.pack_uint16(length);
            } else if (length <= 4294967295) {
                this.bufferBuilder.append(221);
                this.pack_uint32(length);
            } else {
                throw new Error("Invalid length");
            }
            for (var i = 0; i < length; i++) {
                this.pack(ary[i]);
            }
        };
        Packer.prototype.pack_integer = function(num) {
            if (-32 <= num && num <= 127) {
                this.bufferBuilder.append(num & 255);
            } else if (0 <= num && num <= 255) {
                this.bufferBuilder.append(204);
                this.pack_uint8(num);
            } else if (-128 <= num && num <= 127) {
                this.bufferBuilder.append(208);
                this.pack_int8(num);
            } else if (0 <= num && num <= 65535) {
                this.bufferBuilder.append(205);
                this.pack_uint16(num);
            } else if (-32768 <= num && num <= 32767) {
                this.bufferBuilder.append(209);
                this.pack_int16(num);
            } else if (0 <= num && num <= 4294967295) {
                this.bufferBuilder.append(206);
                this.pack_uint32(num);
            } else if (-2147483648 <= num && num <= 2147483647) {
                this.bufferBuilder.append(210);
                this.pack_int32(num);
            } else if (-0x8000000000000000 <= num && num <= 0x8000000000000000) {
                this.bufferBuilder.append(211);
                this.pack_int64(num);
            } else if (0 <= num && num <= 0x10000000000000000) {
                this.bufferBuilder.append(207);
                this.pack_uint64(num);
            } else {
                throw new Error("Invalid integer");
            }
        };
        Packer.prototype.pack_double = function(num) {
            var sign = 0;
            if (num < 0) {
                sign = 1;
                num = -num;
            }
            var exp = Math.floor(Math.log(num) / Math.LN2);
            var frac0 = num / Math.pow(2, exp) - 1;
            var frac1 = Math.floor(frac0 * Math.pow(2, 52));
            var b32 = Math.pow(2, 32);
            var h32 = sign << 31 | exp + 1023 << 20 | frac1 / b32 & 1048575;
            var l32 = frac1 % b32;
            this.bufferBuilder.append(203);
            this.pack_int32(h32);
            this.pack_int32(l32);
        };
        Packer.prototype.pack_object = function(obj) {
            var keys = Object.keys(obj);
            var length = keys.length;
            if (length <= 15) {
                this.pack_uint8(128 + length);
            } else if (length <= 65535) {
                this.bufferBuilder.append(222);
                this.pack_uint16(length);
            } else if (length <= 4294967295) {
                this.bufferBuilder.append(223);
                this.pack_uint32(length);
            } else {
                throw new Error("Invalid length");
            }
            for (var prop in obj) {
                if (obj.hasOwnProperty(prop)) {
                    this.pack(prop);
                    this.pack(obj[prop]);
                }
            }
        };
        Packer.prototype.pack_uint8 = function(num) {
            this.bufferBuilder.append(num);
        };
        Packer.prototype.pack_uint16 = function(num) {
            this.bufferBuilder.append(num >> 8);
            this.bufferBuilder.append(num & 255);
        };
        Packer.prototype.pack_uint32 = function(num) {
            var n = num & 4294967295;
            this.bufferBuilder.append((n & 4278190080) >>> 24);
            this.bufferBuilder.append((n & 16711680) >>> 16);
            this.bufferBuilder.append((n & 65280) >>> 8);
            this.bufferBuilder.append(n & 255);
        };
        Packer.prototype.pack_uint64 = function(num) {
            var high = num / Math.pow(2, 32);
            var low = num % Math.pow(2, 32);
            this.bufferBuilder.append((high & 4278190080) >>> 24);
            this.bufferBuilder.append((high & 16711680) >>> 16);
            this.bufferBuilder.append((high & 65280) >>> 8);
            this.bufferBuilder.append(high & 255);
            this.bufferBuilder.append((low & 4278190080) >>> 24);
            this.bufferBuilder.append((low & 16711680) >>> 16);
            this.bufferBuilder.append((low & 65280) >>> 8);
            this.bufferBuilder.append(low & 255);
        };
        Packer.prototype.pack_int8 = function(num) {
            this.bufferBuilder.append(num & 255);
        };
        Packer.prototype.pack_int16 = function(num) {
            this.bufferBuilder.append((num & 65280) >> 8);
            this.bufferBuilder.append(num & 255);
        };
        Packer.prototype.pack_int32 = function(num) {
            this.bufferBuilder.append(num >>> 24 & 255);
            this.bufferBuilder.append((num & 16711680) >>> 16);
            this.bufferBuilder.append((num & 65280) >>> 8);
            this.bufferBuilder.append(num & 255);
        };
        Packer.prototype.pack_int64 = function(num) {
            var high = Math.floor(num / Math.pow(2, 32));
            var low = num % Math.pow(2, 32);
            this.bufferBuilder.append((high & 4278190080) >>> 24);
            this.bufferBuilder.append((high & 16711680) >>> 16);
            this.bufferBuilder.append((high & 65280) >>> 8);
            this.bufferBuilder.append(high & 255);
            this.bufferBuilder.append((low & 4278190080) >>> 24);
            this.bufferBuilder.append((low & 16711680) >>> 16);
            this.bufferBuilder.append((low & 65280) >>> 8);
            this.bufferBuilder.append(low & 255);
        };
        function _utf8Replace(m) {
            var code = m.charCodeAt(0);
            if (code <= 2047) return "00";
            if (code <= 65535) return "000";
            if (code <= 2097151) return "0000";
            if (code <= 67108863) return "00000";
            return "000000";
        }
        function utf8Length(str) {
            if (str.length > 600) {
                // Blob method faster for large strings
                return new Blob([ str ]).size;
            } else {
                return str.replace(/[^\u0000-\u007F]/g, _utf8Replace).length;
            }
        }
        /**
     * Light EventEmitter. Ported from Node.js/events.js
     * Eric Zhang
     */
        /**
     * EventEmitter class
     * Creates an object with event registering and firing methods
     */
        function EventEmitter() {
            // Initialise required storage variables
            this._events = {};
        }
        var isArray = Array.isArray;
        EventEmitter.prototype.addListener = function(type, listener, scope, once) {
            if ("function" !== typeof listener) {
                throw new Error("addListener only takes instances of Function");
            }
            // To avoid recursion in the case that type == "newListeners"! Before
            // adding it to the listeners, first emit "newListeners".
            this.emit("newListener", type, typeof listener.listener === "function" ? listener.listener : listener);
            if (!this._events[type]) {
                // Optimize the case of one listener. Don't need the extra array object.
                this._events[type] = listener;
            } else if (isArray(this._events[type])) {
                // If we've already got an array, just append.
                this._events[type].push(listener);
            } else {
                // Adding the second element, need to change to array.
                this._events[type] = [ this._events[type], listener ];
            }
            return this;
        };
        EventEmitter.prototype.on = EventEmitter.prototype.addListener;
        EventEmitter.prototype.once = function(type, listener, scope) {
            if ("function" !== typeof listener) {
                throw new Error(".once only takes instances of Function");
            }
            var self = this;
            function g() {
                self.removeListener(type, g);
                listener.apply(this, arguments);
            }
            g.listener = listener;
            self.on(type, g);
            return this;
        };
        EventEmitter.prototype.removeListener = function(type, listener, scope) {
            if ("function" !== typeof listener) {
                throw new Error("removeListener only takes instances of Function");
            }
            // does not use listeners(), so no side effect of creating _events[type]
            if (!this._events[type]) return this;
            var list = this._events[type];
            if (isArray(list)) {
                var position = -1;
                for (var i = 0, length = list.length; i < length; i++) {
                    if (list[i] === listener || list[i].listener && list[i].listener === listener) {
                        position = i;
                        break;
                    }
                }
                if (position < 0) return this;
                list.splice(position, 1);
                if (list.length == 0) delete this._events[type];
            } else if (list === listener || list.listener && list.listener === listener) {
                delete this._events[type];
            }
            return this;
        };
        EventEmitter.prototype.off = EventEmitter.prototype.removeListener;
        EventEmitter.prototype.removeAllListeners = function(type) {
            if (arguments.length === 0) {
                this._events = {};
                return this;
            }
            // does not use listeners(), so no side effect of creating _events[type]
            if (type && this._events && this._events[type]) this._events[type] = null;
            return this;
        };
        EventEmitter.prototype.listeners = function(type) {
            if (!this._events[type]) this._events[type] = [];
            if (!isArray(this._events[type])) {
                this._events[type] = [ this._events[type] ];
            }
            return this._events[type];
        };
        EventEmitter.prototype.emit = function(type) {
            var type = arguments[0];
            var handler = this._events[type];
            if (!handler) return false;
            if (typeof handler == "function") {
                switch (arguments.length) {
                  // fast cases
                    case 1:
                    handler.call(this);
                    break;

                  case 2:
                    handler.call(this, arguments[1]);
                    break;

                  case 3:
                    handler.call(this, arguments[1], arguments[2]);
                    break;

                  // slower
                    default:
                    var l = arguments.length;
                    var args = new Array(l - 1);
                    for (var i = 1; i < l; i++) args[i - 1] = arguments[i];
                    handler.apply(this, args);
                }
                return true;
            } else if (isArray(handler)) {
                var l = arguments.length;
                var args = new Array(l - 1);
                for (var i = 1; i < l; i++) args[i - 1] = arguments[i];
                var listeners = handler.slice();
                for (var i = 0, l = listeners.length; i < l; i++) {
                    listeners[i].apply(this, args);
                }
                return true;
            } else {
                return false;
            }
        };
        /**
     * Reliable transfer for Chrome Canary DataChannel impl.
     * Author: @michellebu
     */
        function Reliable(dc, debug) {
            if (!(this instanceof Reliable)) return new Reliable(dc);
            this._dc = dc;
            util.debug = debug;
            // Messages sent/received so far.
            // id: { ack: n, chunks: [...] }
            this._outgoing = {};
            // id: { ack: ['ack', id, n], chunks: [...] }
            this._incoming = {};
            this._received = {};
            // Window size.
            this._window = 1e3;
            // MTU.
            this._mtu = 500;
            // Interval for setInterval. In ms.
            this._interval = 0;
            // Messages sent.
            this._count = 0;
            // Outgoing message queue.
            this._queue = [];
            this._setupDC();
        }
        // Send a message reliably.
        Reliable.prototype.send = function(msg) {
            // Determine if chunking is necessary.
            var bl = util.pack(msg);
            if (bl.size < this._mtu) {
                this._handleSend([ "no", bl ]);
                return;
            }
            this._outgoing[this._count] = {
                ack: 0,
                chunks: this._chunk(bl)
            };
            if (util.debug) {
                this._outgoing[this._count].timer = new Date();
            }
            // Send prelim window.
            this._sendWindowedChunks(this._count);
            this._count += 1;
        };
        // Set up interval for processing queue.
        Reliable.prototype._setupInterval = function() {
            // TODO: fail gracefully.
            var self = this;
            this._timeout = setInterval(function() {
                // FIXME: String stuff makes things terribly async.
                var msg = self._queue.shift();
                if (msg._multiple) {
                    for (var i = 0, ii = msg.length; i < ii; i += 1) {
                        self._intervalSend(msg[i]);
                    }
                } else {
                    self._intervalSend(msg);
                }
            }, this._interval);
        };
        Reliable.prototype._intervalSend = function(msg) {
            var self = this;
            msg = util.pack(msg);
            util.blobToBinaryString(msg, function(str) {
                self._dc.send(str);
            });
            if (self._queue.length === 0) {
                clearTimeout(self._timeout);
                self._timeout = null;
            }
        };
        // Go through ACKs to send missing pieces.
        Reliable.prototype._processAcks = function() {
            for (var id in this._outgoing) {
                if (this._outgoing.hasOwnProperty(id)) {
                    this._sendWindowedChunks(id);
                }
            }
        };
        // Handle sending a message.
        // FIXME: Don't wait for interval time for all messages...
        Reliable.prototype._handleSend = function(msg) {
            var push = true;
            for (var i = 0, ii = this._queue.length; i < ii; i += 1) {
                var item = this._queue[i];
                if (item === msg) {
                    push = false;
                } else if (item._multiple && item.indexOf(msg) !== -1) {
                    push = false;
                }
            }
            if (push) {
                this._queue.push(msg);
                if (!this._timeout) {
                    this._setupInterval();
                }
            }
        };
        // Set up DataChannel handlers.
        Reliable.prototype._setupDC = function() {
            // Handle various message types.
            var self = this;
            this._dc.onmessage = function(e) {
                var msg = e.data;
                var datatype = msg.constructor;
                // FIXME: msg is String until binary is supported.
                // Once that happens, this will have to be smarter.
                if (datatype === String) {
                    var ab = util.binaryStringToArrayBuffer(msg);
                    msg = util.unpack(ab);
                    self._handleMessage(msg);
                }
            };
        };
        // Handles an incoming message.
        Reliable.prototype._handleMessage = function(msg) {
            var id = msg[1];
            var idata = this._incoming[id];
            var odata = this._outgoing[id];
            var data;
            switch (msg[0]) {
              // No chunking was done.
                case "no":
                var message = id;
                if (!!message) {
                    this.onmessage(util.unpack(message));
                }
                break;

              // Reached the end of the message.
                case "end":
                data = idata;
                // In case end comes first.
                this._received[id] = msg[2];
                if (!data) {
                    break;
                }
                this._ack(id);
                break;

              case "ack":
                data = odata;
                if (!!data) {
                    var ack = msg[2];
                    // Take the larger ACK, for out of order messages.
                    data.ack = Math.max(ack, data.ack);
                    // Clean up when all chunks are ACKed.
                    if (data.ack >= data.chunks.length) {
                        util.log("Time: ", new Date() - data.timer);
                        delete this._outgoing[id];
                    } else {
                        this._processAcks();
                    }
                }
                // If !data, just ignore.
                break;

              // Received a chunk of data.
                case "chunk":
                // Create a new entry if none exists.
                data = idata;
                if (!data) {
                    var end = this._received[id];
                    if (end === true) {
                        break;
                    }
                    data = {
                        ack: [ "ack", id, 0 ],
                        chunks: []
                    };
                    this._incoming[id] = data;
                }
                var n = msg[2];
                var chunk = msg[3];
                data.chunks[n] = new Uint8Array(chunk);
                // If we get the chunk we're looking for, ACK for next missing.
                // Otherwise, ACK the same N again.
                if (n === data.ack[2]) {
                    this._calculateNextAck(id);
                }
                this._ack(id);
                break;

              default:
                // Shouldn't happen, but would make sense for message to just go
                // through as is.
                this._handleSend(msg);
                break;
            }
        };
        // Chunks BL into smaller messages.
        Reliable.prototype._chunk = function(bl) {
            var chunks = [];
            var size = bl.size;
            var start = 0;
            while (start < size) {
                var end = Math.min(size, start + this._mtu);
                var b = bl.slice(start, end);
                var chunk = {
                    payload: b
                };
                chunks.push(chunk);
                start = end;
            }
            util.log("Created", chunks.length, "chunks.");
            return chunks;
        };
        // Sends ACK N, expecting Nth blob chunk for message ID.
        Reliable.prototype._ack = function(id) {
            var ack = this._incoming[id].ack;
            // if ack is the end value, then call _complete.
            if (this._received[id] === ack[2]) {
                this._complete(id);
                this._received[id] = true;
            }
            this._handleSend(ack);
        };
        // Calculates the next ACK number, given chunks.
        Reliable.prototype._calculateNextAck = function(id) {
            var data = this._incoming[id];
            var chunks = data.chunks;
            for (var i = 0, ii = chunks.length; i < ii; i += 1) {
                // This chunk is missing!!! Better ACK for it.
                if (chunks[i] === undefined) {
                    data.ack[2] = i;
                    return;
                }
            }
            data.ack[2] = chunks.length;
        };
        // Sends the next window of chunks.
        Reliable.prototype._sendWindowedChunks = function(id) {
            util.log("sendWindowedChunks for: ", id);
            var data = this._outgoing[id];
            var ch = data.chunks;
            var chunks = [];
            var limit = Math.min(data.ack + this._window, ch.length);
            for (var i = data.ack; i < limit; i += 1) {
                if (!ch[i].sent || i === data.ack) {
                    ch[i].sent = true;
                    chunks.push([ "chunk", id, i, ch[i].payload ]);
                }
            }
            if (data.ack + this._window >= ch.length) {
                chunks.push([ "end", id, ch.length ]);
            }
            chunks._multiple = true;
            this._handleSend(chunks);
        };
        // Puts together a message from chunks.
        Reliable.prototype._complete = function(id) {
            util.log("Completed called for", id);
            var self = this;
            var chunks = this._incoming[id].chunks;
            var bl = new Blob(chunks);
            util.blobToArrayBuffer(bl, function(ab) {
                self.onmessage(util.unpack(ab));
            });
            delete this._incoming[id];
        };
        // Ups bandwidth limit on SDP. Meant to be called during offer/answer.
        Reliable.higherBandwidthSDP = function(sdp) {
            // AS stands for Application-Specific Maximum.
            // Bandwidth number is in kilobits / sec.
            // See RFC for more info: http://www.ietf.org/rfc/rfc2327.txt
            // Chrome 31+ doesn't want us munging the SDP, so we'll let them have their
            // way.
            var version = navigator.appVersion.match(/Chrome\/(.*?) /);
            if (version) {
                version = parseInt(version[1].split(".").shift());
                if (version < 31) {
                    var parts = sdp.split("b=AS:30");
                    var replace = "b=AS:102400";
                    // 100 Mbps
                    if (parts.length > 1) {
                        return parts[0] + replace + parts[1];
                    }
                }
            }
            return sdp;
        };
        // Overwritten, typically.
        Reliable.prototype.onmessage = function(msg) {};
        exports.Reliable = Reliable;
        exports.RTCSessionDescription = window.mozRTCSessionDescription || window.RTCSessionDescription;
        exports.RTCPeerConnection = window.mozRTCPeerConnection || window.webkitRTCPeerConnection || window.RTCPeerConnection;
        exports.RTCIceCandidate = window.mozRTCIceCandidate || window.RTCIceCandidate;
        var defaultConfig = {
            iceServers: [ {
                url: "stun:stun.l.google.com:19302"
            } ]
        };
        var dataCount = 1;
        var util = {
            noop: function() {},
            CLOUD_HOST: "0.peerjs.com",
            CLOUD_PORT: 9e3,
            // Browsers that need chunking:
            chunkedBrowsers: {
                Chrome: 1
            },
            chunkedMTU: 16300,
            // The original 60000 bytes setting does not work when sending data from Firefox to Chrome, which is "cut off" after 16384 bytes and delivered individually.
            // Logging logic
            logLevel: 0,
            setLogLevel: function(level) {
                var debugLevel = parseInt(level, 10);
                if (!isNaN(parseInt(level, 10))) {
                    util.logLevel = debugLevel;
                } else {
                    // If they are using truthy/falsy values for debug
                    util.logLevel = level ? 3 : 0;
                }
                util.log = util.warn = util.error = util.noop;
                if (util.logLevel > 0) {
                    util.error = util._printWith("ERROR");
                }
                if (util.logLevel > 1) {
                    util.warn = util._printWith("WARNING");
                }
                if (util.logLevel > 2) {
                    util.log = util._print;
                }
            },
            setLogFunction: function(fn) {
                if (fn.constructor !== Function) {
                    util.warn("The log function you passed in is not a function. Defaulting to regular logs.");
                } else {
                    util._print = fn;
                }
            },
            _printWith: function(prefix) {
                return function() {
                    var copy = Array.prototype.slice.call(arguments);
                    copy.unshift(prefix);
                    util._print.apply(util, copy);
                };
            },
            _print: function() {
                var err = false;
                var copy = Array.prototype.slice.call(arguments);
                copy.unshift("PeerJS: ");
                for (var i = 0, l = copy.length; i < l; i++) {
                    if (copy[i] instanceof Error) {
                        copy[i] = "(" + copy[i].name + ") " + copy[i].message;
                        err = true;
                    }
                }
                err ? console.error.apply(console, copy) : console.log.apply(console, copy);
            },
            //
            // Returns browser-agnostic default config
            defaultConfig: defaultConfig,
            //
            // Returns the current browser.
            browser: function() {
                if (window.mozRTCPeerConnection) {
                    return "Firefox";
                } else if (window.webkitRTCPeerConnection) {
                    return "Chrome";
                } else if (window.RTCPeerConnection) {
                    return "Supported";
                } else {
                    return "Unsupported";
                }
            }(),
            //
            // Lists which features are supported
            supports: function() {
                if (typeof RTCPeerConnection === "undefined") {
                    return {};
                }
                var data = true;
                var audioVideo = true;
                var binaryBlob = false;
                var sctp = false;
                var onnegotiationneeded = !!window.webkitRTCPeerConnection;
                var pc, dc;
                try {
                    pc = new RTCPeerConnection(defaultConfig, {
                        optional: [ {
                            RtpDataChannels: true
                        } ]
                    });
                } catch (e) {
                    data = false;
                    audioVideo = false;
                }
                if (data) {
                    try {
                        dc = pc.createDataChannel("_PEERJSTEST");
                    } catch (e) {
                        data = false;
                    }
                }
                if (data) {
                    // Binary test
                    try {
                        dc.binaryType = "blob";
                        binaryBlob = true;
                    } catch (e) {}
                    // Reliable test.
                    // Unfortunately Chrome is a bit unreliable about whether or not they
                    // support reliable.
                    var reliablePC = new RTCPeerConnection(defaultConfig, {});
                    try {
                        var reliableDC = reliablePC.createDataChannel("_PEERJSRELIABLETEST", {});
                        sctp = reliableDC.reliable;
                    } catch (e) {}
                    reliablePC.close();
                }
                // FIXME: not really the best check...
                if (audioVideo) {
                    audioVideo = !!pc.addStream;
                }
                // FIXME: this is not great because in theory it doesn't work for
                // av-only browsers (?).
                if (!onnegotiationneeded && data) {
                    // sync default check.
                    var negotiationPC = new RTCPeerConnection(defaultConfig, {
                        optional: [ {
                            RtpDataChannels: true
                        } ]
                    });
                    negotiationPC.onnegotiationneeded = function() {
                        onnegotiationneeded = true;
                        // async check.
                        if (util && util.supports) {
                            util.supports.onnegotiationneeded = true;
                        }
                    };
                    var negotiationDC = negotiationPC.createDataChannel("_PEERJSNEGOTIATIONTEST");
                    setTimeout(function() {
                        negotiationPC.close();
                    }, 1e3);
                }
                if (pc) {
                    pc.close();
                }
                return {
                    audioVideo: audioVideo,
                    data: data,
                    binaryBlob: binaryBlob,
                    binary: sctp,
                    // deprecated; sctp implies binary support.
                    reliable: sctp,
                    // deprecated; sctp implies reliable data.
                    sctp: sctp,
                    onnegotiationneeded: onnegotiationneeded
                };
            }(),
            //
            // Ensure alphanumeric ids
            validateId: function(id) {
                // Allow empty ids
                return !id || /^[A-Za-z0-9]+(?:[ _-][A-Za-z0-9]+)*$/.exec(id);
            },
            validateKey: function(key) {
                // Allow empty keys
                return !key || /^[A-Za-z0-9]+(?:[ _-][A-Za-z0-9]+)*$/.exec(key);
            },
            debug: false,
            inherits: function(ctor, superCtor) {
                ctor.super_ = superCtor;
                ctor.prototype = Object.create(superCtor.prototype, {
                    constructor: {
                        value: ctor,
                        enumerable: false,
                        writable: true,
                        configurable: true
                    }
                });
            },
            extend: function(dest, source) {
                for (var key in source) {
                    if (source.hasOwnProperty(key)) {
                        dest[key] = source[key];
                    }
                }
                return dest;
            },
            pack: BinaryPack.pack,
            unpack: BinaryPack.unpack,
            log: function() {
                if (util.debug) {
                    var err = false;
                    var copy = Array.prototype.slice.call(arguments);
                    copy.unshift("PeerJS: ");
                    for (var i = 0, l = copy.length; i < l; i++) {
                        if (copy[i] instanceof Error) {
                            copy[i] = "(" + copy[i].name + ") " + copy[i].message;
                            err = true;
                        }
                    }
                    err ? console.error.apply(console, copy) : console.log.apply(console, copy);
                }
            },
            setZeroTimeout: function(global) {
                var timeouts = [];
                var messageName = "zero-timeout-message";
                // Like setTimeout, but only takes a function argument.	 There's
                // no time argument (always zero) and no arguments (you have to
                // use a closure).
                function setZeroTimeoutPostMessage(fn) {
                    timeouts.push(fn);
                    global.postMessage(messageName, "*");
                }
                function handleMessage(event) {
                    if (event.source == global && event.data == messageName) {
                        if (event.stopPropagation) {
                            event.stopPropagation();
                        }
                        if (timeouts.length) {
                            timeouts.shift()();
                        }
                    }
                }
                if (global.addEventListener) {
                    global.addEventListener("message", handleMessage, true);
                } else if (global.attachEvent) {
                    global.attachEvent("onmessage", handleMessage);
                }
                return setZeroTimeoutPostMessage;
            }(this),
            // Binary stuff
            // chunks a blob.
            chunk: function(bl) {
                var chunks = [];
                var size = bl.size;
                var start = index = 0;
                var total = Math.ceil(size / util.chunkedMTU);
                while (start < size) {
                    var end = Math.min(size, start + util.chunkedMTU);
                    var b = bl.slice(start, end);
                    var chunk = {
                        __peerData: dataCount,
                        n: index,
                        data: b,
                        total: total
                    };
                    chunks.push(chunk);
                    start = end;
                    index += 1;
                }
                dataCount += 1;
                return chunks;
            },
            blobToArrayBuffer: function(blob, cb) {
                var fr = new FileReader();
                fr.onload = function(evt) {
                    cb(evt.target.result);
                };
                fr.readAsArrayBuffer(blob);
            },
            blobToBinaryString: function(blob, cb) {
                var fr = new FileReader();
                fr.onload = function(evt) {
                    cb(evt.target.result);
                };
                fr.readAsBinaryString(blob);
            },
            binaryStringToArrayBuffer: function(binary) {
                var byteArray = new Uint8Array(binary.length);
                for (var i = 0; i < binary.length; i++) {
                    byteArray[i] = binary.charCodeAt(i) & 255;
                }
                return byteArray.buffer;
            },
            randomToken: function() {
                return Math.random().toString(36).substr(2);
            },
            //
            isSecure: function() {
                return location.protocol === "https:";
            }
        };
        exports.util = util;
        /**
     * A peer who can initiate connections with other peers.
     */
        function Peer(id, options) {
            if (!(this instanceof Peer)) return new Peer(id, options);
            EventEmitter.call(this);
            // Deal with overloading
            if (id && id.constructor == Object) {
                options = id;
                id = undefined;
            } else if (id) {
                // Ensure id is a string
                id = id.toString();
            }
            //
            // Configurize options
            options = util.extend({
                debug: 0,
                // 1: Errors, 2: Warnings, 3: All logs
                host: util.CLOUD_HOST,
                port: util.CLOUD_PORT,
                key: "peerjs",
                config: util.defaultConfig
            }, options);
            this.options = options;
            // Detect relative URL host.
            if (options.host === "/") {
                options.host = window.location.hostname;
            }
            // Set whether we use SSL to same as current host
            if (options.secure === undefined && options.host !== util.CLOUD_HOST) {
                options.secure = util.isSecure();
            }
            // Set a custom log function if present
            if (options.logFunction) {
                util.setLogFunction(options.logFunction);
            }
            util.setLogLevel(options.debug);
            //
            // Sanity checks
            // Ensure WebRTC supported
            if (!util.supports.audioVideo && !util.supports.data) {
                this._delayedAbort("browser-incompatible", "The current browser does not support WebRTC");
                return;
            }
            // Ensure alphanumeric id
            if (!util.validateId(id)) {
                this._delayedAbort("invalid-id", 'ID "' + id + '" is invalid');
                return;
            }
            // Ensure valid key
            if (!util.validateKey(options.key)) {
                this._delayedAbort("invalid-key", 'API KEY "' + options.key + '" is invalid');
                return;
            }
            // Ensure not using unsecure cloud server on SSL page
            if (options.secure && options.host === "0.peerjs.com") {
                this._delayedAbort("ssl-unavailable", "The cloud server currently does not support HTTPS. Please run your own PeerServer to use HTTPS.");
                return;
            }
            //
            // States.
            this.destroyed = false;
            // Connections have been killed
            this.disconnected = false;
            // Connection to PeerServer killed manually but P2P connections still active
            this.open = false;
            // Sockets and such are not yet open.
            //
            // References
            this.connections = {};
            // DataConnections for this peer.
            this._lostMessages = {};
            // src => [list of messages]
            //
            // Initialize the 'socket' (which is actually a mix of XHR streaming and
            // websockets.)
            var self = this;
            this.socket = new Socket(this.options.secure, this.options.host, this.options.port, this.options.key);
            this.socket.on("message", function(data) {
                self._handleMessage(data);
            });
            this.socket.on("error", function(error) {
                self._abort("socket-error", error);
            });
            this.socket.on("close", function() {
                if (!self.disconnected) {
                    // If we haven't explicitly disconnected, emit error.
                    self._abort("socket-closed", "Underlying socket is already closed.");
                }
            });
            //
            // Start the connections
            if (id) {
                this._initialize(id);
            } else {
                this._retrieveId();
            }
        }
        util.inherits(Peer, EventEmitter);
        /** Get a unique ID from the server via XHR. */
        Peer.prototype._retrieveId = function(cb) {
            var self = this;
            var http = new XMLHttpRequest();
            var protocol = this.options.secure ? "https://" : "http://";
            var url = protocol + this.options.host + ":" + this.options.port + "/" + this.options.key + "/id";
            var queryString = "?ts=" + new Date().getTime() + "" + Math.random();
            url += queryString;
            // If there's no ID we need to wait for one before trying to init socket.
            http.open("get", url, true);
            http.onerror = function(e) {
                util.error("Error retrieving ID", e);
                self._abort("server-error", "Could not get an ID from the server");
            };
            http.onreadystatechange = function() {
                if (http.readyState !== 4) {
                    return;
                }
                if (http.status !== 200) {
                    http.onerror();
                    return;
                }
                self._initialize(http.responseText);
            };
            http.send(null);
        };
        /** Initialize a connection with the server. */
        Peer.prototype._initialize = function(id) {
            var self = this;
            this.id = id;
            this.socket.start(this.id);
        };
        /** Handles messages from the server. */
        Peer.prototype._handleMessage = function(message) {
            var type = message.type;
            var payload = message.payload;
            var peer = message.src;
            switch (type) {
              case "OPEN":
                // The connection to the server is open.
                this.emit("open", this.id);
                this.open = true;
                break;

              case "ERROR":
                // Server error.
                this._abort("server-error", payload.msg);
                break;

              case "ID-TAKEN":
                // The selected ID is taken.
                this._abort("unavailable-id", "ID `" + this.id + "` is taken");
                break;

              case "INVALID-KEY":
                // The given API key cannot be found.
                this._abort("invalid-key", 'API KEY "' + this.options.key + '" is invalid');
                break;

              //
                case "LEAVE":
                // Another peer has closed its connection to this peer.
                util.log("Received leave message from", peer);
                this._cleanupPeer(peer);
                break;

              case "EXPIRE":
                // The offer sent to a peer has expired without response.
                this.emit("error", new Error("Could not connect to peer " + peer));
                break;

              case "OFFER":
                // we should consider switching this to CALL/CONNECT, but this is the least breaking option.
                var connectionId = payload.connectionId;
                var connection = this.getConnection(peer, connectionId);
                if (connection) {
                    util.warn("Offer received for existing Connection ID:", connectionId);
                } else {
                    // Create a new connection.
                    if (payload.type === "media") {
                        var connection = new MediaConnection(peer, this, {
                            connectionId: connectionId,
                            _payload: payload,
                            metadata: payload.metadata
                        });
                        this._addConnection(peer, connection);
                        this.emit("call", connection);
                    } else if (payload.type === "data") {
                        connection = new DataConnection(peer, this, {
                            connectionId: connectionId,
                            _payload: payload,
                            metadata: payload.metadata,
                            label: payload.label,
                            serialization: payload.serialization,
                            reliable: payload.reliable
                        });
                        this._addConnection(peer, connection);
                        this.emit("connection", connection);
                    } else {
                        util.warn("Received malformed connection type:", payload.type);
                        return;
                    }
                    // Find messages.
                    var messages = this._getMessages(connectionId);
                    for (var i = 0, ii = messages.length; i < ii; i += 1) {
                        connection.handleMessage(messages[i]);
                    }
                }
                break;

              default:
                if (!payload) {
                    util.warn("You received a malformed message from " + peer + " of type " + type);
                    return;
                }
                var id = payload.connectionId;
                var connection = this.getConnection(peer, id);
                if (connection && connection.pc) {
                    // Pass it on.
                    connection.handleMessage(message);
                } else if (id) {
                    // Store for possible later use
                    this._storeMessage(id, message);
                } else {
                    util.warn("You received an unrecognized message:", message);
                }
                break;
            }
        };
        /** Stores messages without a set up connection, to be claimed later. */
        Peer.prototype._storeMessage = function(connectionId, message) {
            if (!this._lostMessages[connectionId]) {
                this._lostMessages[connectionId] = [];
            }
            this._lostMessages[connectionId].push(message);
        };
        /** Retrieve messages from lost message store */
        Peer.prototype._getMessages = function(connectionId) {
            var messages = this._lostMessages[connectionId];
            if (messages) {
                delete this._lostMessages[connectionId];
                return messages;
            } else {
                return [];
            }
        };
        /**
     * Returns a DataConnection to the specified peer. See documentation for a
     * complete list of options.
     */
        Peer.prototype.connect = function(peer, options) {
            if (this.disconnected) {
                util.warn("You cannot connect to a new Peer because you called " + ".disconnect() on this Peer and ended your connection with the" + " server. You can create a new Peer to reconnect.");
                this.emit("error", new Error("Cannot connect to new Peer after disconnecting from server."));
                return;
            }
            var connection = new DataConnection(peer, this, options);
            this._addConnection(peer, connection);
            return connection;
        };
        /**
     * Returns a MediaConnection to the specified peer. See documentation for a
     * complete list of options.
     */
        Peer.prototype.call = function(peer, stream, options) {
            if (this.disconnected) {
                util.warn("You cannot connect to a new Peer because you called " + ".disconnect() on this Peer and ended your connection with the" + " server. You can create a new Peer to reconnect.");
                this.emit("error", new Error("Cannot connect to new Peer after disconnecting from server."));
                return;
            }
            if (!stream) {
                util.error("To call a peer, you must provide a stream from your browser's `getUserMedia`.");
                return;
            }
            options = options || {};
            options._stream = stream;
            var call = new MediaConnection(peer, this, options);
            this._addConnection(peer, call);
            return call;
        };
        /** Add a data/media connection to this peer. */
        Peer.prototype._addConnection = function(peer, connection) {
            if (!this.connections[peer]) {
                this.connections[peer] = [];
            }
            this.connections[peer].push(connection);
        };
        /** Retrieve a data/media connection for this peer. */
        Peer.prototype.getConnection = function(peer, id) {
            var connections = this.connections[peer];
            if (!connections) {
                return null;
            }
            for (var i = 0, ii = connections.length; i < ii; i++) {
                if (connections[i].id === id) {
                    return connections[i];
                }
            }
            return null;
        };
        Peer.prototype._delayedAbort = function(type, message) {
            var self = this;
            util.setZeroTimeout(function() {
                self._abort(type, message);
            });
        };
        /** Destroys the Peer and emits an error message. */
        Peer.prototype._abort = function(type, message) {
            util.error("Aborting. Error:", message);
            var err = new Error(message);
            err.type = type;
            this.destroy();
            this.emit("error", err);
        };
        /**
     * Destroys the Peer: closes all active connections as well as the connection
     *  to the server.
     * Warning: The peer can no longer create or accept connections after being
     *  destroyed.
     */
        Peer.prototype.destroy = function() {
            if (!this.destroyed) {
                this._cleanup();
                this.disconnect();
                this.destroyed = true;
            }
        };
        /** Disconnects every connection on this peer. */
        Peer.prototype._cleanup = function() {
            if (this.connections) {
                var peers = Object.keys(this.connections);
                for (var i = 0, ii = peers.length; i < ii; i++) {
                    this._cleanupPeer(peers[i]);
                }
            }
            this.emit("close");
        };
        /** Closes all connections to this peer. */
        Peer.prototype._cleanupPeer = function(peer) {
            var connections = this.connections[peer];
            for (var j = 0, jj = connections.length; j < jj; j += 1) {
                connections[j].close();
            }
        };
        /**
     * Disconnects the Peer's connection to the PeerServer. Does not close any
     *  active connections.
     * Warning: The peer can no longer create or accept connections after being
     *  disconnected. It also cannot reconnect to the server.
     */
        Peer.prototype.disconnect = function() {
            var self = this;
            util.setZeroTimeout(function() {
                if (!self.disconnected) {
                    self.disconnected = true;
                    self.open = false;
                    if (self.socket) {
                        self.socket.close();
                    }
                    self.id = null;
                }
            });
        };
        exports.Peer = Peer;
        /**
     * Wraps a DataChannel between two Peers.
     */
        function DataConnection(peer, provider, options) {
            if (!(this instanceof DataConnection)) return new DataConnection(peer, provider, options);
            EventEmitter.call(this);
            this.options = util.extend({
                serialization: "binary",
                reliable: false
            }, options);
            // Connection is not open yet.
            this.open = false;
            this.type = "data";
            this.peer = peer;
            this.provider = provider;
            this.id = this.options.connectionId || DataConnection._idPrefix + util.randomToken();
            this.label = this.options.label || this.id;
            this.metadata = this.options.metadata;
            this.serialization = this.options.serialization;
            this.reliable = this.options.reliable;
            // Data channel buffering.
            this._buffer = [];
            this._buffering = false;
            this.bufferSize = 0;
            // For storing large data.
            this._chunkedData = {};
            if (this.options._payload) {
                this._peerBrowser = this.options._payload.browser;
            }
            Negotiator.startConnection(this, this.options._payload || {
                originator: true
            });
        }
        util.inherits(DataConnection, EventEmitter);
        DataConnection._idPrefix = "dc_";
        /** Called by the Negotiator when the DataChannel is ready. */
        DataConnection.prototype.initialize = function(dc) {
            this._dc = this.dataChannel = dc;
            this._configureDataChannel();
        };
        DataConnection.prototype._configureDataChannel = function() {
            var self = this;
            if (util.supports.sctp) {
                this._dc.binaryType = "arraybuffer";
            }
            this._dc.onopen = function() {
                util.log("Data channel connection success");
                self.open = true;
                self.emit("open");
            };
            // Use the Reliable shim for non Firefox browsers
            if (!util.supports.sctp && this.reliable) {
                this._reliable = new Reliable(this._dc, util.debug);
            }
            if (this._reliable) {
                this._reliable.onmessage = function(msg) {
                    self.emit("data", msg);
                };
            } else {
                this._dc.onmessage = function(e) {
                    self._handleDataMessage(e);
                };
            }
            this._dc.onclose = function(e) {
                util.log("DataChannel closed for:", self.peer);
                self.close();
            };
        };
        // Handles a DataChannel message.
        DataConnection.prototype._handleDataMessage = function(e) {
            var self = this;
            var data = e.data;
            var datatype = data.constructor;
            if (this.serialization === "binary" || this.serialization === "binary-utf8") {
                if (datatype === Blob) {
                    // Datatype should never be blob
                    util.blobToArrayBuffer(data, function(ab) {
                        data = util.unpack(ab);
                        self.emit("data", data);
                    });
                    return;
                } else if (datatype === ArrayBuffer) {
                    data = util.unpack(data);
                } else if (datatype === String) {
                    // String fallback for binary data for browsers that don't support binary yet
                    var ab = util.binaryStringToArrayBuffer(data);
                    data = util.unpack(ab);
                }
            } else if (this.serialization === "json") {
                data = JSON.parse(data);
            }
            // Check if we've chunked--if so, piece things back together.
            // We're guaranteed that this isn't 0.
            if (data.__peerData) {
                var id = data.__peerData;
                var chunkInfo = this._chunkedData[id] || {
                    data: [],
                    count: 0,
                    total: data.total
                };
                chunkInfo.data[data.n] = data.data;
                chunkInfo.count += 1;
                if (chunkInfo.total === chunkInfo.count) {
                    // We've received all the chunks--time to construct the complete data.
                    data = new Blob(chunkInfo.data);
                    this._handleDataMessage({
                        data: data
                    });
                    // We can also just delete the chunks now.
                    delete this._chunkedData[id];
                }
                this._chunkedData[id] = chunkInfo;
                return;
            }
            this.emit("data", data);
        };
        /**
     * Exposed functionality for users.
     */
        /** Allows user to close connection. */
        DataConnection.prototype.close = function() {
            if (!this.open) {
                return;
            }
            this.open = false;
            Negotiator.cleanup(this);
            this.emit("close");
        };
        /** Allows user to send data. */
        DataConnection.prototype.send = function(data, chunked) {
            if (!this.open) {
                this.emit("error", new Error("Connection is not open. You should listen for the `open` event before sending messages."));
                return;
            }
            if (this._reliable) {
                // Note: reliable shim sending will make it so that you cannot customize
                // serialization.
                this._reliable.send(data);
                return;
            }
            var self = this;
            if (this.serialization === "json") {
                this._bufferedSend(JSON.stringify(data));
            } else if (this.serialization === "binary" || this.serialization === "binary-utf8") {
                var blob = util.pack(data);
                // For Chrome-Firefox interoperability, we need to make Firefox "chunk"
                // the data it sends out.
                var needsChunking = util.chunkedBrowsers[this._peerBrowser] || util.chunkedBrowsers[util.browser];
                if (needsChunking && !chunked && blob.size > util.chunkedMTU) {
                    this._sendChunks(blob);
                    return;
                }
                // DataChannel currently only supports strings.
                if (!util.supports.sctp) {
                    util.blobToBinaryString(blob, function(str) {
                        self._bufferedSend(str);
                    });
                } else if (!util.supports.binaryBlob) {
                    // We only do this if we really need to (e.g. blobs are not supported),
                    // because this conversion is costly.
                    util.blobToArrayBuffer(blob, function(ab) {
                        self._bufferedSend(ab);
                    });
                } else {
                    this._bufferedSend(blob);
                }
            } else {
                this._bufferedSend(data);
            }
        };
        DataConnection.prototype._bufferedSend = function(msg) {
            if (this._buffering || !this._trySend(msg)) {
                this._buffer.push(msg);
                this.bufferSize = this._buffer.length;
            }
        };
        // Returns true if the send succeeds.
        DataConnection.prototype._trySend = function(msg) {
            try {
                this._dc.send(msg);
            } catch (e) {
                this._buffering = true;
                var self = this;
                setTimeout(function() {
                    // Try again.
                    self._buffering = false;
                    self._tryBuffer();
                }, 100);
                return false;
            }
            return true;
        };
        // Try to send the first message in the buffer.
        DataConnection.prototype._tryBuffer = function() {
            if (this._buffer.length === 0) {
                return;
            }
            var msg = this._buffer[0];
            if (this._trySend(msg)) {
                this._buffer.shift();
                this.bufferSize = this._buffer.length;
                this._tryBuffer();
            }
        };
        DataConnection.prototype._sendChunks = function(blob) {
            var blobs = util.chunk(blob);
            for (var i = 0, ii = blobs.length; i < ii; i += 1) {
                var blob = blobs[i];
                this.send(blob, true);
            }
        };
        DataConnection.prototype.handleMessage = function(message) {
            var payload = message.payload;
            switch (message.type) {
              case "ANSWER":
                this._peerBrowser = payload.browser;
                // Forward to negotiator
                Negotiator.handleSDP(message.type, this, payload.sdp);
                break;

              case "CANDIDATE":
                Negotiator.handleCandidate(this, payload.candidate);
                break;

              default:
                util.warn("Unrecognized message type:", message.type, "from peer:", this.peer);
                break;
            }
        };
        /**
     * Wraps the streaming interface between two Peers.
     */
        function MediaConnection(peer, provider, options) {
            if (!(this instanceof MediaConnection)) return new MediaConnection(peer, provider, options);
            EventEmitter.call(this);
            this.options = util.extend({}, options);
            this.open = false;
            this.type = "media";
            this.peer = peer;
            this.provider = provider;
            this.metadata = this.options.metadata;
            this.localStream = this.options._stream;
            this.id = this.options.connectionId || MediaConnection._idPrefix + util.randomToken();
            if (this.localStream) {
                Negotiator.startConnection(this, {
                    _stream: this.localStream,
                    originator: true
                });
            }
        }
        util.inherits(MediaConnection, EventEmitter);
        MediaConnection._idPrefix = "mc_";
        MediaConnection.prototype.addStream = function(remoteStream) {
            util.log("Receiving stream", remoteStream);
            this.remoteStream = remoteStream;
            this.emit("stream", remoteStream);
        };
        MediaConnection.prototype.handleMessage = function(message) {
            var payload = message.payload;
            switch (message.type) {
              case "ANSWER":
                // Forward to negotiator
                Negotiator.handleSDP(message.type, this, payload.sdp);
                this.open = true;
                break;

              case "CANDIDATE":
                Negotiator.handleCandidate(this, payload.candidate);
                break;

              default:
                util.warn("Unrecognized message type:", message.type, "from peer:", this.peer);
                break;
            }
        };
        MediaConnection.prototype.answer = function(stream) {
            if (this.localStream) {
                util.warn("Local stream already exists on this MediaConnection. Are you answering a call twice?");
                return;
            }
            this.options._payload._stream = stream;
            this.localStream = stream;
            Negotiator.startConnection(this, this.options._payload);
            // Retrieve lost messages stored because PeerConnection not set up.
            var messages = this.provider._getMessages(this.id);
            for (var i = 0, ii = messages.length; i < ii; i += 1) {
                this.handleMessage(messages[i]);
            }
            this.open = true;
        };
        /**
     * Exposed functionality for users.
     */
        /** Allows user to close connection. */
        MediaConnection.prototype.close = function() {
            if (!this.open) {
                return;
            }
            this.open = false;
            Negotiator.cleanup(this);
            this.emit("close");
        };
        /**
     * Manages all negotiations between Peers.
     */
        var Negotiator = {
            pcs: {
                data: {},
                media: {}
            },
            // type => {peerId: {pc_id: pc}}.
            //providers: {}, // provider's id => providers (there may be multiple providers/client.
            queue: []
        };
        Negotiator._idPrefix = "pc_";
        /** Returns a PeerConnection object set up correctly (for data, media). */
        Negotiator.startConnection = function(connection, options) {
            var pc = Negotiator._getPeerConnection(connection, options);
            if (connection.type === "media" && options._stream) {
                // Add the stream.
                pc.addStream(options._stream);
            }
            // Set the connection's PC.
            connection.pc = pc;
            // What do we need to do now?
            if (options.originator) {
                if (connection.type === "data") {
                    // Create the datachannel.
                    var config = {};
                    // Dropping reliable:false support, since it seems to be crashing
                    // Chrome.
                    /*if (util.supports.sctp && !options.reliable) {
            // If we have canonical reliable support...
            config = {maxRetransmits: 0};
          }*/
                    // Fallback to ensure older browsers don't crash.
                    if (!util.supports.sctp) {
                        config = {
                            reliable: options.reliable
                        };
                    }
                    var dc = pc.createDataChannel(connection.label, config);
                    connection.initialize(dc);
                }
                if (!util.supports.onnegotiationneeded) {
                    Negotiator._makeOffer(connection);
                }
            } else {
                Negotiator.handleSDP("OFFER", connection, options.sdp);
            }
        };
        Negotiator._getPeerConnection = function(connection, options) {
            if (!Negotiator.pcs[connection.type]) {
                util.error(connection.type + " is not a valid connection type. Maybe you overrode the `type` property somewhere.");
            }
            if (!Negotiator.pcs[connection.type][connection.peer]) {
                Negotiator.pcs[connection.type][connection.peer] = {};
            }
            var peerConnections = Negotiator.pcs[connection.type][connection.peer];
            var pc;
            // Not multiplexing while FF and Chrome have not-great support for it.
            /*if (options.multiplex) {
        ids = Object.keys(peerConnections);
        for (var i = 0, ii = ids.length; i < ii; i += 1) {
          pc = peerConnections[ids[i]];
          if (pc.signalingState === 'stable') {
            break; // We can go ahead and use this PC.
          }
        }
      } else */
            if (options.pc) {
                // Simplest case: PC id already provided for us.
                pc = Negotiator.pcs[connection.type][connection.peer][options.pc];
            }
            if (!pc || pc.signalingState !== "stable") {
                pc = Negotiator._startPeerConnection(connection);
            }
            return pc;
        };
        /*
    Negotiator._addProvider = function(provider) {
      if ((!provider.id && !provider.disconnected) || !provider.socket.open) {
        // Wait for provider to obtain an ID.
        provider.on('open', function(id) {
          Negotiator._addProvider(provider);
        });
      } else {
        Negotiator.providers[provider.id] = provider;
      }
    }*/
        /** Start a PC. */
        Negotiator._startPeerConnection = function(connection) {
            util.log("Creating RTCPeerConnection.");
            var id = Negotiator._idPrefix + util.randomToken();
            var optional = {};
            if (connection.type === "data" && !util.supports.sctp) {
                optional = {
                    optional: [ {
                        RtpDataChannels: true
                    } ]
                };
            } else if (connection.type === "media") {
                // Interop req for chrome.
                optional = {
                    optional: [ {
                        DtlsSrtpKeyAgreement: true
                    } ]
                };
            }
            var pc = new RTCPeerConnection(connection.provider.options.config, optional);
            Negotiator.pcs[connection.type][connection.peer][id] = pc;
            Negotiator._setupListeners(connection, pc, id);
            return pc;
        };
        /** Set up various WebRTC listeners. */
        Negotiator._setupListeners = function(connection, pc, pc_id) {
            var peerId = connection.peer;
            var connectionId = connection.id;
            var provider = connection.provider;
            // ICE CANDIDATES.
            util.log("Listening for ICE candidates.");
            pc.onicecandidate = function(evt) {
                if (evt.candidate) {
                    util.log("Received ICE candidates for:", connection.peer);
                    provider.socket.send({
                        type: "CANDIDATE",
                        payload: {
                            candidate: evt.candidate,
                            type: connection.type,
                            connectionId: connection.id
                        },
                        dst: peerId
                    });
                }
            };
            pc.oniceconnectionstatechange = function() {
                switch (pc.iceConnectionState) {
                  case "disconnected":
                  case "failed":
                    util.log("iceConnectionState is disconnected, closing connections to " + peerId);
                    connection.close();
                    break;

                  case "completed":
                    pc.onicecandidate = util.noop;
                    break;
                }
            };
            // Fallback for older Chrome impls.
            pc.onicechange = pc.oniceconnectionstatechange;
            // ONNEGOTIATIONNEEDED (Chrome)
            util.log("Listening for `negotiationneeded`");
            pc.onnegotiationneeded = function() {
                util.log("`negotiationneeded` triggered");
                if (pc.signalingState == "stable") {
                    Negotiator._makeOffer(connection);
                } else {
                    util.log("onnegotiationneeded triggered when not stable. Is another connection being established?");
                }
            };
            // DATACONNECTION.
            util.log("Listening for data channel");
            // Fired between offer and answer, so options should already be saved
            // in the options hash.
            pc.ondatachannel = function(evt) {
                util.log("Received data channel");
                var dc = evt.channel;
                var connection = provider.getConnection(peerId, connectionId);
                connection.initialize(dc);
            };
            // MEDIACONNECTION.
            util.log("Listening for remote stream");
            pc.onaddstream = function(evt) {
                util.log("Received remote stream");
                var stream = evt.stream;
                provider.getConnection(peerId, connectionId).addStream(stream);
            };
        };
        Negotiator.cleanup = function(connection) {
            util.log("Cleaning up PeerConnection to " + connection.peer);
            var pc = connection.pc;
            if (!!pc && (pc.readyState !== "closed" || pc.signalingState !== "closed")) {
                pc.close();
                connection.pc = null;
            }
        };
        Negotiator._makeOffer = function(connection) {
            var pc = connection.pc;
            pc.createOffer(function(offer) {
                util.log("Created offer.");
                if (!util.supports.sctp && connection.type === "data" && connection.reliable) {
                    offer.sdp = Reliable.higherBandwidthSDP(offer.sdp);
                }
                pc.setLocalDescription(offer, function() {
                    util.log("Set localDescription: offer", "for:", connection.peer);
                    connection.provider.socket.send({
                        type: "OFFER",
                        payload: {
                            sdp: offer,
                            type: connection.type,
                            label: connection.label,
                            connectionId: connection.id,
                            reliable: connection.reliable,
                            serialization: connection.serialization,
                            metadata: connection.metadata,
                            browser: util.browser
                        },
                        dst: connection.peer
                    });
                }, function(err) {
                    connection.provider.emit("error", err);
                    util.log("Failed to setLocalDescription, ", err);
                });
            }, function(err) {
                connection.provider.emit("error", err);
                util.log("Failed to createOffer, ", err);
            }, connection.options.constraints);
        };
        Negotiator._makeAnswer = function(connection) {
            var pc = connection.pc;
            pc.createAnswer(function(answer) {
                util.log("Created answer.");
                if (!util.supports.sctp && connection.type === "data" && connection.reliable) {
                    answer.sdp = Reliable.higherBandwidthSDP(answer.sdp);
                }
                pc.setLocalDescription(answer, function() {
                    util.log("Set localDescription: answer", "for:", connection.peer);
                    connection.provider.socket.send({
                        type: "ANSWER",
                        payload: {
                            sdp: answer,
                            type: connection.type,
                            connectionId: connection.id,
                            browser: util.browser
                        },
                        dst: connection.peer
                    });
                }, function(err) {
                    connection.provider.emit("error", err);
                    util.log("Failed to setLocalDescription, ", err);
                });
            }, function(err) {
                connection.provider.emit("error", err);
                util.log("Failed to create answer, ", err);
            });
        };
        /** Handle an SDP. */
        Negotiator.handleSDP = function(type, connection, sdp) {
            sdp = new RTCSessionDescription(sdp);
            var pc = connection.pc;
            util.log("Setting remote description", sdp);
            pc.setRemoteDescription(sdp, function() {
                util.log("Set remoteDescription:", type, "for:", connection.peer);
                if (type === "OFFER") {
                    Negotiator._makeAnswer(connection);
                }
            }, function(err) {
                connection.provider.emit("error", err);
                util.log("Failed to setRemoteDescription, ", err);
            });
        };
        /** Handle a candidate. */
        Negotiator.handleCandidate = function(connection, ice) {
            var candidate = ice.candidate;
            var sdpMLineIndex = ice.sdpMLineIndex;
            connection.pc.addIceCandidate(new RTCIceCandidate({
                sdpMLineIndex: sdpMLineIndex,
                candidate: candidate
            }));
            util.log("Added ICE candidate for:", connection.peer);
        };
        /**
     * An abstraction on top of WebSockets and XHR streaming to provide fastest
     * possible connection for peers.
     */
        function Socket(secure, host, port, key) {
            if (!(this instanceof Socket)) return new Socket(secure, host, port, key);
            EventEmitter.call(this);
            // Disconnected manually.
            this.disconnected = false;
            this._queue = [];
            var httpProtocol = secure ? "https://" : "http://";
            var wsProtocol = secure ? "wss://" : "ws://";
            this._httpUrl = httpProtocol + host + ":" + port + "/" + key;
            this._wsUrl = wsProtocol + host + ":" + port + "/peerjs?key=" + key;
        }
        util.inherits(Socket, EventEmitter);
        /** Check in with ID or get one from server. */
        Socket.prototype.start = function(id) {
            this.id = id;
            var token = util.randomToken();
            this._httpUrl += "/" + id + "/" + token;
            this._wsUrl += "&id=" + id + "&token=" + token;
            this._startXhrStream();
            this._startWebSocket();
        };
        /** Start up websocket communications. */
        Socket.prototype._startWebSocket = function(id) {
            var self = this;
            if (this._socket) {
                return;
            }
            this._socket = new WebSocket(this._wsUrl);
            this._socket.onmessage = function(event) {
                var data;
                try {
                    data = JSON.parse(event.data);
                } catch (e) {
                    util.log("Invalid server message", event.data);
                    return;
                }
                self.emit("message", data);
            };
            // Take care of the queue of connections if necessary and make sure Peer knows
            // socket is open.
            this._socket.onopen = function() {
                if (self._timeout) {
                    clearTimeout(self._timeout);
                    setTimeout(function() {
                        self._http.abort();
                        self._http = null;
                    }, 5e3);
                }
                self._sendQueuedMessages();
                util.log("Socket open");
            };
        };
        /** Start XHR streaming. */
        Socket.prototype._startXhrStream = function(n) {
            try {
                var self = this;
                this._http = new XMLHttpRequest();
                this._http._index = 1;
                this._http._streamIndex = n || 0;
                this._http.open("post", this._httpUrl + "/id?i=" + this._http._streamIndex, true);
                this._http.onreadystatechange = function() {
                    if (this.readyState == 2 && this.old) {
                        this.old.abort();
                        delete this.old;
                    }
                    if (this.readyState > 2 && this.status == 200 && this.responseText) {
                        self._handleStream(this);
                    }
                };
                this._http.send(null);
                this._setHTTPTimeout();
            } catch (e) {
                util.log("XMLHttpRequest not available; defaulting to WebSockets");
            }
        };
        /** Handles onreadystatechange response as a stream. */
        Socket.prototype._handleStream = function(http) {
            // 3 and 4 are loading/done state. All others are not relevant.
            var messages = http.responseText.split("\n");
            // Check to see if anything needs to be processed on buffer.
            if (http._buffer) {
                while (http._buffer.length > 0) {
                    var index = http._buffer.shift();
                    var bufferedMessage = messages[index];
                    try {
                        bufferedMessage = JSON.parse(bufferedMessage);
                    } catch (e) {
                        http._buffer.shift(index);
                        break;
                    }
                    this.emit("message", bufferedMessage);
                }
            }
            var message = messages[http._index];
            if (message) {
                http._index += 1;
                // Buffering--this message is incomplete and we'll get to it next time.
                // This checks if the httpResponse ended in a `\n`, in which case the last
                // element of messages should be the empty string.
                if (http._index === messages.length) {
                    if (!http._buffer) {
                        http._buffer = [];
                    }
                    http._buffer.push(http._index - 1);
                } else {
                    try {
                        message = JSON.parse(message);
                    } catch (e) {
                        util.log("Invalid server message", message);
                        return;
                    }
                    this.emit("message", message);
                }
            }
        };
        Socket.prototype._setHTTPTimeout = function() {
            var self = this;
            this._timeout = setTimeout(function() {
                var old = self._http;
                if (!self._wsOpen()) {
                    self._startXhrStream(old._streamIndex + 1);
                    self._http.old = old;
                } else {
                    old.abort();
                }
            }, 25e3);
        };
        /** Is the websocket currently open? */
        Socket.prototype._wsOpen = function() {
            return this._socket && this._socket.readyState == 1;
        };
        /** Send queued messages. */
        Socket.prototype._sendQueuedMessages = function() {
            for (var i = 0, ii = this._queue.length; i < ii; i += 1) {
                this.send(this._queue[i]);
            }
        };
        /** Exposed send for DC & Peer. */
        Socket.prototype.send = function(data) {
            if (this.disconnected) {
                return;
            }
            // If we didn't get an ID yet, we can't yet send anything so we should queue
            // up these messages.
            if (!this.id) {
                this._queue.push(data);
                return;
            }
            if (!data.type) {
                this.emit("error", "Invalid message");
                return;
            }
            var message = JSON.stringify(data);
            if (this._wsOpen()) {
                this._socket.send(message);
            } else {
                var http = new XMLHttpRequest();
                var url = this._httpUrl + "/" + data.type.toLowerCase();
                http.open("post", url, true);
                http.setRequestHeader("Content-Type", "application/json");
                http.send(message);
            }
        };
        Socket.prototype.close = function() {
            if (!this.disconnected && this._wsOpen()) {
                this._socket.close();
                this.disconnected = true;
            }
        };
    }).bind(this)(this);
}.bind(this));

require.register("app/vendor/underscore.js", function(exports, require, module) {
    //     Underscore.js 1.6.0
    //     http://underscorejs.org
    //     (c) 2009-2014 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
    //     Underscore may be freely distributed under the MIT license.
    (function() {
        // Baseline setup
        // --------------
        // Establish the root object, `window` in the browser, or `exports` on the server.
        var root = this;
        // Save the previous value of the `_` variable.
        var previousUnderscore = root._;
        // Establish the object that gets returned to break out of a loop iteration.
        var breaker = {};
        // Save bytes in the minified (but not gzipped) version:
        var ArrayProto = Array.prototype, ObjProto = Object.prototype, FuncProto = Function.prototype;
        // Create quick reference variables for speed access to core prototypes.
        var push = ArrayProto.push, slice = ArrayProto.slice, concat = ArrayProto.concat, toString = ObjProto.toString, hasOwnProperty = ObjProto.hasOwnProperty;
        // All **ECMAScript 5** native function implementations that we hope to use
        // are declared here.
        var nativeForEach = ArrayProto.forEach, nativeMap = ArrayProto.map, nativeReduce = ArrayProto.reduce, nativeReduceRight = ArrayProto.reduceRight, nativeFilter = ArrayProto.filter, nativeEvery = ArrayProto.every, nativeSome = ArrayProto.some, nativeIndexOf = ArrayProto.indexOf, nativeLastIndexOf = ArrayProto.lastIndexOf, nativeIsArray = Array.isArray, nativeKeys = Object.keys, nativeBind = FuncProto.bind;
        // Create a safe reference to the Underscore object for use below.
        var _ = function(obj) {
            if (obj instanceof _) return obj;
            if (!(this instanceof _)) return new _(obj);
            this._wrapped = obj;
        };
        // Export the Underscore object for **Node.js**, with
        // backwards-compatibility for the old `require()` API. If we're in
        // the browser, add `_` as a global object via a string identifier,
        // for Closure Compiler "advanced" mode.
        if (typeof exports !== "undefined") {
            if (typeof module !== "undefined" && module.exports) {
                exports = module.exports = _;
            }
            exports._ = _;
        } else {
            root._ = _;
        }
        // Current version.
        _.VERSION = "1.6.0";
        // Collection Functions
        // --------------------
        // The cornerstone, an `each` implementation, aka `forEach`.
        // Handles objects with the built-in `forEach`, arrays, and raw objects.
        // Delegates to **ECMAScript 5**'s native `forEach` if available.
        var each = _.each = _.forEach = function(obj, iterator, context) {
            if (obj == null) return obj;
            if (nativeForEach && obj.forEach === nativeForEach) {
                obj.forEach(iterator, context);
            } else if (obj.length === +obj.length) {
                for (var i = 0, length = obj.length; i < length; i++) {
                    if (iterator.call(context, obj[i], i, obj) === breaker) return;
                }
            } else {
                var keys = _.keys(obj);
                for (var i = 0, length = keys.length; i < length; i++) {
                    if (iterator.call(context, obj[keys[i]], keys[i], obj) === breaker) return;
                }
            }
            return obj;
        };
        // Return the results of applying the iterator to each element.
        // Delegates to **ECMAScript 5**'s native `map` if available.
        _.map = _.collect = function(obj, iterator, context) {
            var results = [];
            if (obj == null) return results;
            if (nativeMap && obj.map === nativeMap) return obj.map(iterator, context);
            each(obj, function(value, index, list) {
                results.push(iterator.call(context, value, index, list));
            });
            return results;
        };
        var reduceError = "Reduce of empty array with no initial value";
        // **Reduce** builds up a single result from a list of values, aka `inject`,
        // or `foldl`. Delegates to **ECMAScript 5**'s native `reduce` if available.
        _.reduce = _.foldl = _.inject = function(obj, iterator, memo, context) {
            var initial = arguments.length > 2;
            if (obj == null) obj = [];
            if (nativeReduce && obj.reduce === nativeReduce) {
                if (context) iterator = _.bind(iterator, context);
                return initial ? obj.reduce(iterator, memo) : obj.reduce(iterator);
            }
            each(obj, function(value, index, list) {
                if (!initial) {
                    memo = value;
                    initial = true;
                } else {
                    memo = iterator.call(context, memo, value, index, list);
                }
            });
            if (!initial) throw new TypeError(reduceError);
            return memo;
        };
        // The right-associative version of reduce, also known as `foldr`.
        // Delegates to **ECMAScript 5**'s native `reduceRight` if available.
        _.reduceRight = _.foldr = function(obj, iterator, memo, context) {
            var initial = arguments.length > 2;
            if (obj == null) obj = [];
            if (nativeReduceRight && obj.reduceRight === nativeReduceRight) {
                if (context) iterator = _.bind(iterator, context);
                return initial ? obj.reduceRight(iterator, memo) : obj.reduceRight(iterator);
            }
            var length = obj.length;
            if (length !== +length) {
                var keys = _.keys(obj);
                length = keys.length;
            }
            each(obj, function(value, index, list) {
                index = keys ? keys[--length] : --length;
                if (!initial) {
                    memo = obj[index];
                    initial = true;
                } else {
                    memo = iterator.call(context, memo, obj[index], index, list);
                }
            });
            if (!initial) throw new TypeError(reduceError);
            return memo;
        };
        // Return the first value which passes a truth test. Aliased as `detect`.
        _.find = _.detect = function(obj, predicate, context) {
            var result;
            any(obj, function(value, index, list) {
                if (predicate.call(context, value, index, list)) {
                    result = value;
                    return true;
                }
            });
            return result;
        };
        // Return all the elements that pass a truth test.
        // Delegates to **ECMAScript 5**'s native `filter` if available.
        // Aliased as `select`.
        _.filter = _.select = function(obj, predicate, context) {
            var results = [];
            if (obj == null) return results;
            if (nativeFilter && obj.filter === nativeFilter) return obj.filter(predicate, context);
            each(obj, function(value, index, list) {
                if (predicate.call(context, value, index, list)) results.push(value);
            });
            return results;
        };
        // Return all the elements for which a truth test fails.
        _.reject = function(obj, predicate, context) {
            return _.filter(obj, function(value, index, list) {
                return !predicate.call(context, value, index, list);
            }, context);
        };
        // Determine whether all of the elements match a truth test.
        // Delegates to **ECMAScript 5**'s native `every` if available.
        // Aliased as `all`.
        _.every = _.all = function(obj, predicate, context) {
            predicate || (predicate = _.identity);
            var result = true;
            if (obj == null) return result;
            if (nativeEvery && obj.every === nativeEvery) return obj.every(predicate, context);
            each(obj, function(value, index, list) {
                if (!(result = result && predicate.call(context, value, index, list))) return breaker;
            });
            return !!result;
        };
        // Determine if at least one element in the object matches a truth test.
        // Delegates to **ECMAScript 5**'s native `some` if available.
        // Aliased as `any`.
        var any = _.some = _.any = function(obj, predicate, context) {
            predicate || (predicate = _.identity);
            var result = false;
            if (obj == null) return result;
            if (nativeSome && obj.some === nativeSome) return obj.some(predicate, context);
            each(obj, function(value, index, list) {
                if (result || (result = predicate.call(context, value, index, list))) return breaker;
            });
            return !!result;
        };
        // Determine if the array or object contains a given value (using `===`).
        // Aliased as `include`.
        _.contains = _.include = function(obj, target) {
            if (obj == null) return false;
            if (nativeIndexOf && obj.indexOf === nativeIndexOf) return obj.indexOf(target) != -1;
            return any(obj, function(value) {
                return value === target;
            });
        };
        // Invoke a method (with arguments) on every item in a collection.
        _.invoke = function(obj, method) {
            var args = slice.call(arguments, 2);
            var isFunc = _.isFunction(method);
            return _.map(obj, function(value) {
                return (isFunc ? method : value[method]).apply(value, args);
            });
        };
        // Convenience version of a common use case of `map`: fetching a property.
        _.pluck = function(obj, key) {
            return _.map(obj, _.property(key));
        };
        // Convenience version of a common use case of `filter`: selecting only objects
        // containing specific `key:value` pairs.
        _.where = function(obj, attrs) {
            return _.filter(obj, _.matches(attrs));
        };
        // Convenience version of a common use case of `find`: getting the first object
        // containing specific `key:value` pairs.
        _.findWhere = function(obj, attrs) {
            return _.find(obj, _.matches(attrs));
        };
        // Return the maximum element or (element-based computation).
        // Can't optimize arrays of integers longer than 65,535 elements.
        // See [WebKit Bug 80797](https://bugs.webkit.org/show_bug.cgi?id=80797)
        _.max = function(obj, iterator, context) {
            if (!iterator && _.isArray(obj) && obj[0] === +obj[0] && obj.length < 65535) {
                return Math.max.apply(Math, obj);
            }
            var result = -Infinity, lastComputed = -Infinity;
            each(obj, function(value, index, list) {
                var computed = iterator ? iterator.call(context, value, index, list) : value;
                if (computed > lastComputed) {
                    result = value;
                    lastComputed = computed;
                }
            });
            return result;
        };
        // Return the minimum element (or element-based computation).
        _.min = function(obj, iterator, context) {
            if (!iterator && _.isArray(obj) && obj[0] === +obj[0] && obj.length < 65535) {
                return Math.min.apply(Math, obj);
            }
            var result = Infinity, lastComputed = Infinity;
            each(obj, function(value, index, list) {
                var computed = iterator ? iterator.call(context, value, index, list) : value;
                if (computed < lastComputed) {
                    result = value;
                    lastComputed = computed;
                }
            });
            return result;
        };
        // Shuffle an array, using the modern version of the
        // [Fisher-Yates shuffle](http://en.wikipedia.org/wiki/FisherYates_shuffle).
        _.shuffle = function(obj) {
            var rand;
            var index = 0;
            var shuffled = [];
            each(obj, function(value) {
                rand = _.random(index++);
                shuffled[index - 1] = shuffled[rand];
                shuffled[rand] = value;
            });
            return shuffled;
        };
        // Sample **n** random values from a collection.
        // If **n** is not specified, returns a single random element.
        // The internal `guard` argument allows it to work with `map`.
        _.sample = function(obj, n, guard) {
            if (n == null || guard) {
                if (obj.length !== +obj.length) obj = _.values(obj);
                return obj[_.random(obj.length - 1)];
            }
            return _.shuffle(obj).slice(0, Math.max(0, n));
        };
        // An internal function to generate lookup iterators.
        var lookupIterator = function(value) {
            if (value == null) return _.identity;
            if (_.isFunction(value)) return value;
            return _.property(value);
        };
        // Sort the object's values by a criterion produced by an iterator.
        _.sortBy = function(obj, iterator, context) {
            iterator = lookupIterator(iterator);
            return _.pluck(_.map(obj, function(value, index, list) {
                return {
                    value: value,
                    index: index,
                    criteria: iterator.call(context, value, index, list)
                };
            }).sort(function(left, right) {
                var a = left.criteria;
                var b = right.criteria;
                if (a !== b) {
                    if (a > b || a === void 0) return 1;
                    if (a < b || b === void 0) return -1;
                }
                return left.index - right.index;
            }), "value");
        };
        // An internal function used for aggregate "group by" operations.
        var group = function(behavior) {
            return function(obj, iterator, context) {
                var result = {};
                iterator = lookupIterator(iterator);
                each(obj, function(value, index) {
                    var key = iterator.call(context, value, index, obj);
                    behavior(result, key, value);
                });
                return result;
            };
        };
        // Groups the object's values by a criterion. Pass either a string attribute
        // to group by, or a function that returns the criterion.
        _.groupBy = group(function(result, key, value) {
            _.has(result, key) ? result[key].push(value) : result[key] = [ value ];
        });
        // Indexes the object's values by a criterion, similar to `groupBy`, but for
        // when you know that your index values will be unique.
        _.indexBy = group(function(result, key, value) {
            result[key] = value;
        });
        // Counts instances of an object that group by a certain criterion. Pass
        // either a string attribute to count by, or a function that returns the
        // criterion.
        _.countBy = group(function(result, key) {
            _.has(result, key) ? result[key]++ : result[key] = 1;
        });
        // Use a comparator function to figure out the smallest index at which
        // an object should be inserted so as to maintain order. Uses binary search.
        _.sortedIndex = function(array, obj, iterator, context) {
            iterator = lookupIterator(iterator);
            var value = iterator.call(context, obj);
            var low = 0, high = array.length;
            while (low < high) {
                var mid = low + high >>> 1;
                iterator.call(context, array[mid]) < value ? low = mid + 1 : high = mid;
            }
            return low;
        };
        // Safely create a real, live array from anything iterable.
        _.toArray = function(obj) {
            if (!obj) return [];
            if (_.isArray(obj)) return slice.call(obj);
            if (obj.length === +obj.length) return _.map(obj, _.identity);
            return _.values(obj);
        };
        // Return the number of elements in an object.
        _.size = function(obj) {
            if (obj == null) return 0;
            return obj.length === +obj.length ? obj.length : _.keys(obj).length;
        };
        // Array Functions
        // ---------------
        // Get the first element of an array. Passing **n** will return the first N
        // values in the array. Aliased as `head` and `take`. The **guard** check
        // allows it to work with `_.map`.
        _.first = _.head = _.take = function(array, n, guard) {
            if (array == null) return void 0;
            if (n == null || guard) return array[0];
            if (n < 0) return [];
            return slice.call(array, 0, n);
        };
        // Returns everything but the last entry of the array. Especially useful on
        // the arguments object. Passing **n** will return all the values in
        // the array, excluding the last N. The **guard** check allows it to work with
        // `_.map`.
        _.initial = function(array, n, guard) {
            return slice.call(array, 0, array.length - (n == null || guard ? 1 : n));
        };
        // Get the last element of an array. Passing **n** will return the last N
        // values in the array. The **guard** check allows it to work with `_.map`.
        _.last = function(array, n, guard) {
            if (array == null) return void 0;
            if (n == null || guard) return array[array.length - 1];
            return slice.call(array, Math.max(array.length - n, 0));
        };
        // Returns everything but the first entry of the array. Aliased as `tail` and `drop`.
        // Especially useful on the arguments object. Passing an **n** will return
        // the rest N values in the array. The **guard**
        // check allows it to work with `_.map`.
        _.rest = _.tail = _.drop = function(array, n, guard) {
            return slice.call(array, n == null || guard ? 1 : n);
        };
        // Trim out all falsy values from an array.
        _.compact = function(array) {
            return _.filter(array, _.identity);
        };
        // Internal implementation of a recursive `flatten` function.
        var flatten = function(input, shallow, output) {
            if (shallow && _.every(input, _.isArray)) {
                return concat.apply(output, input);
            }
            each(input, function(value) {
                if (_.isArray(value) || _.isArguments(value)) {
                    shallow ? push.apply(output, value) : flatten(value, shallow, output);
                } else {
                    output.push(value);
                }
            });
            return output;
        };
        // Flatten out an array, either recursively (by default), or just one level.
        _.flatten = function(array, shallow) {
            return flatten(array, shallow, []);
        };
        // Return a version of the array that does not contain the specified value(s).
        _.without = function(array) {
            return _.difference(array, slice.call(arguments, 1));
        };
        // Split an array into two arrays: one whose elements all satisfy the given
        // predicate, and one whose elements all do not satisfy the predicate.
        _.partition = function(array, predicate) {
            var pass = [], fail = [];
            each(array, function(elem) {
                (predicate(elem) ? pass : fail).push(elem);
            });
            return [ pass, fail ];
        };
        // Produce a duplicate-free version of the array. If the array has already
        // been sorted, you have the option of using a faster algorithm.
        // Aliased as `unique`.
        _.uniq = _.unique = function(array, isSorted, iterator, context) {
            if (_.isFunction(isSorted)) {
                context = iterator;
                iterator = isSorted;
                isSorted = false;
            }
            var initial = iterator ? _.map(array, iterator, context) : array;
            var results = [];
            var seen = [];
            each(initial, function(value, index) {
                if (isSorted ? !index || seen[seen.length - 1] !== value : !_.contains(seen, value)) {
                    seen.push(value);
                    results.push(array[index]);
                }
            });
            return results;
        };
        // Produce an array that contains the union: each distinct element from all of
        // the passed-in arrays.
        _.union = function() {
            return _.uniq(_.flatten(arguments, true));
        };
        // Produce an array that contains every item shared between all the
        // passed-in arrays.
        _.intersection = function(array) {
            var rest = slice.call(arguments, 1);
            return _.filter(_.uniq(array), function(item) {
                return _.every(rest, function(other) {
                    return _.contains(other, item);
                });
            });
        };
        // Take the difference between one array and a number of other arrays.
        // Only the elements present in just the first array will remain.
        _.difference = function(array) {
            var rest = concat.apply(ArrayProto, slice.call(arguments, 1));
            return _.filter(array, function(value) {
                return !_.contains(rest, value);
            });
        };
        // Zip together multiple lists into a single array -- elements that share
        // an index go together.
        _.zip = function() {
            var length = _.max(_.pluck(arguments, "length").concat(0));
            var results = new Array(length);
            for (var i = 0; i < length; i++) {
                results[i] = _.pluck(arguments, "" + i);
            }
            return results;
        };
        // Converts lists into objects. Pass either a single array of `[key, value]`
        // pairs, or two parallel arrays of the same length -- one of keys, and one of
        // the corresponding values.
        _.object = function(list, values) {
            if (list == null) return {};
            var result = {};
            for (var i = 0, length = list.length; i < length; i++) {
                if (values) {
                    result[list[i]] = values[i];
                } else {
                    result[list[i][0]] = list[i][1];
                }
            }
            return result;
        };
        // If the browser doesn't supply us with indexOf (I'm looking at you, **MSIE**),
        // we need this function. Return the position of the first occurrence of an
        // item in an array, or -1 if the item is not included in the array.
        // Delegates to **ECMAScript 5**'s native `indexOf` if available.
        // If the array is large and already in sort order, pass `true`
        // for **isSorted** to use binary search.
        _.indexOf = function(array, item, isSorted) {
            if (array == null) return -1;
            var i = 0, length = array.length;
            if (isSorted) {
                if (typeof isSorted == "number") {
                    i = isSorted < 0 ? Math.max(0, length + isSorted) : isSorted;
                } else {
                    i = _.sortedIndex(array, item);
                    return array[i] === item ? i : -1;
                }
            }
            if (nativeIndexOf && array.indexOf === nativeIndexOf) return array.indexOf(item, isSorted);
            for (;i < length; i++) if (array[i] === item) return i;
            return -1;
        };
        // Delegates to **ECMAScript 5**'s native `lastIndexOf` if available.
        _.lastIndexOf = function(array, item, from) {
            if (array == null) return -1;
            var hasIndex = from != null;
            if (nativeLastIndexOf && array.lastIndexOf === nativeLastIndexOf) {
                return hasIndex ? array.lastIndexOf(item, from) : array.lastIndexOf(item);
            }
            var i = hasIndex ? from : array.length;
            while (i--) if (array[i] === item) return i;
            return -1;
        };
        // Generate an integer Array containing an arithmetic progression. A port of
        // the native Python `range()` function. See
        // [the Python documentation](http://docs.python.org/library/functions.html#range).
        _.range = function(start, stop, step) {
            if (arguments.length <= 1) {
                stop = start || 0;
                start = 0;
            }
            step = arguments[2] || 1;
            var length = Math.max(Math.ceil((stop - start) / step), 0);
            var idx = 0;
            var range = new Array(length);
            while (idx < length) {
                range[idx++] = start;
                start += step;
            }
            return range;
        };
        // Function (ahem) Functions
        // ------------------
        // Reusable constructor function for prototype setting.
        var ctor = function() {};
        // Create a function bound to a given object (assigning `this`, and arguments,
        // optionally). Delegates to **ECMAScript 5**'s native `Function.bind` if
        // available.
        _.bind = function(func, context) {
            var args, bound;
            if (nativeBind && func.bind === nativeBind) return nativeBind.apply(func, slice.call(arguments, 1));
            if (!_.isFunction(func)) throw new TypeError();
            args = slice.call(arguments, 2);
            return bound = function() {
                if (!(this instanceof bound)) return func.apply(context, args.concat(slice.call(arguments)));
                ctor.prototype = func.prototype;
                var self = new ctor();
                ctor.prototype = null;
                var result = func.apply(self, args.concat(slice.call(arguments)));
                if (Object(result) === result) return result;
                return self;
            };
        };
        // Partially apply a function by creating a version that has had some of its
        // arguments pre-filled, without changing its dynamic `this` context. _ acts
        // as a placeholder, allowing any combination of arguments to be pre-filled.
        _.partial = function(func) {
            var boundArgs = slice.call(arguments, 1);
            return function() {
                var position = 0;
                var args = boundArgs.slice();
                for (var i = 0, length = args.length; i < length; i++) {
                    if (args[i] === _) args[i] = arguments[position++];
                }
                while (position < arguments.length) args.push(arguments[position++]);
                return func.apply(this, args);
            };
        };
        // Bind a number of an object's methods to that object. Remaining arguments
        // are the method names to be bound. Useful for ensuring that all callbacks
        // defined on an object belong to it.
        _.bindAll = function(obj) {
            var funcs = slice.call(arguments, 1);
            if (funcs.length === 0) throw new Error("bindAll must be passed function names");
            each(funcs, function(f) {
                obj[f] = _.bind(obj[f], obj);
            });
            return obj;
        };
        // Memoize an expensive function by storing its results.
        _.memoize = function(func, hasher) {
            var memo = {};
            hasher || (hasher = _.identity);
            return function() {
                var key = hasher.apply(this, arguments);
                return _.has(memo, key) ? memo[key] : memo[key] = func.apply(this, arguments);
            };
        };
        // Delays a function for the given number of milliseconds, and then calls
        // it with the arguments supplied.
        _.delay = function(func, wait) {
            var args = slice.call(arguments, 2);
            return setTimeout(function() {
                return func.apply(null, args);
            }, wait);
        };
        // Defers a function, scheduling it to run after the current call stack has
        // cleared.
        _.defer = function(func) {
            return _.delay.apply(_, [ func, 1 ].concat(slice.call(arguments, 1)));
        };
        // Returns a function, that, when invoked, will only be triggered at most once
        // during a given window of time. Normally, the throttled function will run
        // as much as it can, without ever going more than once per `wait` duration;
        // but if you'd like to disable the execution on the leading edge, pass
        // `{leading: false}`. To disable execution on the trailing edge, ditto.
        _.throttle = function(func, wait, options) {
            var context, args, result;
            var timeout = null;
            var previous = 0;
            options || (options = {});
            var later = function() {
                previous = options.leading === false ? 0 : _.now();
                timeout = null;
                result = func.apply(context, args);
                context = args = null;
            };
            return function() {
                var now = _.now();
                if (!previous && options.leading === false) previous = now;
                var remaining = wait - (now - previous);
                context = this;
                args = arguments;
                if (remaining <= 0) {
                    clearTimeout(timeout);
                    timeout = null;
                    previous = now;
                    result = func.apply(context, args);
                    context = args = null;
                } else if (!timeout && options.trailing !== false) {
                    timeout = setTimeout(later, remaining);
                }
                return result;
            };
        };
        // Returns a function, that, as long as it continues to be invoked, will not
        // be triggered. The function will be called after it stops being called for
        // N milliseconds. If `immediate` is passed, trigger the function on the
        // leading edge, instead of the trailing.
        _.debounce = function(func, wait, immediate) {
            var timeout, args, context, timestamp, result;
            var later = function() {
                var last = _.now() - timestamp;
                if (last < wait) {
                    timeout = setTimeout(later, wait - last);
                } else {
                    timeout = null;
                    if (!immediate) {
                        result = func.apply(context, args);
                        context = args = null;
                    }
                }
            };
            return function() {
                context = this;
                args = arguments;
                timestamp = _.now();
                var callNow = immediate && !timeout;
                if (!timeout) {
                    timeout = setTimeout(later, wait);
                }
                if (callNow) {
                    result = func.apply(context, args);
                    context = args = null;
                }
                return result;
            };
        };
        // Returns a function that will be executed at most one time, no matter how
        // often you call it. Useful for lazy initialization.
        _.once = function(func) {
            var ran = false, memo;
            return function() {
                if (ran) return memo;
                ran = true;
                memo = func.apply(this, arguments);
                func = null;
                return memo;
            };
        };
        // Returns the first function passed as an argument to the second,
        // allowing you to adjust arguments, run code before and after, and
        // conditionally execute the original function.
        _.wrap = function(func, wrapper) {
            return _.partial(wrapper, func);
        };
        // Returns a function that is the composition of a list of functions, each
        // consuming the return value of the function that follows.
        _.compose = function() {
            var funcs = arguments;
            return function() {
                var args = arguments;
                for (var i = funcs.length - 1; i >= 0; i--) {
                    args = [ funcs[i].apply(this, args) ];
                }
                return args[0];
            };
        };
        // Returns a function that will only be executed after being called N times.
        _.after = function(times, func) {
            return function() {
                if (--times < 1) {
                    return func.apply(this, arguments);
                }
            };
        };
        // Object Functions
        // ----------------
        // Retrieve the names of an object's properties.
        // Delegates to **ECMAScript 5**'s native `Object.keys`
        _.keys = function(obj) {
            if (!_.isObject(obj)) return [];
            if (nativeKeys) return nativeKeys(obj);
            var keys = [];
            for (var key in obj) if (_.has(obj, key)) keys.push(key);
            return keys;
        };
        // Retrieve the values of an object's properties.
        _.values = function(obj) {
            var keys = _.keys(obj);
            var length = keys.length;
            var values = new Array(length);
            for (var i = 0; i < length; i++) {
                values[i] = obj[keys[i]];
            }
            return values;
        };
        // Convert an object into a list of `[key, value]` pairs.
        _.pairs = function(obj) {
            var keys = _.keys(obj);
            var length = keys.length;
            var pairs = new Array(length);
            for (var i = 0; i < length; i++) {
                pairs[i] = [ keys[i], obj[keys[i]] ];
            }
            return pairs;
        };
        // Invert the keys and values of an object. The values must be serializable.
        _.invert = function(obj) {
            var result = {};
            var keys = _.keys(obj);
            for (var i = 0, length = keys.length; i < length; i++) {
                result[obj[keys[i]]] = keys[i];
            }
            return result;
        };
        // Return a sorted list of the function names available on the object.
        // Aliased as `methods`
        _.functions = _.methods = function(obj) {
            var names = [];
            for (var key in obj) {
                if (_.isFunction(obj[key])) names.push(key);
            }
            return names.sort();
        };
        // Extend a given object with all the properties in passed-in object(s).
        _.extend = function(obj) {
            each(slice.call(arguments, 1), function(source) {
                if (source) {
                    for (var prop in source) {
                        obj[prop] = source[prop];
                    }
                }
            });
            return obj;
        };
        // Return a copy of the object only containing the whitelisted properties.
        _.pick = function(obj) {
            var copy = {};
            var keys = concat.apply(ArrayProto, slice.call(arguments, 1));
            each(keys, function(key) {
                if (key in obj) copy[key] = obj[key];
            });
            return copy;
        };
        // Return a copy of the object without the blacklisted properties.
        _.omit = function(obj) {
            var copy = {};
            var keys = concat.apply(ArrayProto, slice.call(arguments, 1));
            for (var key in obj) {
                if (!_.contains(keys, key)) copy[key] = obj[key];
            }
            return copy;
        };
        // Fill in a given object with default properties.
        _.defaults = function(obj) {
            each(slice.call(arguments, 1), function(source) {
                if (source) {
                    for (var prop in source) {
                        if (obj[prop] === void 0) obj[prop] = source[prop];
                    }
                }
            });
            return obj;
        };
        // Create a (shallow-cloned) duplicate of an object.
        _.clone = function(obj) {
            if (!_.isObject(obj)) return obj;
            return _.isArray(obj) ? obj.slice() : _.extend({}, obj);
        };
        // Invokes interceptor with the obj, and then returns obj.
        // The primary purpose of this method is to "tap into" a method chain, in
        // order to perform operations on intermediate results within the chain.
        _.tap = function(obj, interceptor) {
            interceptor(obj);
            return obj;
        };
        // Internal recursive comparison function for `isEqual`.
        var eq = function(a, b, aStack, bStack) {
            // Identical objects are equal. `0 === -0`, but they aren't identical.
            // See the [Harmony `egal` proposal](http://wiki.ecmascript.org/doku.php?id=harmony:egal).
            if (a === b) return a !== 0 || 1 / a == 1 / b;
            // A strict comparison is necessary because `null == undefined`.
            if (a == null || b == null) return a === b;
            // Unwrap any wrapped objects.
            if (a instanceof _) a = a._wrapped;
            if (b instanceof _) b = b._wrapped;
            // Compare `[[Class]]` names.
            var className = toString.call(a);
            if (className != toString.call(b)) return false;
            switch (className) {
              // Strings, numbers, dates, and booleans are compared by value.
                case "[object String]":
                // Primitives and their corresponding object wrappers are equivalent; thus, `"5"` is
                // equivalent to `new String("5")`.
                return a == String(b);

              case "[object Number]":
                // `NaN`s are equivalent, but non-reflexive. An `egal` comparison is performed for
                // other numeric values.
                return a != +a ? b != +b : a == 0 ? 1 / a == 1 / b : a == +b;

              case "[object Date]":
              case "[object Boolean]":
                // Coerce dates and booleans to numeric primitive values. Dates are compared by their
                // millisecond representations. Note that invalid dates with millisecond representations
                // of `NaN` are not equivalent.
                return +a == +b;

              // RegExps are compared by their source patterns and flags.
                case "[object RegExp]":
                return a.source == b.source && a.global == b.global && a.multiline == b.multiline && a.ignoreCase == b.ignoreCase;
            }
            if (typeof a != "object" || typeof b != "object") return false;
            // Assume equality for cyclic structures. The algorithm for detecting cyclic
            // structures is adapted from ES 5.1 section 15.12.3, abstract operation `JO`.
            var length = aStack.length;
            while (length--) {
                // Linear search. Performance is inversely proportional to the number of
                // unique nested structures.
                if (aStack[length] == a) return bStack[length] == b;
            }
            // Objects with different constructors are not equivalent, but `Object`s
            // from different frames are.
            var aCtor = a.constructor, bCtor = b.constructor;
            if (aCtor !== bCtor && !(_.isFunction(aCtor) && aCtor instanceof aCtor && _.isFunction(bCtor) && bCtor instanceof bCtor) && ("constructor" in a && "constructor" in b)) {
                return false;
            }
            // Add the first object to the stack of traversed objects.
            aStack.push(a);
            bStack.push(b);
            var size = 0, result = true;
            // Recursively compare objects and arrays.
            if (className == "[object Array]") {
                // Compare array lengths to determine if a deep comparison is necessary.
                size = a.length;
                result = size == b.length;
                if (result) {
                    // Deep compare the contents, ignoring non-numeric properties.
                    while (size--) {
                        if (!(result = eq(a[size], b[size], aStack, bStack))) break;
                    }
                }
            } else {
                // Deep compare objects.
                for (var key in a) {
                    if (_.has(a, key)) {
                        // Count the expected number of properties.
                        size++;
                        // Deep compare each member.
                        if (!(result = _.has(b, key) && eq(a[key], b[key], aStack, bStack))) break;
                    }
                }
                // Ensure that both objects contain the same number of properties.
                if (result) {
                    for (key in b) {
                        if (_.has(b, key) && !size--) break;
                    }
                    result = !size;
                }
            }
            // Remove the first object from the stack of traversed objects.
            aStack.pop();
            bStack.pop();
            return result;
        };
        // Perform a deep comparison to check if two objects are equal.
        _.isEqual = function(a, b) {
            return eq(a, b, [], []);
        };
        // Is a given array, string, or object empty?
        // An "empty" object has no enumerable own-properties.
        _.isEmpty = function(obj) {
            if (obj == null) return true;
            if (_.isArray(obj) || _.isString(obj)) return obj.length === 0;
            for (var key in obj) if (_.has(obj, key)) return false;
            return true;
        };
        // Is a given value a DOM element?
        _.isElement = function(obj) {
            return !!(obj && obj.nodeType === 1);
        };
        // Is a given value an array?
        // Delegates to ECMA5's native Array.isArray
        _.isArray = nativeIsArray || function(obj) {
            return toString.call(obj) == "[object Array]";
        };
        // Is a given variable an object?
        _.isObject = function(obj) {
            return obj === Object(obj);
        };
        // Add some isType methods: isArguments, isFunction, isString, isNumber, isDate, isRegExp.
        each([ "Arguments", "Function", "String", "Number", "Date", "RegExp" ], function(name) {
            _["is" + name] = function(obj) {
                return toString.call(obj) == "[object " + name + "]";
            };
        });
        // Define a fallback version of the method in browsers (ahem, IE), where
        // there isn't any inspectable "Arguments" type.
        if (!_.isArguments(arguments)) {
            _.isArguments = function(obj) {
                return !!(obj && _.has(obj, "callee"));
            };
        }
        // Optimize `isFunction` if appropriate.
        if (typeof /./ !== "function") {
            _.isFunction = function(obj) {
                return typeof obj === "function";
            };
        }
        // Is a given object a finite number?
        _.isFinite = function(obj) {
            return isFinite(obj) && !isNaN(parseFloat(obj));
        };
        // Is the given value `NaN`? (NaN is the only number which does not equal itself).
        _.isNaN = function(obj) {
            return _.isNumber(obj) && obj != +obj;
        };
        // Is a given value a boolean?
        _.isBoolean = function(obj) {
            return obj === true || obj === false || toString.call(obj) == "[object Boolean]";
        };
        // Is a given value equal to null?
        _.isNull = function(obj) {
            return obj === null;
        };
        // Is a given variable undefined?
        _.isUndefined = function(obj) {
            return obj === void 0;
        };
        // Shortcut function for checking if an object has a given property directly
        // on itself (in other words, not on a prototype).
        _.has = function(obj, key) {
            return hasOwnProperty.call(obj, key);
        };
        // Utility Functions
        // -----------------
        // Run Underscore.js in *noConflict* mode, returning the `_` variable to its
        // previous owner. Returns a reference to the Underscore object.
        _.noConflict = function() {
            root._ = previousUnderscore;
            return this;
        };
        // Keep the identity function around for default iterators.
        _.identity = function(value) {
            return value;
        };
        _.constant = function(value) {
            return function() {
                return value;
            };
        };
        _.property = function(key) {
            return function(obj) {
                return obj[key];
            };
        };
        // Returns a predicate for checking whether an object has a given set of `key:value` pairs.
        _.matches = function(attrs) {
            return function(obj) {
                if (obj === attrs) return true;
                //avoid comparing an object to itself.
                for (var key in attrs) {
                    if (attrs[key] !== obj[key]) return false;
                }
                return true;
            };
        };
        // Run a function **n** times.
        _.times = function(n, iterator, context) {
            var accum = Array(Math.max(0, n));
            for (var i = 0; i < n; i++) accum[i] = iterator.call(context, i);
            return accum;
        };
        // Return a random integer between min and max (inclusive).
        _.random = function(min, max) {
            if (max == null) {
                max = min;
                min = 0;
            }
            return min + Math.floor(Math.random() * (max - min + 1));
        };
        // A (possibly faster) way to get the current timestamp as an integer.
        _.now = Date.now || function() {
            return new Date().getTime();
        };
        // List of HTML entities for escaping.
        var entityMap = {
            escape: {
                "&": "&amp;",
                "<": "&lt;",
                ">": "&gt;",
                '"': "&quot;",
                "'": "&#x27;"
            }
        };
        entityMap.unescape = _.invert(entityMap.escape);
        // Regexes containing the keys and values listed immediately above.
        var entityRegexes = {
            escape: new RegExp("[" + _.keys(entityMap.escape).join("") + "]", "g"),
            unescape: new RegExp("(" + _.keys(entityMap.unescape).join("|") + ")", "g")
        };
        // Functions for escaping and unescaping strings to/from HTML interpolation.
        _.each([ "escape", "unescape" ], function(method) {
            _[method] = function(string) {
                if (string == null) return "";
                return ("" + string).replace(entityRegexes[method], function(match) {
                    return entityMap[method][match];
                });
            };
        });
        // If the value of the named `property` is a function then invoke it with the
        // `object` as context; otherwise, return it.
        _.result = function(object, property) {
            if (object == null) return void 0;
            var value = object[property];
            return _.isFunction(value) ? value.call(object) : value;
        };
        // Add your own custom functions to the Underscore object.
        _.mixin = function(obj) {
            each(_.functions(obj), function(name) {
                var func = _[name] = obj[name];
                _.prototype[name] = function() {
                    var args = [ this._wrapped ];
                    push.apply(args, arguments);
                    return result.call(this, func.apply(_, args));
                };
            });
        };
        // Generate a unique integer id (unique within the entire client session).
        // Useful for temporary DOM ids.
        var idCounter = 0;
        _.uniqueId = function(prefix) {
            var id = ++idCounter + "";
            return prefix ? prefix + id : id;
        };
        // By default, Underscore uses ERB-style template delimiters, change the
        // following template settings to use alternative delimiters.
        _.templateSettings = {
            evaluate: /<%([\s\S]+?)%>/g,
            interpolate: /<%=([\s\S]+?)%>/g,
            escape: /<%-([\s\S]+?)%>/g
        };
        // When customizing `templateSettings`, if you don't want to define an
        // interpolation, evaluation or escaping regex, we need one that is
        // guaranteed not to match.
        var noMatch = /(.)^/;
        // Certain characters need to be escaped so that they can be put into a
        // string literal.
        var escapes = {
            "'": "'",
            "\\": "\\",
            "\r": "r",
            "\n": "n",
            "	": "t",
            "\u2028": "u2028",
            "\u2029": "u2029"
        };
        var escaper = /\\|'|\r|\n|\t|\u2028|\u2029/g;
        // JavaScript micro-templating, similar to John Resig's implementation.
        // Underscore templating handles arbitrary delimiters, preserves whitespace,
        // and correctly escapes quotes within interpolated code.
        _.template = function(text, data, settings) {
            var render;
            settings = _.defaults({}, settings, _.templateSettings);
            // Combine delimiters into one regular expression via alternation.
            var matcher = new RegExp([ (settings.escape || noMatch).source, (settings.interpolate || noMatch).source, (settings.evaluate || noMatch).source ].join("|") + "|$", "g");
            // Compile the template source, escaping string literals appropriately.
            var index = 0;
            var source = "__p+='";
            text.replace(matcher, function(match, escape, interpolate, evaluate, offset) {
                source += text.slice(index, offset).replace(escaper, function(match) {
                    return "\\" + escapes[match];
                });
                if (escape) {
                    source += "'+\n((__t=(" + escape + "))==null?'':_.escape(__t))+\n'";
                }
                if (interpolate) {
                    source += "'+\n((__t=(" + interpolate + "))==null?'':__t)+\n'";
                }
                if (evaluate) {
                    source += "';\n" + evaluate + "\n__p+='";
                }
                index = offset + match.length;
                return match;
            });
            source += "';\n";
            // If a variable is not specified, place data values in local scope.
            if (!settings.variable) source = "with(obj||{}){\n" + source + "}\n";
            source = "var __t,__p='',__j=Array.prototype.join," + "print=function(){__p+=__j.call(arguments,'');};\n" + source + "return __p;\n";
            try {
                render = new Function(settings.variable || "obj", "_", source);
            } catch (e) {
                e.source = source;
                throw e;
            }
            if (data) return render(data, _);
            var template = function(data) {
                return render.call(this, data, _);
            };
            // Provide the compiled function source as a convenience for precompilation.
            template.source = "function(" + (settings.variable || "obj") + "){\n" + source + "}";
            return template;
        };
        // Add a "chain" function, which will delegate to the wrapper.
        _.chain = function(obj) {
            return _(obj).chain();
        };
        // OOP
        // ---------------
        // If Underscore is called as a function, it returns a wrapped object that
        // can be used OO-style. This wrapper holds altered versions of all the
        // underscore functions. Wrapped objects may be chained.
        // Helper function to continue chaining intermediate results.
        var result = function(obj) {
            return this._chain ? _(obj).chain() : obj;
        };
        // Add all of the Underscore functions to the wrapper object.
        _.mixin(_);
        // Add all mutator Array functions to the wrapper.
        each([ "pop", "push", "reverse", "shift", "sort", "splice", "unshift" ], function(name) {
            var method = ArrayProto[name];
            _.prototype[name] = function() {
                var obj = this._wrapped;
                method.apply(obj, arguments);
                if ((name == "shift" || name == "splice") && obj.length === 0) delete obj[0];
                return result.call(this, obj);
            };
        });
        // Add all accessor Array functions to the wrapper.
        each([ "concat", "join", "slice" ], function(name) {
            var method = ArrayProto[name];
            _.prototype[name] = function() {
                return result.call(this, method.apply(this._wrapped, arguments));
            };
        });
        _.extend(_.prototype, {
            // Start chaining a wrapped Underscore object.
            chain: function() {
                this._chain = true;
                return this;
            },
            // Extracts the result from a wrapped and chained object.
            value: function() {
                return this._wrapped;
            }
        });
        // AMD registration happens at the end for compatibility with AMD loaders
        // that may not enforce next-turn semantics on modules. Even though general
        // practice for AMD registration is to be anonymous, underscore registers
        // as a named module because, like jQuery, it is a base library that is
        // popular enough to be bundled in a third party lib, but not be part of
        // an AMD load request. Those cases could generate an error when an
        // anonymous define() is called outside of a loader request.
        if (typeof define === "function" && define.amd) {
            define("underscore", [], function() {
                return _;
            });
        }
    }).call(this);
}.bind(this));

require.register("app/vendor/zepto.js", function(exports, require, module) {
    /* Zepto v1.1.2 - zepto event ajax form ie - zeptojs.com/license */
    var Zepto = function() {
        var undefined, key, $, classList, emptyArray = [], slice = emptyArray.slice, filter = emptyArray.filter, document = window.document, elementDisplay = {}, classCache = {}, cssNumber = {
            "column-count": 1,
            columns: 1,
            "font-weight": 1,
            "line-height": 1,
            opacity: 1,
            "z-index": 1,
            zoom: 1
        }, fragmentRE = /^\s*<(\w+|!)[^>]*>/, singleTagRE = /^<(\w+)\s*\/?>(?:<\/\1>|)$/, tagExpanderRE = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:]+)[^>]*)\/>/gi, rootNodeRE = /^(?:body|html)$/i, capitalRE = /([A-Z])/g, // special attributes that should be get/set via method calls
        methodAttributes = [ "val", "css", "html", "text", "data", "width", "height", "offset" ], adjacencyOperators = [ "after", "prepend", "before", "append" ], table = document.createElement("table"), tableRow = document.createElement("tr"), containers = {
            tr: document.createElement("tbody"),
            tbody: table,
            thead: table,
            tfoot: table,
            td: tableRow,
            th: tableRow,
            "*": document.createElement("div")
        }, readyRE = /complete|loaded|interactive/, classSelectorRE = /^\.([\w-]+)$/, idSelectorRE = /^#([\w-]*)$/, simpleSelectorRE = /^[\w-]*$/, class2type = {}, toString = class2type.toString, zepto = {}, camelize, uniq, tempParent = document.createElement("div"), propMap = {
            tabindex: "tabIndex",
            readonly: "readOnly",
            "for": "htmlFor",
            "class": "className",
            maxlength: "maxLength",
            cellspacing: "cellSpacing",
            cellpadding: "cellPadding",
            rowspan: "rowSpan",
            colspan: "colSpan",
            usemap: "useMap",
            frameborder: "frameBorder",
            contenteditable: "contentEditable"
        };
        zepto.matches = function(element, selector) {
            if (!selector || !element || element.nodeType !== 1) return false;
            var matchesSelector = element.webkitMatchesSelector || element.mozMatchesSelector || element.oMatchesSelector || element.matchesSelector;
            if (matchesSelector) return matchesSelector.call(element, selector);
            // fall back to performing a selector:
            var match, parent = element.parentNode, temp = !parent;
            if (temp) (parent = tempParent).appendChild(element);
            match = ~zepto.qsa(parent, selector).indexOf(element);
            temp && tempParent.removeChild(element);
            return match;
        };
        function type(obj) {
            return obj == null ? String(obj) : class2type[toString.call(obj)] || "object";
        }
        function isFunction(value) {
            return type(value) == "function";
        }
        function isWindow(obj) {
            return obj != null && obj == obj.window;
        }
        function isDocument(obj) {
            return obj != null && obj.nodeType == obj.DOCUMENT_NODE;
        }
        function isObject(obj) {
            return type(obj) == "object";
        }
        function isPlainObject(obj) {
            return isObject(obj) && !isWindow(obj) && Object.getPrototypeOf(obj) == Object.prototype;
        }
        function isArray(value) {
            return value instanceof Array;
        }
        function likeArray(obj) {
            return typeof obj.length == "number";
        }
        function compact(array) {
            return filter.call(array, function(item) {
                return item != null;
            });
        }
        function flatten(array) {
            return array.length > 0 ? $.fn.concat.apply([], array) : array;
        }
        camelize = function(str) {
            return str.replace(/-+(.)?/g, function(match, chr) {
                return chr ? chr.toUpperCase() : "";
            });
        };
        function dasherize(str) {
            return str.replace(/::/g, "/").replace(/([A-Z]+)([A-Z][a-z])/g, "$1_$2").replace(/([a-z\d])([A-Z])/g, "$1_$2").replace(/_/g, "-").toLowerCase();
        }
        uniq = function(array) {
            return filter.call(array, function(item, idx) {
                return array.indexOf(item) == idx;
            });
        };
        function classRE(name) {
            return name in classCache ? classCache[name] : classCache[name] = new RegExp("(^|\\s)" + name + "(\\s|$)");
        }
        function maybeAddPx(name, value) {
            return typeof value == "number" && !cssNumber[dasherize(name)] ? value + "px" : value;
        }
        function defaultDisplay(nodeName) {
            var element, display;
            if (!elementDisplay[nodeName]) {
                element = document.createElement(nodeName);
                document.body.appendChild(element);
                display = getComputedStyle(element, "").getPropertyValue("display");
                element.parentNode.removeChild(element);
                display == "none" && (display = "block");
                elementDisplay[nodeName] = display;
            }
            return elementDisplay[nodeName];
        }
        function children(element) {
            return "children" in element ? slice.call(element.children) : $.map(element.childNodes, function(node) {
                if (node.nodeType == 1) return node;
            });
        }
        // `$.zepto.fragment` takes a html string and an optional tag name
        // to generate DOM nodes nodes from the given html string.
        // The generated DOM nodes are returned as an array.
        // This function can be overriden in plugins for example to make
        // it compatible with browsers that don't support the DOM fully.
        zepto.fragment = function(html, name, properties) {
            var dom, nodes, container;
            // A special case optimization for a single tag
            if (singleTagRE.test(html)) dom = $(document.createElement(RegExp.$1));
            if (!dom) {
                if (html.replace) html = html.replace(tagExpanderRE, "<$1></$2>");
                if (name === undefined) name = fragmentRE.test(html) && RegExp.$1;
                if (!(name in containers)) name = "*";
                container = containers[name];
                container.innerHTML = "" + html;
                dom = $.each(slice.call(container.childNodes), function() {
                    container.removeChild(this);
                });
            }
            if (isPlainObject(properties)) {
                nodes = $(dom);
                $.each(properties, function(key, value) {
                    if (methodAttributes.indexOf(key) > -1) nodes[key](value); else nodes.attr(key, value);
                });
            }
            return dom;
        };
        // `$.zepto.Z` swaps out the prototype of the given `dom` array
        // of nodes with `$.fn` and thus supplying all the Zepto functions
        // to the array. Note that `__proto__` is not supported on Internet
        // Explorer. This method can be overriden in plugins.
        zepto.Z = function(dom, selector) {
            dom = dom || [];
            dom.__proto__ = $.fn;
            dom.selector = selector || "";
            return dom;
        };
        // `$.zepto.isZ` should return `true` if the given object is a Zepto
        // collection. This method can be overriden in plugins.
        zepto.isZ = function(object) {
            return object instanceof zepto.Z;
        };
        // `$.zepto.init` is Zepto's counterpart to jQuery's `$.fn.init` and
        // takes a CSS selector and an optional context (and handles various
        // special cases).
        // This method can be overriden in plugins.
        zepto.init = function(selector, context) {
            var dom;
            // If nothing given, return an empty Zepto collection
            if (!selector) return zepto.Z(); else if (typeof selector == "string") {
                selector = selector.trim();
                // If it's a html fragment, create nodes from it
                // Note: In both Chrome 21 and Firefox 15, DOM error 12
                // is thrown if the fragment doesn't begin with <
                if (selector[0] == "<" && fragmentRE.test(selector)) dom = zepto.fragment(selector, RegExp.$1, context), 
                selector = null; else if (context !== undefined) return $(context).find(selector); else dom = zepto.qsa(document, selector);
            } else if (isFunction(selector)) return $(document).ready(selector); else if (zepto.isZ(selector)) return selector; else {
                // normalize array if an array of nodes is given
                if (isArray(selector)) dom = compact(selector); else if (isObject(selector)) dom = [ selector ], 
                selector = null; else if (fragmentRE.test(selector)) dom = zepto.fragment(selector.trim(), RegExp.$1, context), 
                selector = null; else if (context !== undefined) return $(context).find(selector); else dom = zepto.qsa(document, selector);
            }
            // create a new Zepto collection from the nodes found
            return zepto.Z(dom, selector);
        };
        // `$` will be the base `Zepto` object. When calling this
        // function just call `$.zepto.init, which makes the implementation
        // details of selecting nodes and creating Zepto collections
        // patchable in plugins.
        $ = function(selector, context) {
            return zepto.init(selector, context);
        };
        function extend(target, source, deep) {
            for (key in source) if (deep && (isPlainObject(source[key]) || isArray(source[key]))) {
                if (isPlainObject(source[key]) && !isPlainObject(target[key])) target[key] = {};
                if (isArray(source[key]) && !isArray(target[key])) target[key] = [];
                extend(target[key], source[key], deep);
            } else if (source[key] !== undefined) target[key] = source[key];
        }
        // Copy all but undefined properties from one or more
        // objects to the `target` object.
        $.extend = function(target) {
            var deep, args = slice.call(arguments, 1);
            if (typeof target == "boolean") {
                deep = target;
                target = args.shift();
            }
            args.forEach(function(arg) {
                extend(target, arg, deep);
            });
            return target;
        };
        // `$.zepto.qsa` is Zepto's CSS selector implementation which
        // uses `document.querySelectorAll` and optimizes for some special cases, like `#id`.
        // This method can be overriden in plugins.
        zepto.qsa = function(element, selector) {
            var found, maybeID = selector[0] == "#", maybeClass = !maybeID && selector[0] == ".", nameOnly = maybeID || maybeClass ? selector.slice(1) : selector, // Ensure that a 1 char tag name still gets checked
            isSimple = simpleSelectorRE.test(nameOnly);
            // If it's simple, it could be a class
            // Or a tag
            return isDocument(element) && isSimple && maybeID ? (found = element.getElementById(nameOnly)) ? [ found ] : [] : element.nodeType !== 1 && element.nodeType !== 9 ? [] : slice.call(isSimple && !maybeID ? maybeClass ? element.getElementsByClassName(nameOnly) : element.getElementsByTagName(selector) : element.querySelectorAll(selector));
        };
        function filtered(nodes, selector) {
            return selector == null ? $(nodes) : $(nodes).filter(selector);
        }
        $.contains = function(parent, node) {
            return parent !== node && parent.contains(node);
        };
        function funcArg(context, arg, idx, payload) {
            return isFunction(arg) ? arg.call(context, idx, payload) : arg;
        }
        function setAttribute(node, name, value) {
            value == null ? node.removeAttribute(name) : node.setAttribute(name, value);
        }
        // access className property while respecting SVGAnimatedString
        function className(node, value) {
            var klass = node.className, svg = klass && klass.baseVal !== undefined;
            if (value === undefined) return svg ? klass.baseVal : klass;
            svg ? klass.baseVal = value : node.className = value;
        }
        // "true"  => true
        // "false" => false
        // "null"  => null
        // "42"    => 42
        // "42.5"  => 42.5
        // "08"    => "08"
        // JSON    => parse if valid
        // String  => self
        function deserializeValue(value) {
            var num;
            try {
                return value ? value == "true" || (value == "false" ? false : value == "null" ? null : !/^0/.test(value) && !isNaN(num = Number(value)) ? num : /^[\[\{]/.test(value) ? $.parseJSON(value) : value) : value;
            } catch (e) {
                return value;
            }
        }
        $.type = type;
        $.isFunction = isFunction;
        $.isWindow = isWindow;
        $.isArray = isArray;
        $.isPlainObject = isPlainObject;
        $.isEmptyObject = function(obj) {
            var name;
            for (name in obj) return false;
            return true;
        };
        $.inArray = function(elem, array, i) {
            return emptyArray.indexOf.call(array, elem, i);
        };
        $.camelCase = camelize;
        $.trim = function(str) {
            return str == null ? "" : String.prototype.trim.call(str);
        };
        // plugin compatibility
        $.uuid = 0;
        $.support = {};
        $.expr = {};
        $.map = function(elements, callback) {
            var value, values = [], i, key;
            if (likeArray(elements)) for (i = 0; i < elements.length; i++) {
                value = callback(elements[i], i);
                if (value != null) values.push(value);
            } else for (key in elements) {
                value = callback(elements[key], key);
                if (value != null) values.push(value);
            }
            return flatten(values);
        };
        $.each = function(elements, callback) {
            var i, key;
            if (likeArray(elements)) {
                for (i = 0; i < elements.length; i++) if (callback.call(elements[i], i, elements[i]) === false) return elements;
            } else {
                for (key in elements) if (callback.call(elements[key], key, elements[key]) === false) return elements;
            }
            return elements;
        };
        $.grep = function(elements, callback) {
            return filter.call(elements, callback);
        };
        if (window.JSON) $.parseJSON = JSON.parse;
        // Populate the class2type map
        $.each("Boolean Number String Function Array Date RegExp Object Error".split(" "), function(i, name) {
            class2type["[object " + name + "]"] = name.toLowerCase();
        });
        // Define methods that will be available on all
        // Zepto collections
        $.fn = {
            // Because a collection acts like an array
            // copy over these useful array functions.
            forEach: emptyArray.forEach,
            reduce: emptyArray.reduce,
            push: emptyArray.push,
            sort: emptyArray.sort,
            indexOf: emptyArray.indexOf,
            concat: emptyArray.concat,
            // `map` and `slice` in the jQuery API work differently
            // from their array counterparts
            map: function(fn) {
                return $($.map(this, function(el, i) {
                    return fn.call(el, i, el);
                }));
            },
            slice: function() {
                return $(slice.apply(this, arguments));
            },
            ready: function(callback) {
                // need to check if document.body exists for IE as that browser reports
                // document ready when it hasn't yet created the body element
                if (readyRE.test(document.readyState) && document.body) callback($); else document.addEventListener("DOMContentLoaded", function() {
                    callback($);
                }, false);
                return this;
            },
            get: function(idx) {
                return idx === undefined ? slice.call(this) : this[idx >= 0 ? idx : idx + this.length];
            },
            toArray: function() {
                return this.get();
            },
            size: function() {
                return this.length;
            },
            remove: function() {
                return this.each(function() {
                    if (this.parentNode != null) this.parentNode.removeChild(this);
                });
            },
            each: function(callback) {
                emptyArray.every.call(this, function(el, idx) {
                    return callback.call(el, idx, el) !== false;
                });
                return this;
            },
            filter: function(selector) {
                if (isFunction(selector)) return this.not(this.not(selector));
                return $(filter.call(this, function(element) {
                    return zepto.matches(element, selector);
                }));
            },
            add: function(selector, context) {
                return $(uniq(this.concat($(selector, context))));
            },
            is: function(selector) {
                return this.length > 0 && zepto.matches(this[0], selector);
            },
            not: function(selector) {
                var nodes = [];
                if (isFunction(selector) && selector.call !== undefined) this.each(function(idx) {
                    if (!selector.call(this, idx)) nodes.push(this);
                }); else {
                    var excludes = typeof selector == "string" ? this.filter(selector) : likeArray(selector) && isFunction(selector.item) ? slice.call(selector) : $(selector);
                    this.forEach(function(el) {
                        if (excludes.indexOf(el) < 0) nodes.push(el);
                    });
                }
                return $(nodes);
            },
            has: function(selector) {
                return this.filter(function() {
                    return isObject(selector) ? $.contains(this, selector) : $(this).find(selector).size();
                });
            },
            eq: function(idx) {
                return idx === -1 ? this.slice(idx) : this.slice(idx, +idx + 1);
            },
            first: function() {
                var el = this[0];
                return el && !isObject(el) ? el : $(el);
            },
            last: function() {
                var el = this[this.length - 1];
                return el && !isObject(el) ? el : $(el);
            },
            find: function(selector) {
                var result, $this = this;
                if (typeof selector == "object") result = $(selector).filter(function() {
                    var node = this;
                    return emptyArray.some.call($this, function(parent) {
                        return $.contains(parent, node);
                    });
                }); else if (this.length == 1) result = $(zepto.qsa(this[0], selector)); else result = this.map(function() {
                    return zepto.qsa(this, selector);
                });
                return result;
            },
            closest: function(selector, context) {
                var node = this[0], collection = false;
                if (typeof selector == "object") collection = $(selector);
                while (node && !(collection ? collection.indexOf(node) >= 0 : zepto.matches(node, selector))) node = node !== context && !isDocument(node) && node.parentNode;
                return $(node);
            },
            parents: function(selector) {
                var ancestors = [], nodes = this;
                while (nodes.length > 0) nodes = $.map(nodes, function(node) {
                    if ((node = node.parentNode) && !isDocument(node) && ancestors.indexOf(node) < 0) {
                        ancestors.push(node);
                        return node;
                    }
                });
                return filtered(ancestors, selector);
            },
            parent: function(selector) {
                return filtered(uniq(this.pluck("parentNode")), selector);
            },
            children: function(selector) {
                return filtered(this.map(function() {
                    return children(this);
                }), selector);
            },
            contents: function() {
                return this.map(function() {
                    return slice.call(this.childNodes);
                });
            },
            siblings: function(selector) {
                return filtered(this.map(function(i, el) {
                    return filter.call(children(el.parentNode), function(child) {
                        return child !== el;
                    });
                }), selector);
            },
            empty: function() {
                return this.each(function() {
                    this.innerHTML = "";
                });
            },
            // `pluck` is borrowed from Prototype.js
            pluck: function(property) {
                return $.map(this, function(el) {
                    return el[property];
                });
            },
            show: function() {
                return this.each(function() {
                    this.style.display == "none" && (this.style.display = "");
                    if (getComputedStyle(this, "").getPropertyValue("display") == "none") this.style.display = defaultDisplay(this.nodeName);
                });
            },
            replaceWith: function(newContent) {
                return this.before(newContent).remove();
            },
            wrap: function(structure) {
                var func = isFunction(structure);
                if (this[0] && !func) var dom = $(structure).get(0), clone = dom.parentNode || this.length > 1;
                return this.each(function(index) {
                    $(this).wrapAll(func ? structure.call(this, index) : clone ? dom.cloneNode(true) : dom);
                });
            },
            wrapAll: function(structure) {
                if (this[0]) {
                    $(this[0]).before(structure = $(structure));
                    var children;
                    // drill down to the inmost element
                    while ((children = structure.children()).length) structure = children.first();
                    $(structure).append(this);
                }
                return this;
            },
            wrapInner: function(structure) {
                var func = isFunction(structure);
                return this.each(function(index) {
                    var self = $(this), contents = self.contents(), dom = func ? structure.call(this, index) : structure;
                    contents.length ? contents.wrapAll(dom) : self.append(dom);
                });
            },
            unwrap: function() {
                this.parent().each(function() {
                    $(this).replaceWith($(this).children());
                });
                return this;
            },
            clone: function() {
                return this.map(function() {
                    return this.cloneNode(true);
                });
            },
            hide: function() {
                return this.css("display", "none");
            },
            toggle: function(setting) {
                return this.each(function() {
                    var el = $(this);
                    (setting === undefined ? el.css("display") == "none" : setting) ? el.show() : el.hide();
                });
            },
            prev: function(selector) {
                return $(this.pluck("previousElementSibling")).filter(selector || "*");
            },
            next: function(selector) {
                return $(this.pluck("nextElementSibling")).filter(selector || "*");
            },
            html: function(html) {
                return arguments.length === 0 ? this.length > 0 ? this[0].innerHTML : null : this.each(function(idx) {
                    var originHtml = this.innerHTML;
                    $(this).empty().append(funcArg(this, html, idx, originHtml));
                });
            },
            text: function(text) {
                return arguments.length === 0 ? this.length > 0 ? this[0].textContent : null : this.each(function() {
                    this.textContent = text === undefined ? "" : "" + text;
                });
            },
            attr: function(name, value) {
                var result;
                return typeof name == "string" && value === undefined ? this.length == 0 || this[0].nodeType !== 1 ? undefined : name == "value" && this[0].nodeName == "INPUT" ? this.val() : !(result = this[0].getAttribute(name)) && name in this[0] ? this[0][name] : result : this.each(function(idx) {
                    if (this.nodeType !== 1) return;
                    if (isObject(name)) for (key in name) setAttribute(this, key, name[key]); else setAttribute(this, name, funcArg(this, value, idx, this.getAttribute(name)));
                });
            },
            removeAttr: function(name) {
                return this.each(function() {
                    this.nodeType === 1 && setAttribute(this, name);
                });
            },
            prop: function(name, value) {
                name = propMap[name] || name;
                return value === undefined ? this[0] && this[0][name] : this.each(function(idx) {
                    this[name] = funcArg(this, value, idx, this[name]);
                });
            },
            data: function(name, value) {
                var data = this.attr("data-" + name.replace(capitalRE, "-$1").toLowerCase(), value);
                return data !== null ? deserializeValue(data) : undefined;
            },
            val: function(value) {
                return arguments.length === 0 ? this[0] && (this[0].multiple ? $(this[0]).find("option").filter(function() {
                    return this.selected;
                }).pluck("value") : this[0].value) : this.each(function(idx) {
                    this.value = funcArg(this, value, idx, this.value);
                });
            },
            offset: function(coordinates) {
                if (coordinates) return this.each(function(index) {
                    var $this = $(this), coords = funcArg(this, coordinates, index, $this.offset()), parentOffset = $this.offsetParent().offset(), props = {
                        top: coords.top - parentOffset.top,
                        left: coords.left - parentOffset.left
                    };
                    if ($this.css("position") == "static") props["position"] = "relative";
                    $this.css(props);
                });
                if (this.length == 0) return null;
                var obj = this[0].getBoundingClientRect();
                return {
                    left: obj.left + window.pageXOffset,
                    top: obj.top + window.pageYOffset,
                    width: Math.round(obj.width),
                    height: Math.round(obj.height)
                };
            },
            css: function(property, value) {
                if (arguments.length < 2) {
                    var element = this[0], computedStyle = getComputedStyle(element, "");
                    if (!element) return;
                    if (typeof property == "string") return element.style[camelize(property)] || computedStyle.getPropertyValue(property); else if (isArray(property)) {
                        var props = {};
                        $.each(isArray(property) ? property : [ property ], function(_, prop) {
                            props[prop] = element.style[camelize(prop)] || computedStyle.getPropertyValue(prop);
                        });
                        return props;
                    }
                }
                var css = "";
                if (type(property) == "string") {
                    if (!value && value !== 0) this.each(function() {
                        this.style.removeProperty(dasherize(property));
                    }); else css = dasherize(property) + ":" + maybeAddPx(property, value);
                } else {
                    for (key in property) if (!property[key] && property[key] !== 0) this.each(function() {
                        this.style.removeProperty(dasherize(key));
                    }); else css += dasherize(key) + ":" + maybeAddPx(key, property[key]) + ";";
                }
                return this.each(function() {
                    this.style.cssText += ";" + css;
                });
            },
            index: function(element) {
                return element ? this.indexOf($(element)[0]) : this.parent().children().indexOf(this[0]);
            },
            hasClass: function(name) {
                if (!name) return false;
                return emptyArray.some.call(this, function(el) {
                    return this.test(className(el));
                }, classRE(name));
            },
            addClass: function(name) {
                if (!name) return this;
                return this.each(function(idx) {
                    classList = [];
                    var cls = className(this), newName = funcArg(this, name, idx, cls);
                    newName.split(/\s+/g).forEach(function(klass) {
                        if (!$(this).hasClass(klass)) classList.push(klass);
                    }, this);
                    classList.length && className(this, cls + (cls ? " " : "") + classList.join(" "));
                });
            },
            removeClass: function(name) {
                return this.each(function(idx) {
                    if (name === undefined) return className(this, "");
                    classList = className(this);
                    funcArg(this, name, idx, classList).split(/\s+/g).forEach(function(klass) {
                        classList = classList.replace(classRE(klass), " ");
                    });
                    className(this, classList.trim());
                });
            },
            toggleClass: function(name, when) {
                if (!name) return this;
                return this.each(function(idx) {
                    var $this = $(this), names = funcArg(this, name, idx, className(this));
                    names.split(/\s+/g).forEach(function(klass) {
                        (when === undefined ? !$this.hasClass(klass) : when) ? $this.addClass(klass) : $this.removeClass(klass);
                    });
                });
            },
            scrollTop: function(value) {
                if (!this.length) return;
                var hasScrollTop = "scrollTop" in this[0];
                if (value === undefined) return hasScrollTop ? this[0].scrollTop : this[0].pageYOffset;
                return this.each(hasScrollTop ? function() {
                    this.scrollTop = value;
                } : function() {
                    this.scrollTo(this.scrollX, value);
                });
            },
            scrollLeft: function(value) {
                if (!this.length) return;
                var hasScrollLeft = "scrollLeft" in this[0];
                if (value === undefined) return hasScrollLeft ? this[0].scrollLeft : this[0].pageXOffset;
                return this.each(hasScrollLeft ? function() {
                    this.scrollLeft = value;
                } : function() {
                    this.scrollTo(value, this.scrollY);
                });
            },
            position: function() {
                if (!this.length) return;
                var elem = this[0], // Get *real* offsetParent
                offsetParent = this.offsetParent(), // Get correct offsets
                offset = this.offset(), parentOffset = rootNodeRE.test(offsetParent[0].nodeName) ? {
                    top: 0,
                    left: 0
                } : offsetParent.offset();
                // Subtract element margins
                // note: when an element has margin: auto the offsetLeft and marginLeft
                // are the same in Safari causing offset.left to incorrectly be 0
                offset.top -= parseFloat($(elem).css("margin-top")) || 0;
                offset.left -= parseFloat($(elem).css("margin-left")) || 0;
                // Add offsetParent borders
                parentOffset.top += parseFloat($(offsetParent[0]).css("border-top-width")) || 0;
                parentOffset.left += parseFloat($(offsetParent[0]).css("border-left-width")) || 0;
                // Subtract the two offsets
                return {
                    top: offset.top - parentOffset.top,
                    left: offset.left - parentOffset.left
                };
            },
            offsetParent: function() {
                return this.map(function() {
                    var parent = this.offsetParent || document.body;
                    while (parent && !rootNodeRE.test(parent.nodeName) && $(parent).css("position") == "static") parent = parent.offsetParent;
                    return parent;
                });
            }
        };
        // for now
        $.fn.detach = $.fn.remove;
        [ "width", "height" ].forEach(function(dimension) {
            var dimensionProperty = dimension.replace(/./, function(m) {
                return m[0].toUpperCase();
            });
            $.fn[dimension] = function(value) {
                var offset, el = this[0];
                if (value === undefined) return isWindow(el) ? el["inner" + dimensionProperty] : isDocument(el) ? el.documentElement["scroll" + dimensionProperty] : (offset = this.offset()) && offset[dimension]; else return this.each(function(idx) {
                    el = $(this);
                    el.css(dimension, funcArg(this, value, idx, el[dimension]()));
                });
            };
        });
        function traverseNode(node, fun) {
            fun(node);
            for (var key in node.childNodes) traverseNode(node.childNodes[key], fun);
        }
        // Generate the `after`, `prepend`, `before`, `append`,
        // `insertAfter`, `insertBefore`, `appendTo`, and `prependTo` methods.
        adjacencyOperators.forEach(function(operator, operatorIndex) {
            var inside = operatorIndex % 2;
            //=> prepend, append
            $.fn[operator] = function() {
                // arguments can be nodes, arrays of nodes, Zepto objects and HTML strings
                var argType, nodes = $.map(arguments, function(arg) {
                    argType = type(arg);
                    return argType == "object" || argType == "array" || arg == null ? arg : zepto.fragment(arg);
                }), parent, copyByClone = this.length > 1;
                if (nodes.length < 1) return this;
                return this.each(function(_, target) {
                    parent = inside ? target : target.parentNode;
                    // convert all methods to a "before" operation
                    target = operatorIndex == 0 ? target.nextSibling : operatorIndex == 1 ? target.firstChild : operatorIndex == 2 ? target : null;
                    nodes.forEach(function(node) {
                        if (copyByClone) node = node.cloneNode(true); else if (!parent) return $(node).remove();
                        traverseNode(parent.insertBefore(node, target), function(el) {
                            if (el.nodeName != null && el.nodeName.toUpperCase() === "SCRIPT" && (!el.type || el.type === "text/javascript") && !el.src) window["eval"].call(window, el.innerHTML);
                        });
                    });
                });
            };
            // after    => insertAfter
            // prepend  => prependTo
            // before   => insertBefore
            // append   => appendTo
            $.fn[inside ? operator + "To" : "insert" + (operatorIndex ? "Before" : "After")] = function(html) {
                $(html)[operator](this);
                return this;
            };
        });
        zepto.Z.prototype = $.fn;
        // Export internal API functions in the `$.zepto` namespace
        zepto.uniq = uniq;
        zepto.deserializeValue = deserializeValue;
        $.zepto = zepto;
        return $;
    }();
    window.Zepto = Zepto;
    window.$ === undefined && (window.$ = Zepto);
    (function($) {
        var $$ = $.zepto.qsa, _zid = 1, undefined, slice = Array.prototype.slice, isFunction = $.isFunction, isString = function(obj) {
            return typeof obj == "string";
        }, handlers = {}, specialEvents = {}, focusinSupported = "onfocusin" in window, focus = {
            focus: "focusin",
            blur: "focusout"
        }, hover = {
            mouseenter: "mouseover",
            mouseleave: "mouseout"
        };
        specialEvents.click = specialEvents.mousedown = specialEvents.mouseup = specialEvents.mousemove = "MouseEvents";
        function zid(element) {
            return element._zid || (element._zid = _zid++);
        }
        function findHandlers(element, event, fn, selector) {
            event = parse(event);
            if (event.ns) var matcher = matcherFor(event.ns);
            return (handlers[zid(element)] || []).filter(function(handler) {
                return handler && (!event.e || handler.e == event.e) && (!event.ns || matcher.test(handler.ns)) && (!fn || zid(handler.fn) === zid(fn)) && (!selector || handler.sel == selector);
            });
        }
        function parse(event) {
            var parts = ("" + event).split(".");
            return {
                e: parts[0],
                ns: parts.slice(1).sort().join(" ")
            };
        }
        function matcherFor(ns) {
            return new RegExp("(?:^| )" + ns.replace(" ", " .* ?") + "(?: |$)");
        }
        function eventCapture(handler, captureSetting) {
            return handler.del && (!focusinSupported && handler.e in focus) || !!captureSetting;
        }
        function realEvent(type) {
            return hover[type] || focusinSupported && focus[type] || type;
        }
        function add(element, events, fn, data, selector, delegator, capture) {
            var id = zid(element), set = handlers[id] || (handlers[id] = []);
            events.split(/\s/).forEach(function(event) {
                if (event == "ready") return $(document).ready(fn);
                var handler = parse(event);
                handler.fn = fn;
                handler.sel = selector;
                // emulate mouseenter, mouseleave
                if (handler.e in hover) fn = function(e) {
                    var related = e.relatedTarget;
                    if (!related || related !== this && !$.contains(this, related)) return handler.fn.apply(this, arguments);
                };
                handler.del = delegator;
                var callback = delegator || fn;
                handler.proxy = function(e) {
                    e = compatible(e);
                    if (e.isImmediatePropagationStopped()) return;
                    e.data = data;
                    var result = callback.apply(element, e._args == undefined ? [ e ] : [ e ].concat(e._args));
                    if (result === false) e.preventDefault(), e.stopPropagation();
                    return result;
                };
                handler.i = set.length;
                set.push(handler);
                if ("addEventListener" in element) element.addEventListener(realEvent(handler.e), handler.proxy, eventCapture(handler, capture));
            });
        }
        function remove(element, events, fn, selector, capture) {
            var id = zid(element);
            (events || "").split(/\s/).forEach(function(event) {
                findHandlers(element, event, fn, selector).forEach(function(handler) {
                    delete handlers[id][handler.i];
                    if ("removeEventListener" in element) element.removeEventListener(realEvent(handler.e), handler.proxy, eventCapture(handler, capture));
                });
            });
        }
        $.event = {
            add: add,
            remove: remove
        };
        $.proxy = function(fn, context) {
            if (isFunction(fn)) {
                var proxyFn = function() {
                    return fn.apply(context, arguments);
                };
                proxyFn._zid = zid(fn);
                return proxyFn;
            } else if (isString(context)) {
                return $.proxy(fn[context], fn);
            } else {
                throw new TypeError("expected function");
            }
        };
        $.fn.bind = function(event, data, callback) {
            return this.on(event, data, callback);
        };
        $.fn.unbind = function(event, callback) {
            return this.off(event, callback);
        };
        $.fn.one = function(event, selector, data, callback) {
            return this.on(event, selector, data, callback, 1);
        };
        var returnTrue = function() {
            return true;
        }, returnFalse = function() {
            return false;
        }, ignoreProperties = /^([A-Z]|returnValue$|layer[XY]$)/, eventMethods = {
            preventDefault: "isDefaultPrevented",
            stopImmediatePropagation: "isImmediatePropagationStopped",
            stopPropagation: "isPropagationStopped"
        };
        function compatible(event, source) {
            if (source || !event.isDefaultPrevented) {
                source || (source = event);
                $.each(eventMethods, function(name, predicate) {
                    var sourceMethod = source[name];
                    event[name] = function() {
                        this[predicate] = returnTrue;
                        return sourceMethod && sourceMethod.apply(source, arguments);
                    };
                    event[predicate] = returnFalse;
                });
                if (source.defaultPrevented !== undefined ? source.defaultPrevented : "returnValue" in source ? source.returnValue === false : source.getPreventDefault && source.getPreventDefault()) event.isDefaultPrevented = returnTrue;
            }
            return event;
        }
        function createProxy(event) {
            var key, proxy = {
                originalEvent: event
            };
            for (key in event) if (!ignoreProperties.test(key) && event[key] !== undefined) proxy[key] = event[key];
            return compatible(proxy, event);
        }
        $.fn.delegate = function(selector, event, callback) {
            return this.on(event, selector, callback);
        };
        $.fn.undelegate = function(selector, event, callback) {
            return this.off(event, selector, callback);
        };
        $.fn.live = function(event, callback) {
            $(document.body).delegate(this.selector, event, callback);
            return this;
        };
        $.fn.die = function(event, callback) {
            $(document.body).undelegate(this.selector, event, callback);
            return this;
        };
        $.fn.on = function(event, selector, data, callback, one) {
            var autoRemove, delegator, $this = this;
            if (event && !isString(event)) {
                $.each(event, function(type, fn) {
                    $this.on(type, selector, data, fn, one);
                });
                return $this;
            }
            if (!isString(selector) && !isFunction(callback) && callback !== false) callback = data, 
            data = selector, selector = undefined;
            if (isFunction(data) || data === false) callback = data, data = undefined;
            if (callback === false) callback = returnFalse;
            return $this.each(function(_, element) {
                if (one) autoRemove = function(e) {
                    remove(element, e.type, callback);
                    return callback.apply(this, arguments);
                };
                if (selector) delegator = function(e) {
                    var evt, match = $(e.target).closest(selector, element).get(0);
                    if (match && match !== element) {
                        evt = $.extend(createProxy(e), {
                            currentTarget: match,
                            liveFired: element
                        });
                        return (autoRemove || callback).apply(match, [ evt ].concat(slice.call(arguments, 1)));
                    }
                };
                add(element, event, callback, data, selector, delegator || autoRemove);
            });
        };
        $.fn.off = function(event, selector, callback) {
            var $this = this;
            if (event && !isString(event)) {
                $.each(event, function(type, fn) {
                    $this.off(type, selector, fn);
                });
                return $this;
            }
            if (!isString(selector) && !isFunction(callback) && callback !== false) callback = selector, 
            selector = undefined;
            if (callback === false) callback = returnFalse;
            return $this.each(function() {
                remove(this, event, callback, selector);
            });
        };
        $.fn.trigger = function(event, args) {
            event = isString(event) || $.isPlainObject(event) ? $.Event(event) : compatible(event);
            event._args = args;
            return this.each(function() {
                // items in the collection might not be DOM elements
                if ("dispatchEvent" in this) this.dispatchEvent(event); else $(this).triggerHandler(event, args);
            });
        };
        // triggers event handlers on current element just as if an event occurred,
        // doesn't trigger an actual event, doesn't bubble
        $.fn.triggerHandler = function(event, args) {
            var e, result;
            this.each(function(i, element) {
                e = createProxy(isString(event) ? $.Event(event) : event);
                e._args = args;
                e.target = element;
                $.each(findHandlers(element, event.type || event), function(i, handler) {
                    result = handler.proxy(e);
                    if (e.isImmediatePropagationStopped()) return false;
                });
            });
            return result;
        };
        ("focusin focusout load resize scroll unload click dblclick " + "mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave " + "change select keydown keypress keyup error").split(" ").forEach(function(event) {
            $.fn[event] = function(callback) {
                return callback ? this.bind(event, callback) : this.trigger(event);
            };
        });
        [ "focus", "blur" ].forEach(function(name) {
            $.fn[name] = function(callback) {
                if (callback) this.bind(name, callback); else this.each(function() {
                    try {
                        this[name]();
                    } catch (e) {}
                });
                return this;
            };
        });
        $.Event = function(type, props) {
            if (!isString(type)) props = type, type = props.type;
            var event = document.createEvent(specialEvents[type] || "Events"), bubbles = true;
            if (props) for (var name in props) name == "bubbles" ? bubbles = !!props[name] : event[name] = props[name];
            event.initEvent(type, bubbles, true);
            return compatible(event);
        };
    })(Zepto);
    (function($) {
        var jsonpID = 0, document = window.document, key, name, rscript = /<script\b[^<]*(?:(?!<\/script>)<[^<]*)*<\/script>/gi, scriptTypeRE = /^(?:text|application)\/javascript/i, xmlTypeRE = /^(?:text|application)\/xml/i, jsonType = "application/json", htmlType = "text/html", blankRE = /^\s*$/;
        // trigger a custom event and return false if it was cancelled
        function triggerAndReturn(context, eventName, data) {
            var event = $.Event(eventName);
            $(context).trigger(event, data);
            return !event.isDefaultPrevented();
        }
        // trigger an Ajax "global" event
        function triggerGlobal(settings, context, eventName, data) {
            if (settings.global) return triggerAndReturn(context || document, eventName, data);
        }
        // Number of active Ajax requests
        $.active = 0;
        function ajaxStart(settings) {
            if (settings.global && $.active++ === 0) triggerGlobal(settings, null, "ajaxStart");
        }
        function ajaxStop(settings) {
            if (settings.global && !--$.active) triggerGlobal(settings, null, "ajaxStop");
        }
        // triggers an extra global event "ajaxBeforeSend" that's like "ajaxSend" but cancelable
        function ajaxBeforeSend(xhr, settings) {
            var context = settings.context;
            if (settings.beforeSend.call(context, xhr, settings) === false || triggerGlobal(settings, context, "ajaxBeforeSend", [ xhr, settings ]) === false) return false;
            triggerGlobal(settings, context, "ajaxSend", [ xhr, settings ]);
        }
        function ajaxSuccess(data, xhr, settings, deferred) {
            var context = settings.context, status = "success";
            settings.success.call(context, data, status, xhr);
            if (deferred) deferred.resolveWith(context, [ data, status, xhr ]);
            triggerGlobal(settings, context, "ajaxSuccess", [ xhr, settings, data ]);
            ajaxComplete(status, xhr, settings);
        }
        // type: "timeout", "error", "abort", "parsererror"
        function ajaxError(error, type, xhr, settings, deferred) {
            var context = settings.context;
            settings.error.call(context, xhr, type, error);
            if (deferred) deferred.rejectWith(context, [ xhr, type, error ]);
            triggerGlobal(settings, context, "ajaxError", [ xhr, settings, error || type ]);
            ajaxComplete(type, xhr, settings);
        }
        // status: "success", "notmodified", "error", "timeout", "abort", "parsererror"
        function ajaxComplete(status, xhr, settings) {
            var context = settings.context;
            settings.complete.call(context, xhr, status);
            triggerGlobal(settings, context, "ajaxComplete", [ xhr, settings ]);
            ajaxStop(settings);
        }
        // Empty function, used as default callback
        function empty() {}
        $.ajaxJSONP = function(options, deferred) {
            if (!("type" in options)) return $.ajax(options);
            var _callbackName = options.jsonpCallback, callbackName = ($.isFunction(_callbackName) ? _callbackName() : _callbackName) || "jsonp" + ++jsonpID, script = document.createElement("script"), originalCallback = window[callbackName], responseData, abort = function(errorType) {
                $(script).triggerHandler("error", errorType || "abort");
            }, xhr = {
                abort: abort
            }, abortTimeout;
            if (deferred) deferred.promise(xhr);
            $(script).on("load error", function(e, errorType) {
                clearTimeout(abortTimeout);
                $(script).off().remove();
                if (e.type == "error" || !responseData) {
                    ajaxError(null, errorType || "error", xhr, options, deferred);
                } else {
                    ajaxSuccess(responseData[0], xhr, options, deferred);
                }
                window[callbackName] = originalCallback;
                if (responseData && $.isFunction(originalCallback)) originalCallback(responseData[0]);
                originalCallback = responseData = undefined;
            });
            if (ajaxBeforeSend(xhr, options) === false) {
                abort("abort");
                return xhr;
            }
            window[callbackName] = function() {
                responseData = arguments;
            };
            script.src = options.url.replace(/=\?/, "=" + callbackName);
            document.head.appendChild(script);
            if (options.timeout > 0) abortTimeout = setTimeout(function() {
                abort("timeout");
            }, options.timeout);
            return xhr;
        };
        $.ajaxSettings = {
            // Default type of request
            type: "GET",
            // Callback that is executed before request
            beforeSend: empty,
            // Callback that is executed if the request succeeds
            success: empty,
            // Callback that is executed the the server drops error
            error: empty,
            // Callback that is executed on request complete (both: error and success)
            complete: empty,
            // The context for the callbacks
            context: null,
            // Whether to trigger "global" Ajax events
            global: true,
            // Transport
            xhr: function() {
                return new window.XMLHttpRequest();
            },
            // MIME types mapping
            // IIS returns Javascript as "application/x-javascript"
            accepts: {
                script: "text/javascript, application/javascript, application/x-javascript",
                json: jsonType,
                xml: "application/xml, text/xml",
                html: htmlType,
                text: "text/plain"
            },
            // Whether the request is to another domain
            crossDomain: false,
            // Default timeout
            timeout: 0,
            // Whether data should be serialized to string
            processData: true,
            // Whether the browser should be allowed to cache GET responses
            cache: true
        };
        function mimeToDataType(mime) {
            if (mime) mime = mime.split(";", 2)[0];
            return mime && (mime == htmlType ? "html" : mime == jsonType ? "json" : scriptTypeRE.test(mime) ? "script" : xmlTypeRE.test(mime) && "xml") || "text";
        }
        function appendQuery(url, query) {
            if (query == "") return url;
            return (url + "&" + query).replace(/[&?]{1,2}/, "?");
        }
        // serialize payload and append it to the URL for GET requests
        function serializeData(options) {
            if (options.processData && options.data && $.type(options.data) != "string") options.data = $.param(options.data, options.traditional);
            if (options.data && (!options.type || options.type.toUpperCase() == "GET")) options.url = appendQuery(options.url, options.data), 
            options.data = undefined;
        }
        $.ajax = function(options) {
            var settings = $.extend({}, options || {}), deferred = $.Deferred && $.Deferred();
            for (key in $.ajaxSettings) if (settings[key] === undefined) settings[key] = $.ajaxSettings[key];
            ajaxStart(settings);
            if (!settings.crossDomain) settings.crossDomain = /^([\w-]+:)?\/\/([^\/]+)/.test(settings.url) && RegExp.$2 != window.location.host;
            if (!settings.url) settings.url = window.location.toString();
            serializeData(settings);
            if (settings.cache === false) settings.url = appendQuery(settings.url, "_=" + Date.now());
            var dataType = settings.dataType, hasPlaceholder = /=\?/.test(settings.url);
            if (dataType == "jsonp" || hasPlaceholder) {
                if (!hasPlaceholder) settings.url = appendQuery(settings.url, settings.jsonp ? settings.jsonp + "=?" : settings.jsonp === false ? "" : "callback=?");
                return $.ajaxJSONP(settings, deferred);
            }
            var mime = settings.accepts[dataType], headers = {}, setHeader = function(name, value) {
                headers[name.toLowerCase()] = [ name, value ];
            }, protocol = /^([\w-]+:)\/\//.test(settings.url) ? RegExp.$1 : window.location.protocol, xhr = settings.xhr(), nativeSetHeader = xhr.setRequestHeader, abortTimeout;
            if (deferred) deferred.promise(xhr);
            if (!settings.crossDomain) setHeader("X-Requested-With", "XMLHttpRequest");
            setHeader("Accept", mime || "*/*");
            if (mime = settings.mimeType || mime) {
                if (mime.indexOf(",") > -1) mime = mime.split(",", 2)[0];
                xhr.overrideMimeType && xhr.overrideMimeType(mime);
            }
            if (settings.contentType || settings.contentType !== false && settings.data && settings.type.toUpperCase() != "GET") setHeader("Content-Type", settings.contentType || "application/x-www-form-urlencoded");
            if (settings.headers) for (name in settings.headers) setHeader(name, settings.headers[name]);
            xhr.setRequestHeader = setHeader;
            xhr.onreadystatechange = function() {
                if (xhr.readyState == 4) {
                    xhr.onreadystatechange = empty;
                    clearTimeout(abortTimeout);
                    var result, error = false;
                    if (xhr.status >= 200 && xhr.status < 300 || xhr.status == 304 || xhr.status == 0 && protocol == "file:") {
                        dataType = dataType || mimeToDataType(settings.mimeType || xhr.getResponseHeader("content-type"));
                        result = xhr.responseText;
                        try {
                            // http://perfectionkills.com/global-eval-what-are-the-options/
                            if (dataType == "script") (1, eval)(result); else if (dataType == "xml") result = xhr.responseXML; else if (dataType == "json") result = blankRE.test(result) ? null : $.parseJSON(result);
                        } catch (e) {
                            error = e;
                        }
                        if (error) ajaxError(error, "parsererror", xhr, settings, deferred); else ajaxSuccess(result, xhr, settings, deferred);
                    } else {
                        ajaxError(xhr.statusText || null, xhr.status ? "error" : "abort", xhr, settings, deferred);
                    }
                }
            };
            if (ajaxBeforeSend(xhr, settings) === false) {
                xhr.abort();
                ajaxError(null, "abort", xhr, settings, deferred);
                return xhr;
            }
            if (settings.xhrFields) for (name in settings.xhrFields) xhr[name] = settings.xhrFields[name];
            var async = "async" in settings ? settings.async : true;
            xhr.open(settings.type, settings.url, async, settings.username, settings.password);
            for (name in headers) nativeSetHeader.apply(xhr, headers[name]);
            if (settings.timeout > 0) abortTimeout = setTimeout(function() {
                xhr.onreadystatechange = empty;
                xhr.abort();
                ajaxError(null, "timeout", xhr, settings, deferred);
            }, settings.timeout);
            // avoid sending empty string (#319)
            xhr.send(settings.data ? settings.data : null);
            return xhr;
        };
        // handle optional data/success arguments
        function parseArguments(url, data, success, dataType) {
            var hasData = !$.isFunction(data);
            return {
                url: url,
                data: hasData ? data : undefined,
                success: !hasData ? data : $.isFunction(success) ? success : undefined,
                dataType: hasData ? dataType || success : success
            };
        }
        $.get = function(url, data, success, dataType) {
            return $.ajax(parseArguments.apply(null, arguments));
        };
        $.post = function(url, data, success, dataType) {
            var options = parseArguments.apply(null, arguments);
            options.type = "POST";
            return $.ajax(options);
        };
        $.getJSON = function(url, data, success) {
            var options = parseArguments.apply(null, arguments);
            options.dataType = "json";
            return $.ajax(options);
        };
        $.fn.load = function(url, data, success) {
            if (!this.length) return this;
            var self = this, parts = url.split(/\s/), selector, options = parseArguments(url, data, success), callback = options.success;
            if (parts.length > 1) options.url = parts[0], selector = parts[1];
            options.success = function(response) {
                self.html(selector ? $("<div>").html(response.replace(rscript, "")).find(selector) : response);
                callback && callback.apply(self, arguments);
            };
            $.ajax(options);
            return this;
        };
        var escape = encodeURIComponent;
        function serialize(params, obj, traditional, scope) {
            var type, array = $.isArray(obj), hash = $.isPlainObject(obj);
            $.each(obj, function(key, value) {
                type = $.type(value);
                if (scope) key = traditional ? scope : scope + "[" + (hash || type == "object" || type == "array" ? key : "") + "]";
                // handle data in serializeArray() format
                if (!scope && array) params.add(value.name, value.value); else if (type == "array" || !traditional && type == "object") serialize(params, value, traditional, key); else params.add(key, value);
            });
        }
        $.param = function(obj, traditional) {
            var params = [];
            params.add = function(k, v) {
                this.push(escape(k) + "=" + escape(v));
            };
            serialize(params, obj, traditional);
            return params.join("&").replace(/%20/g, "+");
        };
    })(Zepto);
    (function($) {
        $.fn.serializeArray = function() {
            var result = [], el;
            $([].slice.call(this.get(0).elements)).each(function() {
                el = $(this);
                var type = el.attr("type");
                if (this.nodeName.toLowerCase() != "fieldset" && !this.disabled && type != "submit" && type != "reset" && type != "button" && (type != "radio" && type != "checkbox" || this.checked)) result.push({
                    name: el.attr("name"),
                    value: el.val()
                });
            });
            return result;
        };
        $.fn.serialize = function() {
            var result = [];
            this.serializeArray().forEach(function(elm) {
                result.push(encodeURIComponent(elm.name) + "=" + encodeURIComponent(elm.value));
            });
            return result.join("&");
        };
        $.fn.submit = function(callback) {
            if (callback) this.bind("submit", callback); else if (this.length) {
                var event = $.Event("submit");
                this.eq(0).trigger(event);
                if (!event.isDefaultPrevented()) this.get(0).submit();
            }
            return this;
        };
    })(Zepto);
    (function($) {
        // __proto__ doesn't exist on IE<11, so redefine
        // the Z function to use object extension instead
        if (!("__proto__" in {})) {
            $.extend($.zepto, {
                Z: function(dom, selector) {
                    dom = dom || [];
                    $.extend(dom, $.fn);
                    dom.selector = selector || "";
                    dom.__Z = true;
                    return dom;
                },
                // this is a kludge but works
                isZ: function(object) {
                    return $.type(object) === "array" && "__Z" in object;
                }
            });
        }
        // getComputedStyle shouldn't freak out when called
        // without a valid element as argument
        try {
            getComputedStyle(undefined);
        } catch (e) {
            var nativeGetComputedStyle = getComputedStyle;
            window.getComputedStyle = function(element) {
                try {
                    return nativeGetComputedStyle(element);
                } catch (e) {
                    return null;
                }
            };
        }
    })(Zepto);
}.bind(this));

require.register("app/custom/helpers/helpers.js", function(exports, require, module) {
    module.exports = {
        timeAgo: function(time) {
            var now = Date.now();
            var difference = now - time;
            var minute = 6e4;
            var hour = 60 * minute;
            var day = 24 * hour;
            if (difference < minute) {
                return "Just Now";
            } else if (difference < hour) {
                var minutes = ~~(difference / minute);
                return minutes + "m ago";
            } else if (difference < day) {
                var hours = ~~(difference / hour);
                return hours + "h ago";
            } else {
                var days = ~~(difference / day);
                return days + "d ago";
            }
        },
        timeSince: function(time) {
            var now = Date.now();
            var timeObj = new Date(time);
            var today = now - now % (36e5 * 24);
            if (time >= today) {
                return timeObj.toTimeString().split(" ")[0].substring(0, 5);
            } else if (today - 36e5 * 24 <= time && time < today) {
                return "yesterday";
            } else if (today - 36e5 * 24 * 7 <= time && time < today - 36e5 * 24) {
                return timeObj.toDateString().split(" ")[0];
            } else {
                return timeObj.toLocaleDateString();
            }
        },
        capitalize: function(string) {
            return string.charAt(0).toUpperCase() + string.substring(1).toLowerCase();
        },
        // functions that generate constant results
        isDev: _.memoize(function() {
            return window.location.host.indexOf("localhost:3") == 0;
        }),
        isMobile: _.memoize(function() {
            return /Android|webOS|iPhone|iPad|iPod|BlackBerry/i.test(navigator.userAgent);
        }),
        linkify: function(text) {
            var urlRegex = /(\b(https?|ftp|file):\/\/[-A-Z0-9+&@#\/%?=~_|!:,.;]*[-A-Z0-9+&@#\/%=~_|])/gi;
            return text.replace(urlRegex, function(url) {
                return '<a href="' + url + '">' + url + "</a>";
            });
        }
    };
}.bind(this));

require.register("app/custom/templates/templates.js", function(exports, require, module) {
    var Helpers = require("helpers");
    var Utility = require("famous/utilities/utility");
    module.exports = {
        toggleSwitch: function(id, checked, disabled) {
            var html = [ '<div class="onoffswitch">', '<input type="checkbox" name="onoffswitch" class="onoffswitch-checkbox" id="', id, '" ' ];
            if (checked) html.push("checked ");
            if (disabled) html.push("disabled ");
            html.push('><label class="onoffswitch-label');
            if (disabled) html.push(" disabled");
            html = html.concat([ '" for="', id, '">', '<div class="onoffswitch-inner"></div>', '<div class="onoffswitch-switch"></div>', "</label>", "</div>" ]);
            return html.join("");
        },
        toggleButton: function(options) {
            if (!options.id) options.id = "toggleButton" + Math.floor(1e5 * Math.random());
            if (!options.classes) options.classes = [];
            var html = [ '<div class="onoffbutton ' + options.classes.join(" ") + '">', '<input type="checkbox" name="onoffbutton" class="onoffbutton-checkbox"' ];
            if (options.id) html.push(' id="' + options.id + '" ');
            if (options.checked) html.push("checked");
            html.push('><label class="onoffbutton-label" for="' + options.id + '"');
            if (options.size) {
                html = html.concat([ 'style="width:' + options.size[0] + "px;", "line-height:" + options.size[1] + 'px;"' ]);
            }
            html.push('><div class="onoffbutton-on"');
            if (options.onBackgroundColor) {
                html.push('style="background-color:' + options.onBackgroundColor + ';"');
            }
            html.push(">" + options.onContent + "</div>");
            html.push('<div class="onoffbutton-off"');
            if (options.offBackgroundColor) {
                html.push('style="background-color:' + options.offBackgroundColor + ';"');
            }
            html = html.concat([ ">" + options.offContent + "</div>", "</label>", "</div>" ]);
            return html.join("");
        },
        deleteButton: function() {
            return '<button class="delete-button fa fa-trash-o fa-lg"></button>';
        },
        addButton: function(id) {
            return '<i class="fa fa-plus add-button" id="' + id + '"></i>';
        },
        plusButton: function(id) {
            return [ '<span class="fa-stack fa-lg delete-button2" id="', id, '"><i class="fa fa-circle fa-stack"></i>', '<i class="fa fa-plus fa-stack"></i>', "</span>" ].join("");
        },
        phoneButton: function(id) {
            return [ '<span class="fa-stack fa-lg phone-button" id="', id, '"><i class="fa fa-square fa-stack-2x fa-background"></i>', '<i class="fa fa-phone fa-stack-1x fa-frontground"></i>', "</span>" ].join("");
        },
        removeButton: function(id) {
            return '<i class="fa fa-times remove-button" id="' + id + '"></i>';
        },
        editButton: function(id) {
            return [ '<span class="fa-stack edit-button2" id="', id, '"><i class="fa fa-circle-o fa-stack-2x fa-background"></i>', '<i class="fa fa-info fa-stack-1x fa-frontground"></i>', "</span>" ].join("");
        },
        crossButton: function(id) {
            return [ '<span class="fa-stack delete-button2" id="', id, '"><i class="fa fa-circle-o fa-stack-2x fa-background"></i>', '<i class="fa fa-times fa-stack-1x fa-frontground"></i>', "</span>" ].join("");
        },
        favoriteButton2: function(ative, id) {
            var html = [ '<span class="fa-stack favorite-button2" id="', id, '"><i class="fa fa-circle fa-stack-2x fa-background"></i>', '<i class="fa fa-star fa-stack-1x fa-frontground' ];
            if (ative) html.push(" active");
            html.push('"></i></span>');
            return html.join("");
        },
        nextButton: function(id) {
            return '<i class="arrow fa fa-angle-right fa-lg import-contact" id="' + id + '"></i>';
        },
        favoriteButton: function(active) {
            var html = [ '<i class="favorite-button fa fa-star fa-2x' ];
            if (active) html.push(" active");
            html.push('"></i>');
            return html.join("");
        },
        button: function(options) {
            if (!options.id) options.id = "button" + Math.floor(1e5 * Math.random());
            if (!options.classes) options.classes = [];
            var html = [ '<button class="button ' + options.classes.join(" ") + '" style="' ];
            if (options.size) {
                html = html.concat([ "width:" + options.size[0] + "px;", "height:" + options.size[1] + "px;", "line-height:" + options.size[1] + "px;" ]);
            }
            html.push('">' + options.content + "</button>");
            return html.join("");
        },
        itemFrame: function(marginLeft, marginRight) {
            var realWidth = window.innerWidth - marginLeft - marginRight;
            return [ '<div class="item-frame" style="width: ', realWidth, "px; margin-left: ", marginLeft, "px; margin-right: ", marginRight, 'px"></div>' ].join("");
        },
        recentItemView: function(call) {
            var name;
            if (call.get("firstname") || call.get("lastname")) {
                name = call.get("firstname") + " <b>" + call.get("lastname") + "</b>";
            } else {
                name = call.get("email");
            }
            var icon = "";
            var missed = "";
            if (call.get("type") == "outgoing") icon = '<i class="fa fa-sign-out"></i>'; else {
                if (!call.get("success")) missed = "missed";
            }
            return [ '<div style = " width: ', window.innerWidth, 'px"><div class="source ', missed, '"><div class="call-type">', icon, "</div>", name, '<div class="call-time">', Helpers.timeSince(call.get("time")), "</div></div></div>" ].join("");
        },
        chatItemView: function(contact) {
            var name;
            var initial = "";
            if (contact.get("firstname") || contact.get("lastname")) {
                name = contact.get("firstname") + " <b>" + contact.get("lastname") + "</b>";
                if (contact.get("firstname")) initial = contact.get("firstname")[0];
                if (contact.get("lastname")) initial += contact.get("lastname")[0];
            } else {
                name = contact.get("email");
                if (name) initial = name[0];
            }
            return [ '<div style = " width: ', window.innerWidth, 'px"><div class="source"><div class="initial ', contact.get("read") ? "" : "unread", '">', initial, "</div>", name, '<div class="call-time">', Helpers.timeSince(contact.get("time")), "</div>", '<div class="message">', contact.get("content"), "</div></div>" ].join("");
        },
        contactItemView: function(model) {
            var name;
            if (model.get("firstname") || model.get("lastname")) {
                name = [ model.get("firstname"), " <b>", model.get("lastname"), "</b>" ].join("");
            } else {
                name = model.get("email");
            }
            var contact = [ '<div style = " width: ', window.innerWidth, 'px"><div class="source">', name ].join("");
            if (model.attributes.email) contact = [ contact, '<i class="fa fa-envelope contact-icon"></i>' ].join("");
            if (model.attributes.facebook) contact = [ contact, '<i class="fa fa-facebook-square contact-icon"></i>' ].join("");
            if (model.attributes.google) contact = [ contact, '<i class="fa fa-google-plus-square contact-icon"></i>' ].join("");
            contact = [ contact, "</div></div>" ].join("");
            return contact;
        },
        favoriteItemView: function(contact) {
            var name;
            var initial = "";
            if (contact.get("firstname") || contact.get("lastname")) {
                name = contact.get("firstname") + " <b>" + contact.get("lastname") + "</b>";
                if (contact.get("firstname")) initial = contact.get("firstname")[0];
                if (contact.get("lastname")) initial += contact.get("lastname")[0];
            } else {
                name = contact.get("email");
                if (name) initial = name[0];
            }
            return [ '<div style = " width: ', window.innerWidth, 'px"><div class="source"><div class="initial">', initial, "</div>", name, "</div></div>" ].join("");
        },
        headerItemView: function(isFirst, marginLeft, marginRight) {
            var realWidth = window.innerWidth - marginLeft - marginRight;
            return [ '<div class="header-view" style="width: ', realWidth, "px; margin-left: ", marginLeft, "px; margin-right: ", marginRight, 'px">', isFirst, "</div>" ].join("");
        },
        fateHeaderItemView: function(marginLeft, marginRight) {
            var realWidth = window.innerWidth - marginLeft - marginRight;
            return [ '<div class="header-view" style="width: ', realWidth, "px; margin-left: ", marginLeft, "px; margin-right: ", marginRight, 'px"></div>' ].join("");
        },
        socialItemView: function(model) {
            var name;
            if (model.get("firstname") || model.get("lastname")) {
                name = [ model.get("firstname"), " <b>", model.get("lastname"), "</b>" ].join("");
            } else {
                name = model.get("email");
            }
            var contact = [ '<div style = " width: ', window.innerWidth, 'px"><div class="source">', name ].join("");
            contact = [ contact, "</div></div>" ].join("");
            return contact;
        },
        editContactHeader: function(title) {
            return [ '<button class="left close-button cancel-contact touchable" id="close-button">Cancel</button><div>', title, '</div><button class="right close-button done-contact touchable">Done</button>' ].join("");
        },
        recentsHeader: function() {
            var content = [ '<div class="recent-toggle"><input type="radio" id="all" name="recents-toggle" value="all" checked>', '<label for="all" class="first" id="recent-toggle">all</label>', '<input type="radio" id="missed" name="recents-toggle" value="missed">', '<label for="missed" class="last" id="recent-toggle">missed</label></div>', '<button class="right clear-button" id="clear-button"></button>' ];
            if (!Helpers.isMobile()) {
                content = [ '<button class="left edit-button touchable" id="recent-edit-contact"></button>' ].concat(content);
            }
            return content.join("");
        },
        chatsHeader: function() {
            return [ '<button class="left edit-button touchable" id="chats-edit-contact"></button><div>Messages</div>' ].join("");
        },
        favoriteHeader: function() {
            return '<button class="left edit-button touchable" id="favorite-edit-contact"></button><div>Favorites</div>';
        },
        conversationViewHeader: function(callee) {
            var name;
            if (callee) {
                if (callee.get("firstname") || callee.get("lastname")) {
                    name = [ callee.get("firstname"), " <b>", callee.get("lastname"), "</b>" ].join("");
                } else {
                    name = callee.get("email");
                }
            } else {
                name = "Shana <b> Ho </b>";
            }
            var content = [ '<div class="touchable"><i class="fa fa-chevron-left fa-lg"></i><span class="conversation-callee">', name, "</span></div>" ].join("");
            return content;
        },
        conversationInputBar: function() {
            return [ '<div><button class="fa fa-comments-o menu-toggle-button fade"></button>', '<button class="fa fa-phone menu-end-button"></button>', '<textarea class="input-msg" name="message"></textarea>', '<button class="send-text-button">Send</button></div>' ].join("");
        },
        settingsPage: function(appSettings) {
            var html = [ '<div class="box">', '<div class="info">' + appSettings.get("firstname") + " " + appSettings.get("lastname"), '<button class="logout-button">Log Out</button></div>', '<div class="desc"></div>', '<div class="info">ID: ' + appSettings.get("username") + "</div>", '<div class="desc"></div>', '<div class="info">Camera ', this.toggleSwitch("camera", appSettings.get("camera")) + "</div>", '<div class="info">Blur ', this.toggleSwitch("blur", appSettings.get("blur")) + "</div>" ];
            if (!Utility.isMobile()) {
                html.push('<div class="info">Notification ');
                html.push(this.toggleSwitch("notification", appSettings.get("notification")) + "</div>");
            }
            html = html.concat([ '<div class="desc">YOU CAN BE REACHED AT</div>', '<div class="info">Facebook ', this.toggleSwitch("facebook", appSettings.get("linkAccounts").facebook) + "</div>", '<div class="info">Google ', this.toggleSwitch("google", appSettings.get("linkAccounts").google) + "</div>", '<div class="info">Linkedin ', this.toggleSwitch("linkedin", appSettings.get("linkAccounts").linkedin) + "</div>", '<div class="info">Github ', this.toggleSwitch("github", appSettings.get("linkAccounts").github) + "</div>", '<div class="info">Yammer ', this.toggleSwitch("yammer", appSettings.get("linkAccounts").yammer) + "</div>" ]);
            if (Helpers.isDev()) {
                html = html.concat([ '<div class="desc">Testing</div>', '<div class="info"><button class="call-button">Call</button>', '<button class="incoming-button">Incoming</button>', '<button class="connected-button">Connected</button>', '<button class="conversations-button">Message</button></div>', "</div>" ]);
            }
            return html.join("");
        },
        abcButtons: function() {
            return '<button id="A">A</button><button id="B">B</button><button id="C">C</button><button id="D">D</button><button id="E">E</button><button id="F">F</button><button id="G">G</button><button id="H">H</button><button id="I">I</button><button id="J">J</button><button id="K">K</button><button id="L">L</button><button id="M">M</button><button id="N">N</button><button id="O">O</button><button id="P">P</button><button id="Q">Q</button><button id="R">R</button><button id="S">S</button><button id="T">T</button><button id="U">U</button><button id="V">V</button><button id="W">W</button><button id="X">X</button><button id="Y">Y</button><button id="Z">Z</button><button id="#">#</button>';
        },
        navigationButton: function(options, badge) {
            return [ '<div><span class="icon ', options.caption.toLowerCase(), '"><div class="badge">', badge, "</div>", options.icon, "</span><br />", options.caption, "</div>" ].join("");
        },
        getFacebookInvite: function(contact) {
            if (!contact.facebook || !contact.dcr || contact.cid) return "";
            return [ '<a class="touchable button invite-button" target="_self" href="', "https://www.facebook.com/dialog/send?", "app_id=648143008577417", "&link=", encodeURI("https://beepe.me/welcome?r="), contact.dcr, "&to=", contact.facebook.id, "&display=popup", "&redirect_uri=", encodeURI("https://beepe.me"), '">Invite</a>' ].join("");
        },
        getSMSInvite: function(contact) {
            if (!Helpers.isMobile() || !contact.phone || !contact.dcr || contact.cid) return "";
            return [ '<a class="touchable button invite-button" target="_blank" href="', "sms:", encodeURI(contact.phone), encodeURI("?body=Hey, call me back on "), encodeURI("https://beepe.me/welcome?r="), contact.dcr, '">Invite</a>' ].join("");
        },
        getEmailInvite: function(contact) {
            if (!contact.email || !contact.dcr || contact.cid) return "";
            return [ '<a class="touchable button invite-button" target="_blank" href="', "mailto:", encodeURI(contact.email), encodeURI("?subject=I just added you on my Beepe contact list"), encodeURI("&body=Now you can call me back on \n\n"), encodeURI("https://beepe.me/welcome?r="), contact.dcr, '">Invite</a>' ].join("");
        }
    };
}.bind(this));

require.register("famous_modules/famous/entity/_git_master/index.js", function(exports, require, module) {
    /**
     * @class Entity.
     * @description A singleton class that maintains a 
     *    global registry of rendered surfaces
     * @name Entity
     * 
     */
    var entities = [];
    function register(entity) {
        var id = entities.length;
        set(id, entity);
        return id;
    }
    function get(id) {
        return entities[id];
    }
    function set(id, entity) {
        entities[id] = entity;
    }
    module.exports = {
        register: register,
        get: get,
        set: set
    };
}.bind(this));

require.register("famous_modules/famous/surface/_git_master/index.js", function(exports, require, module) {
    var Entity = require("famous/entity");
    var EventHandler = require("famous/event-handler");
    var Transform = require("famous/transform");
    var usePrefix = document.body.style.webkitTransform !== undefined;
    /**
     * @class Surface
     * @description A base class for viewable content and event
     *    targets inside a Famous applcation, containing a renderable document
     *    fragment. Like an HTML div, it can accept internal markup,
     *    properties, classes, and handle events. This is a public
     *    interface and can be extended.
     * 
     * @name Surface
     * @constructor
     * 
     * @param {Array.<number>} size Width and height in absolute pixels (array of ints)
     * @param {string} content Document content (e.g. HTML) managed by this
     *    surface.
     */
    function Surface(options) {
        this.options = {};
        this.properties = {};
        this.content = "";
        this.classList = [];
        this.size = undefined;
        this._classesDirty = true;
        this._stylesDirty = true;
        this._sizeDirty = true;
        this._contentDirty = true;
        this._dirtyClasses = [];
        this._matrix = undefined;
        this._opacity = 1;
        this._origin = undefined;
        this._size = undefined;
        /** @ignore */
        this.eventForwarder = function(event) {
            this.emit(event.type, event);
        }.bind(this);
        this.eventHandler = new EventHandler();
        this.eventHandler.bindThis(this);
        this.id = Entity.register(this);
        if (options) this.setOptions(options);
        this._currTarget = undefined;
    }
    Surface.prototype.elementType = "div";
    Surface.prototype.elementClass = "famous-surface";
    /**
     * Bind a handler function to occurrence of event type on this surface.
     *   Document events have the opportunity to first be intercepted by the 
     *   on() method of the Surface upon which the event occurs, then 
     *   by the on() method of the FamousContext containing that surface, and
     *   finally as a default, the FamousEngine itself.
     * 
     * @name Surface#on
     * @function
     * @param  {string} type event type key (for example, 'click')
     * @param {function(string, Object)} handler callback
     */
    Surface.prototype.on = function(type, fn) {
        if (this._currTarget) this._currTarget.addEventListener(type, this.eventForwarder);
        this.eventHandler.on(type, fn);
    };
    /**
     * Unbind an event by type and handler.  
     *   This undoes the work of {@link Surface#on}
     * 
     * @name Surface#unbind
     * @function
     * @param {string} type event type key (for example, 'click')
     * @param {function(string, Object)} handler 
     */
    Surface.prototype.unbind = function(type, fn) {
        this.eventHandler.unbind(type, fn);
    };
    /**
     * Trigger an event, sending to all downstream handlers
     *   matching provided 'type' key.
     * 
     * @name Surface#emit
     * @function
     * @param  {string} type event type key (for example, 'click')
     * @param  {Object} event event data
     * @returns {boolean}  true if event was handled along the event chain.
     */
    Surface.prototype.emit = function(type, event) {
        if (event && !event.origin) event.origin = this;
        var handled = this.eventHandler.emit(type, event);
        if (handled && event.stopPropagation) event.stopPropagation();
        return handled;
    };
    /**
     * Pipe all events to a target {@link emittoerObject}
     *
     * @name Surface#pipe
     * @function
     * @param {emitterObject} target emitter object
     * @returns {emitterObject} target (to allow for chaining)
     */
    Surface.prototype.pipe = function(target) {
        return this.eventHandler.pipe(target);
    };
    /**
     * Stop piping all events at the FamousEngine level to a target emitter 
     *   object.  Undoes the work of #pipe.
     * 
     * @name Surface#unpipe
     * @function
     * @param {emitterObject} target emitter object
     */
    Surface.prototype.unpipe = function(target) {
        return this.eventHandler.unpipe(target);
    };
    /**
     * Return spec for this surface. Note that for a base surface, this is
     *    simply an id.
     * 
     * (Scope: Device developers and deeper)
     * @name Surface#render
     * @function
     * @returns {number} Spec for this surface (spec id)
     */
    Surface.prototype.render = function() {
        return this.id;
    };
    /**
     * Set CSS-style properties on this Surface. Note that this will cause
     *    dirtying and thus re-rendering, even if values do not change (confirm)
     *    
     * @name Surface#setProperties
     * @function
     * @param {Object} properties property dictionary of "key" => "value"
     */
    Surface.prototype.setProperties = function(properties) {
        for (var n in properties) {
            this.properties[n] = properties[n];
        }
        this._stylesDirty = true;
    };
    /**
     * Get CSS-style properties on this Surface.
     * 
     * @name Surface#getProperties
     * @function
     * @returns {Object} Dictionary of properties of this Surface.
     */
    Surface.prototype.getProperties = function() {
        return this.properties;
    };
    /**
     * Add CSS-style class to the list of classes on this Surface. Note
     *   this will map directly to the HTML property of the actual
     *   corresponding rendered <div>. 
     *   These will be deployed to the document on call to .setup().
     *    
     * @param {string} className name of class to add
     */
    Surface.prototype.addClass = function(className) {
        if (this.classList.indexOf(className) < 0) {
            this.classList.push(className);
            this._classesDirty = true;
        }
    };
    /**
     * Remove CSS-style class from the list of classes on this Surface.
     *   Note this will map directly to the HTML property of the actual
     *   corresponding rendered <div>. 
     *   These will be deployed to the document on call to #setup().
     *    
     * @name Surface#removeClass
     * @function
     * @param {string} className name of class to remove
     */
    Surface.prototype.removeClass = function(className) {
        var i = this.classList.indexOf(className);
        if (i >= 0) {
            this._dirtyClasses.push(this.classList.splice(i, 1)[0]);
            this._classesDirty = true;
        }
    };
    Surface.prototype.setClasses = function(classList) {
        var removal = [];
        for (var i = 0; i < this.classList.length; i++) {
            if (classList.indexOf(this.classList[i]) < 0) removal.push(this.classList[i]);
        }
        for (var i = 0; i < removal.length; i++) this.removeClass(removal[i]);
        // duplicates are already checked by addClass()
        for (var i = 0; i < classList.length; i++) this.addClass(classList[i]);
    };
    /**
     * Get array of CSS-style classes attached to this div.
     * 
     * @name Surface#getClasslist
     * @function
     * @returns {Array.<string>} Returns an array of classNames
     */
    Surface.prototype.getClassList = function() {
        return this.classList;
    };
    /**
     * Set or overwrite inner (HTML) content of this surface. Note that this
     *    causes a re-rendering if the content has changed.
     * 
     * @name Surface#setContent
     * @function
     *    
     * @param {string} content HTML content
     */
    Surface.prototype.setContent = function(content) {
        if (this.content != content) {
            this.content = content;
            this._contentDirty = true;
        }
    };
    /**
     * Return inner (HTML) content of this surface.
     * 
     * @name Surface#getContent
     * @function
     * 
     * @returns {string} inner (HTML) content
     */
    Surface.prototype.getContent = function() {
        return this.content;
    };
    /**
     * Set options for this surface
     *
     * @name Surface#setOptions
     * @function
     *
     * @param {Object} options options hash
     */
    Surface.prototype.setOptions = function(options) {
        if (options.size) this.setSize(options.size);
        if (options.classes) this.setClasses(options.classes);
        if (options.properties) this.setProperties(options.properties);
        if (options.content) this.setContent(options.content);
    };
    /**
     *   Attach Famous event handling to document events emanating from target
     *     document element.  This occurs just after deployment to the document.
     *     Calling this enables methods like #on and #pipe.
     *    
     * @private
     * @param {Element} target document element
     */
    function _bindEvents(target) {
        for (var i in this.eventHandler.listeners) {
            target.addEventListener(i, this.eventForwarder);
        }
    }
    /**
     *   Detach Famous event handling from document events emanating from target
     *     document element.  This occurs just before recall from the document.
     *     Calling this enables methods like #on and #pipe.
     *    
     * 
     * @name Surface#_unbindEvents
     * @function
     * @private
     * @param {Element} target document element
     */
    function _unbindEvents(target) {
        for (var i in this.eventHandler.listeners) {
            target.removeEventListener(i, this.eventForwarder);
        }
    }
    /**
     *  Apply to document all changes from #removeClass since last #setup().
     *    
     * @name Surface#_cleanupClasses
     * @function
     * @private
     * @param {Element} target document element
     */
    function _cleanupClasses(target) {
        for (var i = 0; i < this._dirtyClasses.length; i++) target.classList.remove(this._dirtyClasses[i]);
        this._dirtyClasses = [];
    }
    /**
     * Apply values of all Famous-managed styles to the document element.
     *   These will be deployed to the document on call to #setup().
     * 
     * @name Surface#_applyStyles
     * @function
     * @private
     * @param {Element} target document element
     */
    function _applyStyles(target) {
        for (var n in this.properties) {
            target.style[n] = this.properties[n];
        }
    }
    /**
     * Clear all Famous-managed styles from the document element.
     *   These will be deployed to the document on call to #setup().
     * 
     * @name Surface#_cleanupStyles
     * @function
     * @private
     * @param {Element} target document element
     */
    function _cleanupStyles(target) {
        for (var n in this.properties) {
            target.style[n] = "";
        }
    }
    var _setMatrix;
    var _setOrigin;
    var _setInvisible;
    /**
     * Directly apply given FamousMatrix to the document element as the 
     *   appropriate webkit CSS style.
     * 
     * @name SurfaceManager#setMatrix
     * @function
     * @static
     * @private
     * @param {Element} element document element
     * @param {FamousMatrix} matrix 
     */
    if (usePrefix) _setMatrix = function(element, matrix) {
        element.style.webkitTransform = Transform.formatCSS(matrix);
    }; else _setMatrix = function(element, matrix) {
        element.style.transform = Transform.formatCSS(matrix);
    };
    /**
     * Directly apply given origin coordinates to the document element as the 
     *   appropriate webkit CSS style.
     * 
     * @name SurfaceManager#setOrigin
     * @function
     * @static
     * @private
     * @param {Element} element document element
     * @param {FamousMatrix} matrix 
     */
    if (usePrefix) _setOrigin = function(element, origin) {
        element.style.webkitTransformOrigin = _formatCSSOrigin(origin);
    }; else _setOrigin = function(element, origin) {
        element.style.transformOrigin = _formatCSSOrigin(origin);
    };
    /**
     * Shrink given document element until it is effectively invisible.   
     *   This destroys any existing transform properties.  
     *   Note: Is this the ideal implementation?
     *
     * @name SurfaceManager#setInvisible
     * @function
     * @static
     * @private
     * @param {Element} element document element
     */
    if (usePrefix) _setInvisible = function(element) {
        element.style.webkitTransform = "scale3d(0.0001,0.0001,1)";
        element.style.opacity = 0;
    }; else _setInvisible = function(element) {
        element.style.transform = "scale3d(0.0001,0.0001,1)";
        element.style.opacity = 0;
    };
    function _xyNotEquals(a, b) {
        if (!(a && b)) return a !== b;
        return a[0] !== b[0] || a[1] !== b[1];
    }
    function _formatCSSOrigin(origin) {
        return (100 * origin[0]).toFixed(6) + "% " + (100 * origin[1]).toFixed(6) + "%";
    }
    /**
     * Sets up an element to be ready for commits
     *  
     * (Scope: Device developers and deeper)
     * @name Surface#setup
     * @function
     * 
     * @param {Element} target document element
     */
    Surface.prototype.setup = function(allocator) {
        var target = allocator.allocate(this.elementType);
        if (this.elementClass) {
            if (this.elementClass instanceof Array) {
                for (var i = 0; i < this.elementClass.length; i++) {
                    target.classList.add(this.elementClass[i]);
                }
            } else {
                target.classList.add(this.elementClass);
            }
        }
        _bindEvents.call(this, target);
        _setOrigin(target, [ 0, 0 ]);
        // handled internally
        this._currTarget = target;
        this._stylesDirty = true;
        this._classesDirty = true;
        this._sizeDirty = true;
        this._contentDirty = true;
        this._matrix = undefined;
        this._opacity = undefined;
        this._origin = undefined;
        this._size = undefined;
    };
    /**
     * Apply all changes stored in the Surface object to the actual element
     * This includes changes to classes, styles, size, and content, but not
     * transforms or opacities, which are managed by (@link SurfaceManager).
     * 
     * (Scope: Device developers and deeper)
     * @name Surface#commit
     * @function
     */
    Surface.prototype.commit = function(context) {
        if (!this._currTarget) this.setup(context.allocator);
        var target = this._currTarget;
        var matrix = context.transform;
        var opacity = context.opacity;
        var origin = context.origin;
        var size = context.size;
        if (this.size) {
            var origSize = size;
            size = [ this.size[0], this.size[1] ];
            if (size[0] === undefined && origSize[0]) size[0] = origSize[0];
            if (size[1] === undefined && origSize[1]) size[1] = origSize[1];
        }
        if (_xyNotEquals(this._size, size)) {
            this._size = [ size[0], size[1] ];
            this._sizeDirty = true;
        }
        if (!matrix && this._matrix) {
            this._matrix = undefined;
            this._opacity = 0;
            _setInvisible(target);
            return;
        }
        if (this._opacity !== opacity) {
            this._opacity = opacity;
            target.style.opacity = Math.min(opacity, .999999);
        }
        if (_xyNotEquals(this._origin, origin) || Transform.notEquals(this._matrix, matrix)) {
            if (!matrix) matrix = Transform.identity;
            if (!origin) origin = [ 0, 0 ];
            this._origin = [ origin[0], origin[1] ];
            this._matrix = matrix;
            var aaMatrix = matrix;
            if (origin) {
                aaMatrix = Transform.moveThen([ -this._size[0] * origin[0], -this._size[1] * origin[1] ], matrix);
            }
            _setMatrix(target, aaMatrix);
        }
        if (!(this._classesDirty || this._stylesDirty || this._sizeDirty || this._contentDirty)) return;
        if (this._classesDirty) {
            _cleanupClasses.call(this, target);
            var classList = this.getClassList();
            for (var i = 0; i < classList.length; i++) target.classList.add(classList[i]);
            this._classesDirty = false;
        }
        if (this._stylesDirty) {
            _applyStyles.call(this, target);
            this._stylesDirty = false;
        }
        if (this._sizeDirty) {
            if (this._size) {
                target.style.width = this._size[0] !== true ? this._size[0] + "px" : "";
                target.style.height = this._size[1] !== true ? this._size[1] + "px" : "";
            }
            this._sizeDirty = false;
        }
        if (this._contentDirty) {
            this.deploy(target);
            this.eventHandler.emit("deploy");
            this._contentDirty = false;
        }
    };
    /**
     *  Remove all Famous-relevant attributes from a document element.
     *    This is called by SurfaceManager's detach().
     *    This is in some sense the reverse of .deploy().
     *    Note: If you're trying to destroy a surface, don't use this. 
     *    Just remove it from the render tree.
     * 
     * (Scope: Device developers and deeper)
     * @name Surface#cleanup
     * @function
     * @param {Element} target target document element
     */
    Surface.prototype.cleanup = function(allocator) {
        var target = this._currTarget;
        this.eventHandler.emit("recall");
        this.recall(target);
        target.style.width = "";
        target.style.height = "";
        this._size = undefined;
        _cleanupStyles.call(this, target);
        var classList = this.getClassList();
        _cleanupClasses.call(this, target);
        for (var i = 0; i < classList.length; i++) target.classList.remove(classList[i]);
        if (this.elementClass) {
            if (this.elementClass instanceof Array) {
                for (var i = 0; i < this.elementClass.length; i++) {
                    target.classList.remove(this.elementClass[i]);
                }
            } else {
                target.classList.remove(this.elementClass);
            }
        }
        _unbindEvents.call(this, target);
        this._currTarget = undefined;
        allocator.deallocate(target);
        _setInvisible(target);
    };
    /**
     * Directly output this surface's fully prepared inner document content to 
     *   the provided containing parent element.
     *   This translates to innerHTML in the DOM sense.
     * 
     * (Scope: Device developers and deeper)
     * @name Surface#deploy
     * @function
     * @param {Element} target Document parent of this container
     */
    Surface.prototype.deploy = function(target) {
        var content = this.getContent();
        if (content instanceof Node) {
            while (target.hasChildNodes()) target.removeChild(target.firstChild);
            target.appendChild(content);
        } else target.innerHTML = content;
    };
    /**
     * Remove any contained document content associated with this surface 
     *   from the actual document.  
     * 
     * (Scope: Device developers and deeper)
     * @name Surface#recall
     * @function
     */
    Surface.prototype.recall = function(target) {
        var df = document.createDocumentFragment();
        while (target.hasChildNodes()) df.appendChild(target.firstChild);
        this.setContent(df);
    };
    /** 
     *  Get the x and y dimensions of the surface.  This normally returns
     *    the size of the rendered surface unless setSize() was called
     *    more recently than setup().
     * 
     * @name Surface#getSize
     * @function
     * @param {boolean} actual return actual size
     * @returns {Array.<number>} [x,y] size of surface
     */
    Surface.prototype.getSize = function(actual) {
        if (actual) return this._size; else return this.size || this._size;
    };
    /**
     * Set x and y dimensions of the surface.  This takes effect upon
     *   the next call to this.{#setup()}.
     * 
     * @name Surface#setSize
     * @function
     * @param {Array.<number>} size x,y size array
     */
    Surface.prototype.setSize = function(size) {
        this.size = size ? [ size[0], size[1] ] : undefined;
        this._sizeDirty = true;
    };
    module.exports = Surface;
}.bind(this));

require.register("famous_modules/famous/spec-parser/_git_master/index.js", function(exports, require, module) {
    var Transform = require("famous/transform");
    /**
     * @class SpecParser 
     * 
     * @description 
     *   This object translates the rendering instructions of type 
     *   {@link renderSpec} that {@link renderableComponent} objects generate 
     *   into direct document update instructions of type {@link updateSpec} 
     *   for the {@link SurfaceManager}.
     *   Scope: The {@link renderSpec} should be visible to component developers
     *   and deeper.  However, SpecParser This should not be visible below the 
     *   level of device developer.
     *
     * @name SpecParser
     * @constructor
     * 
     * @example 
     *   var parsedSpec = SpecParser.parse(spec);
     *   this.surfaceManager.update(parsedSpec);
     */
    function SpecParser() {
        this.reset();
    }
    /**
     * Convert a {@link renderSpec} coming from the context's render chain to an
     *    update spec for the update chain. This is the only major entrypoint
     *    for a consumer of this class. An optional callback of signature
     *    "function({@link updateSpec})" can be provided for call upon parse
     *    completion.
     *    
     * @name SpecParser#parse
     * @function
     * @static
     * 
     * @param {renderSpec} spec input render spec
     * @param {function(Object)} callback updateSpec-accepting function for 
     *   call on  completion
     * @returns {updateSpec} the resulting update spec (if no callback 
     *   specified, else none)
     */
    SpecParser.parse = function(spec, context, callback) {
        var sp = new SpecParser();
        var result = sp.parse(spec, context, Transform.identity);
        if (callback) callback(result); else return result;
    };
    /**
     * Convert a renderSpec coming from the context's render chain to an update
     *    spec for the update chain. This is the only major entrypoint for a
     *    consumer of this class.
     *    
     * @name SpecParser#parse
     * @function
     * 
     * @param {renderSpec} spec input render spec
     * @returns {updateSpec} the resulting update spec
     */
    SpecParser.prototype.parse = function(spec, context) {
        this.reset();
        this._parseSpec(spec, context, Transform.identity);
        return this.result;
    };
    /**
     * Prepare SpecParser for re-use (or first use) by setting internal state 
     *  to blank.
     *    
     * @name SpecParser#reset
     * @function
     */
    SpecParser.prototype.reset = function() {
        this.result = {};
    };
    /**
     * Transforms a delta vector to apply inside the context of another transform
     *
     * @name _vecInContext
     * @function
     * @private
     *
     * @param {Array.number} vector to apply
     * @param {FamousMatrix} matrix context 
     * @returns {Array.number} transformed delta vector
     */
    function _vecInContext(v, m) {
        return [ v[0] * m[0] + v[1] * m[4] + v[2] * m[8], v[0] * m[1] + v[1] * m[5] + v[2] * m[9], v[0] * m[2] + v[1] * m[6] + v[2] * m[10] ];
    }
    var _originZeroZero = [ 0, 0 ];
    /**
     * From the provided renderSpec tree, recursively compose opacities,
     *    origins, transforms, and groups corresponding to each surface id from
     *    the provided renderSpec tree structure. On completion, those
     *    properties of 'this' object should be ready to use to build an
     *    updateSpec.
     *    
     *    
     * @name SpecParser#_parseSpec
     * @function
     * @private
     * 
     * @param {renderSpec} spec input render spec for a node in the render tree.
     * @param {number|undefined} group group id to apply to this subtree
     * @param {FamousMatrix} parentTransform positional transform to apply to
     *    this subtree.
     * @param {origin=} parentOrigin origin behavior to apply to this subtree
     */
    SpecParser.prototype._parseSpec = function(spec, parentContext, sizeCtx) {
        if (spec === undefined) {} else if (typeof spec === "number") {
            var id = spec;
            var transform = parentContext.transform;
            if (parentContext.size && parentContext.origin && (parentContext.origin[0] || parentContext.origin[1])) {
                var originAdjust = [ parentContext.origin[0] * parentContext.size[0], parentContext.origin[1] * parentContext.size[1], 0 ];
                transform = Transform.move(transform, _vecInContext(originAdjust, sizeCtx));
            }
            this.result[id] = {
                transform: transform,
                opacity: parentContext.opacity,
                origin: parentContext.origin || _originZeroZero,
                size: parentContext.size
            };
        } else if (spec instanceof Array) {
            for (var i = 0; i < spec.length; i++) {
                this._parseSpec(spec[i], parentContext, sizeCtx);
            }
        } else if (spec.target !== undefined) {
            var target = spec.target;
            var transform = parentContext.transform;
            var opacity = parentContext.opacity;
            var origin = parentContext.origin;
            var size = parentContext.size;
            if (spec.opacity !== undefined) opacity = parentContext.opacity * spec.opacity;
            if (spec.transform) transform = Transform.multiply(parentContext.transform, spec.transform);
            if (spec.origin) origin = spec.origin;
            if (spec.size) {
                size = spec.size;
                var parentSize = parentContext.size;
                if (parentSize && origin && (origin[0] || origin[1])) {
                    size = [ spec.size[0] || parentSize[0], spec.size[1] || parentSize[1] ];
                    transform = Transform.move(transform, _vecInContext([ origin[0] * parentSize[0], origin[1] * parentSize[1], 0 ], sizeCtx));
                    transform = Transform.moveThen([ -origin[0] * size[0], -origin[1] * size[1], 0 ], transform);
                }
                origin = null;
            }
            this._parseSpec(target, {
                transform: transform,
                opacity: opacity,
                origin: origin,
                size: size
            }, parentContext.transform);
        }
    };
    module.exports = SpecParser;
}.bind(this));

require.register("famous_modules/famous/render-node/_git_master/index.js", function(exports, require, module) {
    var Entity = require("famous/entity");
    var SpecParser = require("famous/spec-parser");
    /**
     * @class A tree node wrapping a
     *   {@link renderableComponent} (like a {@link FamousTransform} or
     *   {@link FamousSurface}) for insertion into the render tree.
     *
     * @description Note that class may be removed in the near future.
     *
     * Scope: Ideally, RenderNode should not be visible below the level
     * of component developer.
     *
     * @name RenderNode
     * @constructor
     *
     * @example  < This should not be used by component engineers >
     *
     * @param {renderableComponent} child Target renderable component
     */
    function RenderNode(object) {
        this._object = object ? object : null;
        this._child = null;
        this._hasCached = false;
        this._resultCache = {};
        this._prevResults = {};
        this._childResult = null;
    }
    /**
     * Append a renderable to its children.
     *
     * @name RenderNode#add
     * @function
     *
     * @returns {RenderNode} this render node
     */
    RenderNode.prototype.add = function(child) {
        var childNode = child instanceof RenderNode ? child : new RenderNode(child);
        if (this._child instanceof Array) this._child.push(childNode); else if (this._child) {
            this._child = [ this._child, childNode ];
            this._childResult = [];
        } else this._child = childNode;
        return childNode;
    };
    RenderNode.prototype.get = function() {
        return this._object || this._child.get();
    };
    RenderNode.prototype.getSize = function() {
        var target = this.get();
        if (target && target.getSize) {
            return target.getSize();
        } else {
            return this._child && this._child.getSize ? this._child.getSize() : null;
        }
    };
    RenderNode.prototype.commit = function(context) {
        var renderResult = this.render(undefined, this._hasCached);
        if (renderResult !== true) {
            // free up some divs from the last loop
            for (var i in this._prevResults) {
                if (!(i in this._resultCache)) {
                    var object = Entity.get(i);
                    if (object.cleanup) object.cleanup(context.allocator);
                }
            }
            this._prevResults = this._resultCache;
            this._resultCache = {};
            _applyCommit(renderResult, context, this._resultCache);
            this._hasCached = true;
        }
    };
    function _applyCommit(spec, context, cacheStorage) {
        var result = SpecParser.parse(spec, context);
        for (var i in result) {
            var childNode = Entity.get(i);
            var commitParams = result[i];
            commitParams.allocator = context.allocator;
            var commitResult = childNode.commit(commitParams);
            if (commitResult) _applyCommit(commitResult, context, cacheStorage); else cacheStorage[i] = commitParams;
        }
    }
    /**
     * Render the component wrapped directly by this node.
     *
     * @name RenderNode#render
     * @function
     *
     * @returns {renderSpec} render specification for the component subtree
     *    only under this node.
     */
    RenderNode.prototype.render = function() {
        if (this._object && this._object.render) return this._object.render();
        var result = {};
        if (this._child instanceof Array) {
            result = this._childResult;
            var children = this._child;
            for (var i = 0; i < children.length; i++) {
                result[i] = children[i].render();
            }
        } else if (this._child) {
            result = this._child.render();
        }
        if (this._object && this._object.modify) result = this._object.modify(result);
        return result;
    };
    module.exports = RenderNode;
}.bind(this));

require.register("famous_modules/famous/view/_git_master/index.js", function(exports, require, module) {
    var EventHandler = require("famous/event-handler");
    var OptionsManager = require("famous/options-manager");
    var RenderNode = require("famous/render-node");
    /**
     * @class View
     *
     * @description 
     *  Consists of a render node paired with an input event handler and an
     *  output event handler. Useful for quickly creating elements within applications
     *  with large event systems.
     *   
     * @name View
     * @constructor
     * @example
     *   var Engine = require('famous/Engine');
     *   var FamousSurface = require('famous/Surface');
     *   var View = require('famous/View');
     *
     *   var Context = Engine.createContext();
     *
     *   var surface = new FamousSurface({
     *      size: [500,500],
     *      properties: {
     *           backgroundColor: 'red'
     *      }
     *   });
     *   
     *   var view = new View();
     *   view._link(surface);
     *
     *   Context.link(view);
     */
    function View(options) {
        this._node = new RenderNode();
        this._eventInput = new EventHandler();
        this._eventOutput = new EventHandler();
        EventHandler.setInputHandler(this, this._eventInput);
        EventHandler.setOutputHandler(this, this._eventOutput);
        this.options = Object.create(this.constructor.DEFAULT_OPTIONS || View.DEFAULT_OPTIONS);
        this._optionsManager = new OptionsManager(this.options);
        if (options) this.setOptions(options);
    }
    View.DEFAULT_OPTIONS = {};
    // no defaults
    View.prototype.getOptions = function() {
        return this._optionsManager.value();
    };
    View.prototype.setOptions = function(options) {
        this._optionsManager.patch(options);
    };
    //TODO: remove underscore
    //Mark comments: remove this function instead; non-underscored version would present abstraction violation
    View.prototype._add = function() {
        return this._node.add.apply(this._node, arguments);
    };
    View.prototype.render = function() {
        return this._node.render.apply(this._node, arguments);
    };
    View.prototype.getSize = function() {
        if (this._node && this._node.getSize) {
            return this._node.getSize.apply(this._node, arguments) || this.options.size;
        } else return this.options.size;
    };
    module.exports = View;
}.bind(this));

require.register("famous_modules/famous/views/header-footer-layout/_git_master/index.js", function(exports, require, module) {
    var Entity = require("famous/entity");
    var RenderNode = require("famous/render-node");
    var Transform = require("famous/transform");
    /**
     * @class A flexible layout that can sequentially lay out three renderables
     * @description
     *   Takes a header and footer of determinate length and a content of 
     *   flexible length. If headerSize property is omitted the size of the
     *   linked renderable will be used as the header size.
     * @name HeaderFooterLayout
     * @constructor
     * @example 
     *   var header = new Surface({
     *       size: [undefined, 100],
     *       content: 'Header / Caption'
     *   });
     *   var content = new Surface({
     *       content: 'Lorem ipsum sit dolor amet'
     *   });
     *   var footer = new Surface({
     *       size: [undefined, 100],
     *       content: 'Footer goes here'
     *   });
     *
     *   var myLayout = new HeaderFooterLayout();
     *   myLayout.id.header.link(header); // attach header
     *   myLayout.id.content.link(content); // attach content (will be auto-sized)
     *   myLayout.id.footer.link(footer); // attach footer
     *
     *   myContext.link(myLayout);
     */
    function HeaderFooterLayout(options) {
        this.options = Object.create(HeaderFooterLayout.DEFAULT_OPTIONS);
        if (options) this.setOptions(options);
        this._entityId = Entity.register(this);
        this._header = new RenderNode();
        this._footer = new RenderNode();
        this._content = new RenderNode();
        this.id = {
            header: this._header,
            footer: this._footer,
            content: this._content
        };
    }
    /** @const */
    HeaderFooterLayout.DIRECTION_X = 0;
    /** @const */
    HeaderFooterLayout.DIRECTION_Y = 1;
    HeaderFooterLayout.DEFAULT_OPTIONS = {
        direction: HeaderFooterLayout.DIRECTION_Y,
        headerSize: undefined,
        footerSize: undefined,
        defaultHeaderSize: 0,
        defaultFooterSize: 0
    };
    HeaderFooterLayout.prototype.render = function() {
        return this._entityId;
    };
    HeaderFooterLayout.prototype.setOptions = function(options) {
        for (var key in HeaderFooterLayout.DEFAULT_OPTIONS) {
            if (options[key] !== undefined) this.options[key] = options[key];
        }
    };
    function _resolveNodeSize(node, defaultSize) {
        var nodeSize = node.getSize();
        return nodeSize ? nodeSize[this.options.direction] : defaultSize;
    }
    function _outputTransform(offset) {
        if (this.options.direction == HeaderFooterLayout.DIRECTION_X) return Transform.translate(offset, 0, 0); else return Transform.translate(0, offset, 0);
    }
    function _finalSize(directionSize, size) {
        if (this.options.direction == HeaderFooterLayout.DIRECTION_X) return [ directionSize, size[1] ]; else return [ size[0], directionSize ];
    }
    HeaderFooterLayout.prototype.commit = function(context) {
        var transform = context.transform;
        var opacity = context.opacity;
        var origin = context.origin;
        var size = context.size;
        var headerSize = this.options.headerSize !== undefined ? this.options.headerSize : _resolveNodeSize.call(this, this._header, this.options.defaultHeaderSize);
        var footerSize = this.options.footerSize !== undefined ? this.options.footerSize : _resolveNodeSize.call(this, this._footer, this.options.defaultFooterSize);
        var contentSize = size[this.options.direction] - headerSize - footerSize;
        var topOrigin = [ .5, .5 ];
        var bottomOrigin = [ .5, .5 ];
        topOrigin[this.options.direction] = 0;
        bottomOrigin[this.options.direction] = 1;
        var result = [ {
            origin: topOrigin,
            size: _finalSize.call(this, headerSize, size),
            target: this._header.render()
        }, {
            transform: _outputTransform.call(this, headerSize),
            origin: topOrigin,
            size: _finalSize.call(this, contentSize, size),
            target: this._content.render()
        }, {
            origin: bottomOrigin,
            size: _finalSize.call(this, footerSize, size),
            target: this._footer.render()
        } ];
        transform = Transform.moveThen([ -size[0] * origin[0], -size[1] * origin[1], 0 ], transform);
        var nextSpec = {
            transform: transform,
            opacity: opacity,
            origin: origin,
            size: size,
            target: result
        };
        return nextSpec;
    };
    module.exports = HeaderFooterLayout;
}.bind(this));

require.register("famous_modules/famous/element-allocator/_git_master/index.js", function(exports, require, module) {
    /**
     * @class Helper object to {@link Context} that handles the process of 
     *   creating and allocating DOM elements within a managed div.  
     * @description
     * @name ElementAllocator
     * @constructor
     * 
     */
    function ElementAllocator(container) {
        if (!container) container = document.createDocumentFragment();
        this.container = container;
        this.detachedNodes = {};
        this.nodeCount = 0;
    }
    ElementAllocator.prototype.migrate = function(container) {
        var oldContainer = this.container;
        if (container === oldContainer) return;
        if (oldContainer instanceof DocumentFragment) {
            container.appendChild(oldContainer);
        } else {
            while (oldContainer.hasChildNodes()) {
                container.appendChild(oldContainer.removeChild(oldContainer.firstChild));
            }
        }
        this.container = container;
    };
    ElementAllocator.prototype.allocate = function(type) {
        type = type.toLowerCase();
        if (!(type in this.detachedNodes)) this.detachedNodes[type] = [];
        var nodeStore = this.detachedNodes[type];
        var result;
        if (nodeStore.length > 0) {
            result = nodeStore.pop();
        } else {
            result = document.createElement(type);
            this.container.appendChild(result);
        }
        this.nodeCount++;
        return result;
    };
    ElementAllocator.prototype.deallocate = function(element) {
        var nodeType = element.nodeName.toLowerCase();
        var nodeStore = this.detachedNodes[nodeType];
        nodeStore.push(element);
        this.nodeCount--;
    };
    ElementAllocator.prototype.getNodeCount = function() {
        return this.nodeCount;
    };
    module.exports = ElementAllocator;
}.bind(this));

require.register("famous_modules/famous/transitions/multiple-transition/_git_master/index.js", function(exports, require, module) {
    var Utility = require("famous/utilities/utility");
    /**
     * @class Multiple value transition method
     * @description Transition meta-method to support transitioning multiple 
     *   values with scalar-only methods
     *
     * @name MultipleTransition
     * @constructor
     *
     * @param {Object} method Transionable class to multiplex
     */
    function MultipleTransition(method) {
        this.method = method;
        this._instances = [];
        this.state = [];
    }
    MultipleTransition.SUPPORTS_MULTIPLE = true;
    MultipleTransition.prototype.get = function() {
        for (var i = 0; i < this._instances.length; i++) {
            this.state[i] = this._instances[i].get();
        }
        return this.state;
    };
    MultipleTransition.prototype.set = function(endState, transition, callback) {
        var _allCallback = Utility.after(endState.length, callback);
        for (var i = 0; i < endState.length; i++) {
            if (!this._instances[i]) this._instances[i] = new this.method();
            this._instances[i].set(endState[i], transition, _allCallback);
        }
    };
    MultipleTransition.prototype.reset = function(startState) {
        for (var i = 0; i < startState.length; i++) {
            if (!this._instances[i]) this._instances[i] = new this.method();
            this._instances[i].reset(startState[i]);
        }
    };
    module.exports = MultipleTransition;
}.bind(this));

require.register("famous_modules/famous/transitions/tween-transition/_git_master/index.js", function(exports, require, module) {
    var Utility = require("famous/utilities/utility");
    /**
     *
     * @class A state maintainer for a smooth transition between 
     *    numerically-specified states. 
     *
     * @description  Example numeric states include floats or
     *    {@link FamousMatrix} objects. TweenTransitions form the basis
     *    of {@link FamousTransform} objects.
     *
     * An initial state is set with the constructor or set(startValue). A
     *    corresponding end state and transition are set with set(endValue,
     *    transition). Subsequent calls to set(endValue, transition) begin at
     *    the last state. Calls to get(timestamp) provide the _interpolated state
     *    along the way.
     *
     * Note that there is no event loop here - calls to get() are the only way
     *    to find out state projected to the current (or provided) time and are
     *    the only way to trigger callbacks. Usually this kind of object would
     *    be part of the render() path of a visible component.
     *
     * @name TweenTransition
     * @constructor
     *   
     * @param {number|Array.<number>|Object.<number|string, number>} start 
     *    beginning state
     */
    function TweenTransition(options) {
        this.options = Object.create(TweenTransition.DEFAULT_OPTIONS);
        if (options) this.setOptions(options);
        this._startTime = 0;
        this._startValue = 0;
        this._updateTime = 0;
        this._endValue = 0;
        this._curve = undefined;
        this._duration = 0;
        this._active = false;
        this._callback = undefined;
        this.state = 0;
        this.velocity = undefined;
    }
    TweenTransition.SUPPORTS_MULTIPLE = true;
    TweenTransition.DEFAULT_OPTIONS = {
        curve: Utility.Curve.linear,
        duration: 500,
        speed: 0
    };
    var registeredCurves = {};
    /**
     * Add "unit" curve to internal dictionary of registered curves.
     * 
     * @name TweenTransition#registerCurve
     * @function
     * @static
     * 
     * @param {string} curveName dictionary key
     * @param {unitCurve} curve function of one numeric variable mapping [0,1]
     *    to range inside [0,1]
     * @returns {boolean} false if key is taken, else true
     */
    TweenTransition.registerCurve = function(curveName, curve) {
        if (!registeredCurves[curveName]) {
            registeredCurves[curveName] = curve;
            return true;
        } else {
            return false;
        }
    };
    /**
     * Remove object with key "curveName" from internal dictionary of registered
     *    curves.
     * 
     * @name TweenTransition#unregisterCurve
     * @function
     * @static
     * 
     * @param {string} curveName dictionary key
     * @returns {boolean} false if key has no dictionary value
     */
    TweenTransition.unregisterCurve = function(curveName) {
        if (registeredCurves[curveName]) {
            delete registeredCurves[curveName];
            return true;
        } else {
            return false;
        }
    };
    /**
     * Retrieve function with key "curveName" from internal dictionary of
     *    registered curves. Default curves are defined in the 
     *    {@link Utility.Curve} array, where the values represent {@link
     *    unitCurve} functions.
     *    
     * @name TweenTransition#getCurve
     * @function
     * @static
     * 
     * @param {string} curveName dictionary key
     * @returns {unitCurve} curve function of one numeric variable mapping [0,1]
     *    to range inside [0,1]
     */
    TweenTransition.getCurve = function(curveName) {
        return registeredCurves[curveName];
    };
    /**
     * Retrieve all available curves.
     *    
     * @name TweenTransition#getCurves
     * @function
     * @static
     * 
     * @returns {object} curve functions of one numeric variable mapping [0,1]
     *    to range inside [0,1]
     */
    TweenTransition.getCurves = function() {
        return registeredCurves;
    };
    /**
     * Interpolate: If a linear function f(0) = a, f(1) = b, then return f(t)
     *
     * 
     * @name _interpolate
     * @function
     * @static
     * @private 
     * @param {number} a f(0) = a
     * @param {number} b f(1) = b
     * @param {number} t independent variable 
     * @returns {number} f(t) assuming f is linear
     */
    function _interpolate(a, b, t) {
        return (1 - t) * a + t * b;
    }
    function _clone(obj) {
        if (obj instanceof Object) {
            if (obj instanceof Array) return obj.slice(0); else return Object.create(obj);
        } else return obj;
    }
    /**
     * Fill in missing properties in "transition" with those in defaultTransition, and
     *    convert internal named curve to function object, returning as new
     *    object.
     *    
     * 
     * @name _normalize
     * @function
     * @static
     * @private
     * 
     * @param {transition} transition shadowing transition
     * @param {transition} defaultTransition transition with backup properties
     * @returns {transition} newly normalized transition
     */
    function _normalize(transition, defaultTransition) {
        var result = {
            curve: defaultTransition.curve
        };
        if (defaultTransition.duration) result.duration = defaultTransition.duration;
        if (defaultTransition.speed) result.speed = defaultTransition.speed;
        if (transition instanceof Object) {
            if (transition.duration !== undefined) result.duration = transition.duration;
            if (transition.curve) result.curve = transition.curve;
            if (transition.speed) result.speed = transition.speed;
        }
        if (typeof result.curve === "string") result.curve = TweenTransition.getCurve(result.curve);
        return result;
    }
    /**
     * Copy object to internal "default" transition. Missing properties in
     *    provided transitions inherit from this default.
     * 
     * @name TweenTransition#setOptions
     * @function
     *    
     * @param {transition} transition {duration: number, curve: f[0,1] -> [0,1]}
     */
    TweenTransition.prototype.setOptions = function(options) {
        if (options.curve !== undefined) this.options.curve = options.curve;
        if (options.duration !== undefined) this.options.duration = options.duration;
        if (options.speed !== undefined) this.options.speed = options.speed;
    };
    /**
     * Add transition to end state to the queue of pending transitions. Special
     *    Use: calling without a transition resets the object to that state with
     *    no pending actions
     * 
     * @name TweenTransition#set
     * @function
     *    
     * @param {number|FamousMatrix|Array.<number>|Object.<number, number>} endValue
     *    end state to which we _interpolate
     * @param {transition=} transition object of type {duration: number, curve:
     *    f[0,1] -> [0,1] or name}. If transition is omitted, change will be 
     *    instantaneous.
     * @param {function()=} callback Zero-argument function to call on observed
     *    completion (t=1)
     */
    TweenTransition.prototype.set = function(endValue, transition, callback) {
        if (!transition) {
            this.reset(endValue);
            if (callback) callback();
            return;
        }
        this._startValue = _clone(this.get());
        transition = _normalize(transition, this.options);
        if (transition.speed) {
            var startValue = this._startValue;
            if (startValue instanceof Object) {
                var variance = 0;
                for (var i in startValue) variance += (endValue[i] - startValue[i]) * (endValue[i] - startValue[i]);
                transition.duration = Math.sqrt(variance) / transition.speed;
            } else {
                transition.duration = Math.abs(endValue - startValue) / transition.speed;
            }
        }
        this._startTime = Date.now();
        this._endValue = _clone(endValue);
        this._startVelocity = _clone(transition.velocity);
        this._duration = transition.duration;
        this._curve = transition.curve;
        this._active = true;
        this._callback = callback;
    };
    /**
     * Cancel all transitions and reset to a stable state
     *
     * @name TweenTransition#reset
     * @function
     *
     * @param {number|Array.<number>|Object.<number, number>} startValue
     *    stable state to set to
     */
    TweenTransition.prototype.reset = function(startValue, startVelocity) {
        if (this._callback) {
            var callback = this._callback;
            this._callback = undefined;
            callback();
        }
        this.state = _clone(startValue);
        this.velocity = _clone(startVelocity);
        this._startTime = 0;
        this._duration = 0;
        this._updateTime = 0;
        this._startValue = this.state;
        this._startVelocity = this.velocity;
        this._endValue = this.state;
        this._active = false;
    };
    TweenTransition.prototype.getVelocity = function() {
        return this.velocity;
    };
    /**
     * Get _interpolated state of current action at provided time. If the last
     *    action has completed, invoke its callback.
     * 
     * @name TweenTransition#get
     * @function
     *    
     * @param {number=} timestamp Evaluate the curve at a normalized version of this
     *    time. If omitted, use current time. (Unix epoch time)
     * @returns {number|Object.<number|string, number>} beginning state
     *    _interpolated to this point in time.
     */
    TweenTransition.prototype.get = function(timestamp) {
        this.update(timestamp);
        return this.state;
    };
    /**
     * Update internal state to the provided timestamp. This may invoke the last
     *    callback and begin a new action.
     * 
     * @name TweenTransition#update
     * @function
     * 
     * @param {number=} timestamp Evaluate the curve at a normalized version of this
     *    time. If omitted, use current time. (Unix epoch time)
     */
    function _calculateVelocity(current, start, curve, duration, t) {
        var velocity;
        var eps = 1e-7;
        var speed = (curve(t) - curve(t - eps)) / eps;
        if (current instanceof Array) {
            velocity = [];
            for (var i = 0; i < current.length; i++) velocity[i] = speed * (current[i] - start[i]) / duration;
        } else velocity = speed * (current - start) / duration;
        return velocity;
    }
    function _calculateState(start, end, t) {
        var state;
        if (start instanceof Array) {
            state = [];
            for (var i = 0; i < start.length; i++) state[i] = _interpolate(start[i], end[i], t);
        } else state = _interpolate(start, end, t);
        return state;
    }
    TweenTransition.prototype.update = function(timestamp) {
        if (!this._active) {
            if (this._callback) {
                var callback = this._callback;
                this._callback = undefined;
                callback();
            }
            return;
        }
        if (!timestamp) timestamp = Date.now();
        if (this._updateTime >= timestamp) return;
        this._updateTime = timestamp;
        var timeSinceStart = timestamp - this._startTime;
        if (timeSinceStart >= this._duration) {
            this.state = this._endValue;
            this.velocity = _calculateVelocity(this.state, this._startValue, this._curve, this._duration, 1);
            this._active = false;
        } else if (timeSinceStart < 0) {
            this.state = this._startValue;
            this.velocity = this._startVelocity;
        } else {
            var t = timeSinceStart / this._duration;
            this.state = _calculateState(this._startValue, this._endValue, this._curve(t));
            this.velocity = _calculateVelocity(this.state, this._startValue, this._curve, this._duration, t);
        }
    };
    /**
     * Is there at least one action pending completion?
     * 
     * @name TweenTransition#isActive
     * @function
     * 
     * @returns {boolean} 
     */
    TweenTransition.prototype.isActive = function() {
        return this._active;
    };
    /**
     * Halt transition at current state and erase all pending actions.
     * 
     * @name TweenTransition#halt
     * @function
     */
    TweenTransition.prototype.halt = function() {
        this.reset(this.get());
    };
    /* Register all the default curves */
    TweenTransition.registerCurve("linear", Utility.Curve.linear);
    TweenTransition.registerCurve("easeIn", Utility.Curve.easeIn);
    TweenTransition.registerCurve("easeOut", Utility.Curve.easeOut);
    TweenTransition.registerCurve("easeInOut", Utility.Curve.easeInOut);
    TweenTransition.registerCurve("easeOutBounce", Utility.Curve.easeOutBounce);
    TweenTransition.registerCurve("spring", Utility.Curve.spring);
    TweenTransition.customCurve = function(v1, v2) {
        v1 = v1 || 0;
        v2 = v2 || 0;
        return function(t) {
            return v1 * t + (-2 * v1 - v2 + 3) * t * t + (v1 + v2 - 2) * t * t * t;
        };
    };
    module.exports = TweenTransition;
}.bind(this));

require.register("famous_modules/famous/transitions/transitionable/_git_master/index.js", function(exports, require, module) {
    var Utility = require("famous/utilities/utility");
    var MultipleTransition = require("famous/transitions/multiple-transition");
    var TweenTransition = require("famous/transitions/tween-transition");
    /**
     *
     * @class Transitionable 
     *
     * @description  An engineInstance maintainer for a smooth transition between 
     *    numerically-specified engineInstances. Example numeric engineInstances include floats or
     *    {@link FamousMatrix} objects. Transitionables form the basis
     *    of {@link FamousTransform} objects.
     *
     * An initial engineInstance is set with the constructor or set(startState). A
     *    corresponding end engineInstance and transition are set with set(endState,
     *    transition). Subsequent calls to set(endState, transition) begin at
     *    the last engineInstance. Calls to get(timestamp) provide the interpolated engineInstance
     *    along the way.
     *
     * Note that there is no event loop here - calls to get() are the only way
     *    to find engineInstance projected to the current (or provided) time and are
     *    the only way to trigger callbacks. Usually this kind of object would
     *    be part of the render() path of a visible component.
     * 
     * @name Transitionable
     * @constructor
     * @example 
     *   function FamousFader(engineInstance, transition) { 
     *     if(typeof engineInstance == 'undefined') engineInstance = 0; 
     *     if(typeof transition == 'undefined') transition = true; 
     *     this.transitionHelper = new Transitionable(engineInstance);
     *     this.transition = transition; 
     *   }; 
     *   
     *   FamousFader.prototype = { 
     *     show: function(callback) { 
     *       this.set(1, this.transition, callback); 
     *     }, 
     *     hide: function(callback) { 
     *       this.set(0, this.transition, callback); 
     *     }, 
     *     set: function(engineInstance, transition, callback) { 
     *       this.transitionHelper.halt();
     *       this.transitionHelper.set(engineInstance, transition, callback); 
     *     }, 
     *     render: function(target) { 
     *       var currOpacity = this.transitionHelper.get();
     *       return {opacity: currOpacity, target: target}; 
     *     } 
     *   };
     *   
     * @param {number|Array.<number>|Object.<number|string, number>} start 
     *    beginning engineInstance
     */
    function Transitionable(start) {
        this.currentAction = null;
        this.actionQueue = [];
        this.callbackQueue = [];
        this.state = 0;
        this.velocity = undefined;
        this._callback = undefined;
        this._engineInstance = null;
        this._currentMethod = null;
        this.set(start);
    }
    var transitionMethods = {};
    Transitionable.registerMethod = function(name, engineClass) {
        if (!(name in transitionMethods)) {
            transitionMethods[name] = engineClass;
            return true;
        } else return false;
    };
    Transitionable.unregisterMethod = function(name) {
        if (name in transitionMethods) {
            delete transitionMethods[name];
            return true;
        } else return false;
    };
    function _loadNext() {
        if (this._callback) {
            var callback = this._callback;
            this._callback = undefined;
            callback();
        }
        if (this.actionQueue.length <= 0) {
            this.set(this.get());
            // no update required
            return;
        }
        this.currentAction = this.actionQueue.shift();
        this._callback = this.callbackQueue.shift();
        var method = null;
        var endValue = this.currentAction[0];
        var transition = this.currentAction[1];
        if (transition instanceof Object && transition.method) {
            method = transition.method;
            if (typeof method === "string") method = transitionMethods[method];
        } else {
            method = TweenTransition;
        }
        if (this._currentMethod !== method) {
            if (!(endValue instanceof Object) || method.SUPPORTS_MULTIPLE === true || endValue.length <= method.SUPPORTS_MULTIPLE) {
                this._engineInstance = new method();
            } else {
                this._engineInstance = new MultipleTransition(method);
            }
            this._currentMethod = method;
        }
        this._engineInstance.reset(this.state, this.velocity);
        if (this.velocity !== undefined) transition.velocity = this.velocity;
        this._engineInstance.set(endValue, transition, _loadNext.bind(this));
    }
    /**
     * Add transition to end engineInstance to the queue of pending transitions. Special
     *    Use: calling without a transition resets the object to that engineInstance with
     *    no pending actions
     * 
     * @name Transitionable#set
     * @function
     *    
     * @param {number|FamousMatrix|Array.<number>|Object.<number, number>} endState
     *    end engineInstance to which we interpolate
     * @param {transition=} transition object of type {duration: number, curve:
     *    f[0,1] -> [0,1] or name}. If transition is omitted, change will be 
     *    instantaneous.
     * @param {function()=} callback Zero-argument function to call on observed
     *    completion (t=1)
     */
    Transitionable.prototype.set = function(endState, transition, callback) {
        if (!transition) {
            this.reset(endState);
            if (callback) callback();
            return this;
        }
        var action = [ endState, transition ];
        this.actionQueue.push(action);
        this.callbackQueue.push(callback);
        if (!this.currentAction) _loadNext.call(this);
        return this;
    };
    /**
     * Cancel all transitions and reset to a stable engineInstance
     *
     * @name Transitionable#reset
     * @function
     *
     * @param {number|Array.<number>|Object.<number, number>} startState
     *    stable engineInstance to set to
     */
    Transitionable.prototype.reset = function(startState, startVelocity) {
        this._currentMethod = null;
        this._engineInstance = null;
        this.state = startState;
        this.velocity = startVelocity;
        this.currentAction = null;
        this.actionQueue = [];
        this.callbackQueue = [];
    };
    /**
     * Add delay action to the pending action queue queue.
     * 
     * @name Transitionable#delay
     * @function
     * 
     * @param {number} duration delay time (ms)
     * @param {function()} callback Zero-argument function to call on observed
     *    completion (t=1)
     */
    Transitionable.prototype.delay = function(duration, callback) {
        this.set(this._engineInstance.get(), {
            duration: duration,
            curve: function() {
                return 0;
            }
        }, callback);
    };
    /**
     * Get interpolated engineInstance of current action at provided time. If the last
     *    action has completed, invoke its callback. TODO: What if people want
     *    timestamp == 0?
     * 
     * @name Transitionable#get
     * @function
     *    
     * @param {number=} timestamp Evaluate the curve at a normalized version of this
     *    time. If omitted, use current time. (Unix epoch time)
     * @returns {number|Object.<number|string, number>} beginning engineInstance
     *    interpolated to this point in time.
     */
    Transitionable.prototype.get = function(timestamp) {
        if (this._engineInstance) {
            if (this._engineInstance.getVelocity) this.velocity = this._engineInstance.getVelocity();
            this.state = this._engineInstance.get(timestamp);
        }
        return this.state;
    };
    /**
     * Is there at least one action pending completion?
     * 
     * @name Transitionable#isActive
     * @function
     * 
     * @returns {boolean} 
     */
    Transitionable.prototype.isActive = function() {
        return !!this.currentAction;
    };
    /**
     * Halt transition at current engineInstance and erase all pending actions.
     * 
     * @name Transitionable#halt
     * @function
     */
    Transitionable.prototype.halt = function() {
        this.set(this.get());
    };
    module.exports = Transitionable;
}.bind(this));

require.register("famous_modules/famous/context/_git_master/index.js", function(exports, require, module) {
    var RenderNode = require("famous/render-node");
    var EventHandler = require("famous/event-handler");
    var SpecParser = require("famous/spec-parser");
    var ElementAllocator = require("famous/element-allocator");
    var Transform = require("famous/transform");
    var Transitionable = require("famous/transitions/transitionable");
    /**
     * @class Context 
     * @description The top-level container for a Famous-renderable piece of the 
     *    document.  It is directly updated
     *   by the process-wide FamousEngine object, and manages one 
     *   render treeevent tree pair, which can contain other
     *   renderables and events.
     *
     * This constructor should only be called by the engine.
     * @name Context
     * @constructor
     * 
     * @example
     *   var mainDiv = document.querySelector('#main'); 
     *   var mainContext = FamousEngine.createContext(mainDiv);
     *   var surface = new FamousSurface([300,50], 'Hello World');
     *   mainContext.link(surface);
     *
     * 
     */
    function Context(container) {
        this.container = container;
        this.allocator = new ElementAllocator(container);
        this.srcNode = new RenderNode();
        this.eventHandler = new EventHandler();
        this._size = _getElementSize(this.container);
        this.perspectiveState = new Transitionable(0);
        this._perspective = undefined;
        this.eventHandler.on("resize", function() {
            this._size = _getElementSize(this.container);
        }.bind(this));
    }
    function _getElementSize(element) {
        return [ element.clientWidth, element.clientHeight ];
    }
    Context.prototype.getAllocator = function() {
        return this.allocator;
    };
    /**
     * Add renderables to this Context
     *
     * @name Context#add
     * @function
     * @param {renderableComponent} obj 
     * @returns {RenderNode} new node wrapping this object
     */
    Context.prototype.add = function(obj) {
        return this.srcNode.add(obj);
    };
    /**
     * Move this context to another container
     *
     * @name Context#migrate
     * @function
     * @param {Node} container Container node to migrate to
     */
    Context.prototype.migrate = function(container) {
        if (container === this.container) return;
        this.container = container;
        this.allocator.migrate(container);
    };
    /**
     * Gets viewport size for Context
     *
     * @name Context#getSize
     * @function
     *
     * @returns {Array} viewport size
     */
    Context.prototype.getSize = function() {
        return this._size;
    };
    /**
     * Sets viewport size for Context
     *
     * @name Context#setSize
     * @function
     */
    Context.prototype.setSize = function(size) {
        if (!size) size = _getElementSize(this.container);
        this._size = size;
    };
    /**
     * Run the render loop and then the run the update loop for the content 
     *   managed by this context. 
     *
     * @name Context#update
     * @function
     */
    Context.prototype.update = function() {
        var perspective = this.perspectiveState.get();
        if (perspective !== this._perspective) {
            this.container.style.perspective = perspective ? perspective.toFixed() + "px" : "";
            this.container.style.webkitPerspective = perspective ? perspective.toFixed() : "";
            this._perspective = perspective;
        }
        if (this.srcNode) {
            this.srcNode.commit({
                allocator: this.getAllocator(),
                transform: Transform.identity,
                opacity: 1,
                origin: [ 0, 0 ],
                size: this._size
            });
        }
    };
    Context.prototype.getPerspective = function() {
        return this.perspectiveState.get();
    };
    Context.prototype.setPerspective = function(perspective, transition, callback) {
        return this.perspectiveState.set(perspective, transition, callback);
    };
    /**
     * Trigger an event, sending to all downstream handlers
     *   matching provided 'type' key.
     *
     * @name Context#emit
     * @function
     *
     * @param {string} type event type key (for example, 'click')
     * @param {Object} event event data
     */
    Context.prototype.emit = function(type, event) {
        return this.eventHandler.emit(type, event);
    };
    /**
     * Bind a handler function to an event type occuring in the context.
     *   These events will either come link calling {@link Context#emit} or
     *   directly link the document.  
     *   Document events have the opportunity to first be intercepted by the 
     *   on() method of the FamousSurface upon which the event occurs, then 
     *   by the on() method of the Context containing that surface, and
     *   finally as a default, the FamousEngine itself. 
     *
     * @name Context#on
     * @function
     * @param  {string} type event type key (for example, 'click')
     * @param {function(string, Object)} handler callback
     */
    Context.prototype.on = function(type, handler) {
        return this.eventHandler.on(type, handler);
    };
    /**
     * Unbind an event by type and handler.  
     *   This undoes the work of {@link Context#on}
     *
     * @name Context#unbind
     * @function
     * @param {string} type event type key (for example, 'click')
     * @param {function(string, Object)} handler 
     */
    Context.prototype.unbind = function(type, handler) {
        return this.eventHandler.unbind(type, handler);
    };
    /**
     * Emit Context events to downstream event handler
     *
     * @name Context#pipe
     * @function
     * @param {EventHandler} target downstream event handler
     */
    Context.prototype.pipe = function(target) {
        return this.eventHandler.pipe(target);
    };
    /**
     * Stop emitting events to a downstream event handler
     *
     * @name Context#unpipe
     * @function
     * @param {EventHandler} target downstream event handler
     */
    Context.prototype.unpipe = function(target) {
        return this.eventHandler.unpipe(target);
    };
    module.exports = Context;
}.bind(this));

require.register("famous_modules/famous/engine/_git_master/index.js", function(exports, require, module) {
    /**
     * @namespace Engine
     * 
     * @description The singleton object initiated upon process
     *    startup which manages all active {@link Context} instances, runs
     *    the render dispatch loop, and acts as a global listener and dispatcher
     *    for all events. Public functions include
     *    adding contexts and functions for execution at each render tick.
     * 
     *   On static initialization, window.requestAnimationFrame is called with
     *   the event loop function, step().
     * 
     *   Note: Any window in which Engine runs will prevent default 
     *     scrolling behavior on the 'touchmove' event.
     * @static
     * 
     * @name Engine
     * 
     * @example
     *   var mainDiv = document.querySelector('#main'); 
     *   var mainContext = Engine.createContext(mainDiv);
     *   var surface = new FamousSurface([300,50], 'Hello World');
     *   mainContext.from(helloWorldSurface);
     */
    var Context = require("famous/context");
    var EventHandler = require("famous/event-handler");
    var OptionsManager = require("famous/options-manager");
    var Engine = {};
    var contexts = [];
    var nextTickQueue = [];
    var deferQueue = [];
    var lastTime = Date.now();
    var frameTime = undefined;
    var frameTimeLimit = undefined;
    var loopEnabled = true;
    var eventForwarders = {};
    var eventHandler = new EventHandler();
    var options = {
        containerType: "div",
        containerClass: "famous-container",
        fpsCap: undefined,
        runLoop: true
    };
    var optionsManager = new OptionsManager(options);
    optionsManager.on("change", function(data) {
        if (data.id === "fpsCap") setFPSCap(data.value); else if (data.id === "runLoop") {
            // kick off the loop only if it was stopped
            if (!loopEnabled && data.value) {
                loopEnabled = true;
                requestAnimationFrame(loop);
            }
        }
    });
    /** @const */
    var MAX_DEFER_FRAME_TIME = 10;
    /**
     * Inside requestAnimationFrame loop, this function is called which:
     *   - calculates current FPS (throttling loop if it is over limit set in setFPSCap)
     *   - emits dataless 'prerender' event on start of loop
     *   - calls in order any one-shot functions registered by nextTick on last loop.
     *   - calls Context.update on all {@link Context} objects registered.
     *   - emits dataless 'postrender' event on end of loop
     * @name Engine#step
     * @function
     * @private
     */
    Engine.step = function() {
        var currentTime = Date.now();
        // skip frame if we're over our framerate cap
        if (frameTimeLimit && currentTime - lastTime < frameTimeLimit) return;
        frameTime = currentTime - lastTime;
        lastTime = currentTime;
        eventHandler.emit("prerender");
        // empty the queue
        for (var i = 0; i < nextTickQueue.length; i++) nextTickQueue[i].call(this);
        nextTickQueue.splice(0);
        // limit total execution time for deferrable functions
        while (deferQueue.length && Date.now() - currentTime < MAX_DEFER_FRAME_TIME) {
            deferQueue.shift().call(this);
        }
        for (var i = 0; i < contexts.length; i++) contexts[i].update();
        eventHandler.emit("postrender");
    };
    function loop() {
        if (options.runLoop) {
            Engine.step();
            requestAnimationFrame(loop);
        } else loopEnabled = false;
    }
    requestAnimationFrame(loop);
    /**
     * Upon main document window resize (unless on an "input" HTML element)
     *   - scroll to the top left corner of the window
     *   - For each managed {@link Context}: emit the 'resize' event and update its size 
     * @name Engine#step
     * @function
     * @static
     * @private
     * 
     * @param {Object=} event
     */
    function handleResize(event) {
        if (window._disableResize) return;
        if (document.activeElement && document.activeElement.nodeName == "INPUT") {
            document.activeElement.addEventListener("blur", function deferredResize() {
                this.removeEventListener("blur", deferredResize);
                handleResize(event);
            });
            return;
        }
        window.scrollTo(0, 0);
        for (var i = 0; i < contexts.length; i++) {
            contexts[i].emit("resize");
        }
        eventHandler.emit("resize");
    }
    window.addEventListener("resize", handleResize, false);
    handleResize();
    // prevent scrolling via browser
    window.addEventListener("touchmove", function(event) {
        event.preventDefault();
    }, false);
    /**
     * Pipes all events to a target object that implements the #emit() interface.
     * TODO: Confirm that "uncaught" events that bubble up to the document.
     * @name Engine#pipe
     * @function
     * @param {emitterObject} target target emitter object
     * @returns {emitterObject} target emitter object (for chaining)
     */
    Engine.pipe = function(target) {
        if (target.subscribe instanceof Function) return target.subscribe(Engine); else return eventHandler.pipe(target);
    };
    /**
     * Stop piping all events at the Engine level to a target emitter 
     *   object.  Undoes the work of {@link Engine#pipe}.
     * 
     * @name Engine#unpipe
     * @function
     * @param {emitterObject} target target emitter object
     */
    Engine.unpipe = function(target) {
        if (target.unsubscribe instanceof Function) return target.unsubscribe(Engine); else return eventHandler.unpipe(target);
    };
    /**
     * Bind a handler function to a document or Engine event.
     *   These events will either come from calling {@link Engine#emit} or
     *   directly from the document.  The document events to which Engine 
     *   listens by default include: 'touchstart', 'touchmove', 'touchend', 
     *   'touchcancel', 
     *   'click', 'keydown', 'keyup', 'keypress', 'mousemove', 
     *   'mouseover', 'mouseout'.  
     *   Document events have the opportunity to first be intercepted by the 
     *   on() method of the FamousSurface upon which the event occurs, then 
     *   by the on() method of the Context containing that surface, and
     *   finally as a default, the Engine itself.
     * @static
     * @name Engine#on
     * @function
     * @param  {string} type event type key (for example, 'click')
     * @param {function(string, Object)} handler callback
     */
    Engine.on = function(type, handler) {
        if (!(type in eventForwarders)) {
            eventForwarders[type] = eventHandler.emit.bind(eventHandler, type);
            document.body.addEventListener(type, eventForwarders[type]);
        }
        return eventHandler.on(type, handler);
    };
    /**
     * Trigger an event, sending to all downstream handlers
     *   matching provided 'type' key.
     *
     * @static
     * @name Engine#emit
     * @function
     * @param {string} type event type key (for example, 'click')
     * @param {Object} event event data
     */
    Engine.emit = function(type, event) {
        return eventHandler.emit(type, event);
    };
    /**
     * Unbind an event by type and handler.  
     *   This undoes the work of {@link Engine#on}
     * 
     * @static
     * @name Engine#unbind
     * @function
     * @param {string} type 
     * @param {function(string, Object)} handler 
     */
    Engine.unbind = function(type, handler) {
        return eventHandler.unbind(type, handler);
    };
    /**
     * Return the current calculated frames per second of the Engine.
     * 
     * @static
     * @name Engine#getFPS
     * @function
     * @returns {number} calculated fps
     */
    Engine.getFPS = function() {
        return 1e3 / frameTime;
    };
    /**
     * Set the maximum fps at which the system should run. If internal render
     *    loop is called at a greater frequency than this FPSCap, Engine will
     *    throttle render and update until this rate is achieved.
     * 
     * @static
     * @name Engine#setFPS
     * @function
     * @param {number} fps desired fps
     */
    Engine.setFPSCap = function(fps) {
        frameTimeLimit = Math.floor(1e3 / fps);
    };
    /**
     * Return engine options
     * 
     * @static
     * @name Engine#getOptions
     * @function
     * @returns {Object} options
     */
    Engine.getOptions = function() {
        return optionsManager.getOptions.apply(optionsManager, arguments);
    };
    /**
     * Set engine options
     * 
     * @static
     * @name Engine#setOptions
     * @function
     */
    Engine.setOptions = function(options) {
        return optionsManager.setOptions.apply(optionsManager, arguments);
    };
    /**
     * Creates a new context for Famous rendering and event handling with
     *    provided HTML element as top of each tree. This will be tracked by the
     *    process-wide {@link Engine}.
     *
     * Note: syntactic sugar
     *
     * @static
     * @name Engine#createContext
     * @function
     * @param {Element} el Top of document tree
     * @returns {Context}
     */
    Engine.createContext = function(el) {
        if (el === undefined) {
            el = document.createElement(options.containerType);
            el.classList.add(options.containerClass);
            document.body.appendChild(el);
        } else if (!(el instanceof Element)) {
            el = document.createElement(options.containerType);
            console.warn("Tried to create context on non-existent element");
        }
        var context = new Context(el);
        Engine.registerContext(context);
        return context;
    };
    /**
     * Registers a context
     *
     * @static
     * @name FamousEngine#registerContext
     * @function
     * @param {Context} context Context to register
     * @returns {FamousContext}
     */
    Engine.registerContext = function(context) {
        contexts.push(context);
        return context;
    };
    /**
     * Queue a function to be executed on the next tick of the {@link
     *    Engine}.  The function's only argument will be the 
     *    JS window object.
     *    
     * @static
     * @name Engine#nextTick
     * @function
     * @param {Function} fn
     */
    Engine.nextTick = function(fn) {
        nextTickQueue.push(fn);
    };
    /**
     * Queue a function to be executed sometime soon, at a time that is
     *    unlikely to affect framerate.
     *
     * @static
     * @name Engine#defer
     * @function
     * @param {Function} fn
     */
    Engine.defer = function(fn) {
        deferQueue.push(fn);
    };
    module.exports = Engine;
}.bind(this));

require.register("famous_modules/famous/modifier/_git_master/index.js", function(exports, require, module) {
    var Transform = require("famous/transform");
    var Transitionable = require("famous/transitions/transitionable");
    var Utility = require("famous/utilities/utility");
    /**
     *
     * @class Modifier
     *
     * @description A collection of visual changes to be
     *    applied to another renderable component. This collection includes a
     *    transform matrix, an opacity constant, and an origin specifier. These
     *    are all managed separately inside this object, and each operates
     *    independently. Modifier objects can be linked within any context or view
     *    capable of displaying renderables. Objects' subsequent siblings and children
     *    are transformed by the amounts specified in the modifier's properties.
     *
     * Renaming suggestion: Change parameters named "transform" to 
     * "transformMatrix" in here.
     *    
     * @name Modifier
     * @constructor
     * @example
     *   var Engine         = require('famous/Engine');
     *   var FamousSurface  = require('famous/Surface');
     *   var Modifier       = require('famous/Modifier');
     *   var FM             = require('famous/Matrix');
     *
     *   var Context = Engine.createContext();
     *
     *   var surface = new FamousSurface({
     *       size: [200,200],
     *       properties: {
     *           backgroundColor: '#3cf'
     *       },
     *       content: 'test'
     *   });
     *   
     *   var modifier = new Modifier({
     *       origin: [0,0],
     *       transform: FM.translate(400,0,0)
     *   })
     *
     *   Context.link(modifier).link(surface);
     */
    function Modifier(opts) {
        var transform = Transform.identity;
        var opacity = 1;
        var origin = undefined;
        var size = undefined;
        /* maintain backwards compatibility for scene compiler */
        if (arguments.length > 1 || arguments[0] instanceof Array) {
            if (arguments[0] !== undefined) transform = arguments[0];
            if (arguments[1] !== undefined) opacity = arguments[1];
            origin = arguments[2];
            size = arguments[3];
        } else if (opts) {
            if (opts.transform) transform = opts.transform;
            if (opts.opacity !== undefined) opacity = opts.opacity;
            if (opts.origin) origin = opts.origin;
            if (opts.size) size = opts.size;
        }
        this.transformTranslateState = new Transitionable([ 0, 0, 0 ]);
        this.transformRotateState = new Transitionable([ 0, 0, 0 ]);
        this.transformSkewState = new Transitionable([ 0, 0, 0 ]);
        this.transformScaleState = new Transitionable([ 1, 1, 1 ]);
        this.opacityState = new Transitionable(opacity);
        this.originState = new Transitionable([ 0, 0 ]);
        this.sizeState = new Transitionable([ 0, 0 ]);
        this._originEnabled = false;
        this._sizeEnabled = false;
        this.setTransform(transform);
        this.setOpacity(opacity);
        this.setOrigin(origin);
        this.setSize(size);
    }
    /**
     * Get current interpolated positional transform matrix at this point in
     *    time.
     * (Scope: Component developers and deeper)
     *
     * @name Modifier#getTransform
     * @function
     *  
     * @returns {FamousMatrix} webkit-compatible positional transform matrix.
     */
    Modifier.prototype.getTransform = function() {
        if (this.isActive()) {
            return Transform.build({
                translate: this.transformTranslateState.get(),
                rotate: this.transformRotateState.get(),
                skew: this.transformSkewState.get(),
                scale: this.transformScaleState.get()
            });
        } else return this.getFinalTransform();
    };
    /**
     * Get most recently provided end state positional transform matrix.
     * (Scope: Component developers and deeper)
     * 
     * @name Modifier#getFinalTransform
     * @function
     * 
     * @returns {FamousMatrix} webkit-compatible positional transform matrix.
     */
    Modifier.prototype.getFinalTransform = function() {
        return this._finalTransform;
    };
    /**
     * Add positional transformation to the internal queue. Special Use: calling
     *    without a transition resets the object to that state with no pending
     *    actions Note: If we called setTransform in that "start state" way,
     *    then called with a transition, we begin form that start state.
     * 
     * @name Modifier#setTransform
     * @function
     *    
     * @param {FamousMatrix} transform end state positional transformation to
     *    which we interpolate
     * @param {transition=} transition object of type {duration: number, curve:
     *    f[0,1] -> [0,1] or name}
     * @param {function()=} callback Zero-argument function to call on observed
     *    completion (t=1)
     */
    Modifier.prototype.setTransform = function(transform, transition, callback) {
        var _callback = callback ? Utility.after(4, callback) : undefined;
        if (transition) {
            if (this._transformDirty) {
                var startState = Transform.interpret(this.getFinalTransform());
                this.transformTranslateState.set(startState.translate);
                this.transformRotateState.set(startState.rotate);
                this.transformSkewState.set(startState.skew);
                this.transformScaleState.set(startState.scale);
                this._transformDirty = false;
            }
            var endState = Transform.interpret(transform);
            this.transformTranslateState.set(endState.translate, transition, _callback);
            this.transformRotateState.set(endState.rotate, transition, _callback);
            this.transformSkewState.set(endState.skew, transition, _callback);
            this.transformScaleState.set(endState.scale, transition, _callback);
        } else {
            this.transformTranslateState.halt();
            this.transformRotateState.halt();
            this.transformSkewState.halt();
            this.transformScaleState.halt();
            this._transformDirty = true;
        }
        this._finalTransform = transform;
    };
    /**
     * Get current interpolated opacity constant at this point in time.
     * 
     * @name Modifier#getOpacity
     * @function
     * 
     * @returns {number} interpolated opacity number. float w/ range [0..1]
     */
    Modifier.prototype.getOpacity = function() {
        return this.opacityState.get();
    };
    /**
     * Add opacity transformation to the internal queue. Special Use: calling
     *    without a transition resets the object to that state with no pending
     *    actions.
     * 
     * @name Modifier#setOpacity
     * @function
     *    
     * @param {number} opacity end state opacity constant to which we interpolate
     * @param {transition=} transition object of type 
     *    {duration: number, curve: f[0,1] -> [0,1] or name}. If undefined, 
     *    opacity change is instantaneous.
     * @param {function()=} callback Zero-argument function to call on observed
     *    completion (t=1)
     */
    Modifier.prototype.setOpacity = function(opacity, transition, callback) {
        this.opacityState.set(opacity, transition, callback);
    };
    /**
     * Get current interpolated origin pair at this point in time.
     *
     * @returns {Array.<number>} interpolated origin pair
     */
    Modifier.prototype.getOrigin = function() {
        return this._originEnabled ? this.originState.get() : undefined;
    };
    /**
     * Add origin transformation to the internal queue. Special Use: calling
     *    without a transition resets the object to that state with no pending
     *    actions
     * 
     * @name Modifier#setOrigin
     * @function
     *    
     * @param {Array.<number>} origin end state origin pair to which we interpolate
     * @param {transition=} transition object of type 
     *    {duration: number, curve: f[0,1] -> [0,1] or name}. if undefined, 
     *    opacity change is instantaneous.
     * @param {function()=} callback Zero-argument function to call on observed
     *    completion (t=1)
     */
    Modifier.prototype.setOrigin = function(origin, transition, callback) {
        this._originEnabled = !!origin;
        if (!origin) origin = [ 0, 0 ];
        if (!(origin instanceof Array)) origin = Utility.origins[origin];
        this.originState.set(origin, transition, callback);
    };
    /**
     * Get current interpolated size at this point in time.
     *
     * @returns {Array.<number>} interpolated size
     */
    Modifier.prototype.getSize = function() {
        return this._sizeEnabled ? this.sizeState.get() : undefined;
    };
    /**
     * Add size transformation to the internal queue. Special Use: calling
     *    without a transition resets the object to that state with no pending
     *    actions
     * 
     * @name Modifier#setSize
     * @function
     *    
     * @param {Array.<number>} size end state size to which we interpolate
     * @param {transition=} transition object of type 
     *    {duration: number, curve: f[0,1] -> [0,1] or name}. if undefined, 
     *    opacity change is instantaneous.
     * @param {function()=} callback Zero-argument function to call on observed
     *    completion (t=1)
     */
    Modifier.prototype.setSize = function(size, transition, callback) {
        this._sizeEnabled = !!size;
        if (!size) size = [ 0, 0 ];
        this.sizeState.set(size, transition, callback);
    };
    /**
     * Copy object to internal "default" transition. Missing properties in
     *    provided transitions inherit from this default.
     * 
     * (Scope: Component developers and deeper)
     * @name Modifier#setDefaultTransition
     * @function
     *    
     * @param {transition} transition {duration: number, curve: f[0,1] -> [0,1]}
     */
    Modifier.prototype.setDefaultTransition = function(transition) {
        this.transformTranslateState.setDefault(transition);
        this.transformRotateState.setDefault(transition);
        this.transformSkewState.setDefault(transition);
        this.transformScaleState.setDefault(transition);
        this.opacityState.setDefault(transition);
        this.originState.setDefault(transition);
        this.sizeState.setDefault(transition);
    };
    /**
     * Halt the entire transformation at current state.
     * (Scope: Component developers and deeper)
     * 
     * @name Modifier#halt
     * @function
     */
    Modifier.prototype.halt = function() {
        this.transformTranslateState.halt();
        this.transformRotateState.halt();
        this.transformSkewState.halt();
        this.transformScaleState.halt();
        this.opacityState.halt();
        this.originState.halt();
        this.sizeState.halt();
    };
    /**
     * Have we reached our end state in the motion transform?
     * 
     * @name Modifier#isActive
     * @function
     * 
     * @returns {boolean} 
     */
    Modifier.prototype.isActive = function() {
        return this.transformTranslateState.isActive() || this.transformRotateState.isActive() || this.transformSkewState.isActive() || this.transformScaleState.isActive();
    };
    /**
     * * Return {@renderSpec} for this Modifier, applying to the provided
     *    target component. The transform will be applied to the entire target
     *    tree in the following way: 
     *    * Positional Matrix (this.getTransform) - Multiplicatively 
     *    * Opacity (this.getOpacity) - Applied multiplicatively.
     *    * Origin (this.getOrigin) - Children shadow parents
     *
     * (Scope: Component developers and deeper)
     * 
     * @name Modifier#modify
     * @function
     * 
     * @param {renderSpec} target (already rendered) renderable component to
     *    which to apply the transform.
     * @returns {renderSpec} render spec for this Modifier, including the
     *    provided target
     */
    Modifier.prototype.modify = function(target) {
        return {
            transform: this.getTransform(),
            opacity: this.getOpacity(),
            origin: this.getOrigin(),
            size: this.getSize(),
            target: target
        };
    };
    module.exports = Modifier;
}.bind(this));

require.register("app/custom/light-box/light-box.js", function(exports, require, module) {
    var Matrix = require("famous/transform");
    var Modifier = require("famous/modifier");
    var RenderNode = require("famous/render-node");
    var Utility = require("famous/utilities/utility");
    /** @constructor */
    function LightBox(options) {
        this.options = {
            inTransform: Matrix.scale(.001, .001, .001),
            inOpacity: 0,
            inOrigin: [ .5, .5 ],
            outTransform: Matrix.scale(.001, .001, .001),
            outOpacity: 0,
            outOrigin: [ .5, .5 ],
            showTransform: Matrix.identity,
            showOpacity: 1,
            showOrigin: [ .5, .5 ],
            inTransition: true,
            outTransition: true,
            overlap: false
        };
        if (options) this.setOptions(options);
        this._showing = false;
        this.nodes = [];
        this.transforms = [];
    }
    LightBox.prototype.getOptions = function() {
        return this.options;
    };
    LightBox.prototype.setOptions = function(options) {
        if (options.inTransform !== undefined) this.options.inTransform = options.inTransform;
        if (options.inOpacity !== undefined) this.options.inOpacity = options.inOpacity;
        if (options.inOrigin !== undefined) this.options.inOrigin = options.inOrigin;
        if (options.outTransform !== undefined) this.options.outTransform = options.outTransform;
        if (options.outOpacity !== undefined) this.options.outOpacity = options.outOpacity;
        if (options.outOrigin !== undefined) this.options.outOrigin = options.outOrigin;
        if (options.showTransform !== undefined) this.options.showTransform = options.showTransform;
        if (options.showOpacity !== undefined) this.options.showOpacity = options.showOpacity;
        if (options.showOrigin !== undefined) this.options.showOrigin = options.showOrigin;
        if (options.inTransition !== undefined) this.options.inTransition = options.inTransition;
        if (options.outTransition !== undefined) this.options.outTransition = options.outTransition;
        if (options.overlap !== undefined) this.options.overlap = options.overlap;
    };
    LightBox.prototype.show = function(renderable, transition, callback) {
        this.curRenderable = renderable;
        if (!renderable) {
            return this.hide(callback);
        }
        if (transition instanceof Function) {
            callback = transition;
            transition = undefined;
        }
        if (this._showing) {
            if (this.options.overlap) this.hide(); else {
                this.hide(this.show.bind(this, renderable, callback));
                return;
            }
        }
        this._showing = true;
        //new options setting of a new renderable.
        if (renderable.options) this.setOptions(renderable.options);
        var transform = new Modifier({
            transform: this.options.inTransform,
            opacity: this.options.inOpacity,
            origin: this.options.inOrigin
        });
        var node = new RenderNode();
        node.add(transform).add(renderable);
        this.nodes.push(node);
        this.transforms.push(transform);
        var _cb = callback ? Utility.after(3, callback) : undefined;
        if (!transition) transition = this.options.inTransition;
        transform.setTransform(this.options.showTransform, transition, _cb);
        transform.setOpacity(this.options.showOpacity, transition, _cb);
        transform.setOrigin(this.options.showOrigin, transition, _cb);
    };
    LightBox.prototype.hide = function(transition, callback) {
        if (!this._showing) return;
        this._showing = false;
        if (transition instanceof Function) {
            callback = transition;
            transition = undefined;
        }
        var node = this.nodes[this.nodes.length - 1];
        var transform = this.transforms[this.transforms.length - 1];
        var _cb = Utility.after(3, function() {
            this.nodes.splice(this.nodes.indexOf(node), 1);
            this.transforms.splice(this.transforms.indexOf(transform), 1);
            if (callback) callback.call(this);
        }.bind(this));
        if (!transition) transition = this.options.outTransition;
        transform.setTransform(this.options.outTransform, transition, _cb);
        transform.setOpacity(this.options.outOpacity, transition, _cb);
        transform.setOrigin(this.options.outOrigin, transition, _cb);
    };
    LightBox.prototype.render = function() {
        var result = [];
        for (var i = 0; i < this.nodes.length; i++) {
            result.push(this.nodes[i].render());
        }
        return result;
    };
    module.exports = LightBox;
}.bind(this));

require.register("famous_modules/famous/views/light-box/_git_master/index.js", function(exports, require, module) {
    var Transform = require("famous/transform");
    var Modifier = require("famous/modifier");
    var RenderNode = require("famous/render-node");
    var Utility = require("famous/utilities/utility");
    /**
     * @class Show, hide, or switch between different renderables 
     *   with a configurable transitions and in/out states
     * @description
     * @name LightBox
     * @constructor
     */
    function LightBox(options) {
        this.options = {
            inTransform: Transform.scale(.001, .001, .001),
            inOpacity: 0,
            inOrigin: [ .5, .5 ],
            outTransform: Transform.scale(.001, .001, .001),
            outOpacity: 0,
            outOrigin: [ .5, .5 ],
            showTransform: Transform.identity,
            showOpacity: 1,
            showOrigin: [ .5, .5 ],
            inTransition: true,
            outTransition: true,
            overlap: false
        };
        if (options) this.setOptions(options);
        this._showing = false;
        this.nodes = [];
        this.transforms = [];
    }
    LightBox.prototype.getOptions = function() {
        return this.options;
    };
    LightBox.prototype.setOptions = function(options) {
        if (options.inTransform !== undefined) this.options.inTransform = options.inTransform;
        if (options.inOpacity !== undefined) this.options.inOpacity = options.inOpacity;
        if (options.inOrigin !== undefined) this.options.inOrigin = options.inOrigin;
        if (options.outTransform !== undefined) this.options.outTransform = options.outTransform;
        if (options.outOpacity !== undefined) this.options.outOpacity = options.outOpacity;
        if (options.outOrigin !== undefined) this.options.outOrigin = options.outOrigin;
        if (options.showTransform !== undefined) this.options.showTransform = options.showTransform;
        if (options.showOpacity !== undefined) this.options.showOpacity = options.showOpacity;
        if (options.showOrigin !== undefined) this.options.showOrigin = options.showOrigin;
        if (options.inTransition !== undefined) this.options.inTransition = options.inTransition;
        if (options.outTransition !== undefined) this.options.outTransition = options.outTransition;
        if (options.overlap !== undefined) this.options.overlap = options.overlap;
    };
    LightBox.prototype.show = function(renderable, transition, callback) {
        if (!renderable) {
            return this.hide(callback);
        }
        if (transition instanceof Function) {
            callback = transition;
            transition = undefined;
        }
        if (this._showing) {
            if (this.options.overlap) this.hide(); else {
                this.hide(this.show.bind(this, renderable, callback));
                return;
            }
        }
        this._showing = true;
        var transform = new Modifier({
            transform: this.options.inTransform,
            opacity: this.options.inOpacity,
            origin: this.options.inOrigin
        });
        var node = new RenderNode();
        node.add(transform).add(renderable);
        this.nodes.push(node);
        this.transforms.push(transform);
        var _cb = callback ? Utility.after(3, callback) : undefined;
        if (!transition) transition = this.options.inTransition;
        transform.setTransform(this.options.showTransform, transition, _cb);
        transform.setOpacity(this.options.showOpacity, transition, _cb);
        transform.setOrigin(this.options.showOrigin, transition, _cb);
    };
    LightBox.prototype.hide = function(transition, callback) {
        if (!this._showing) return;
        this._showing = false;
        if (transition instanceof Function) {
            callback = transition;
            transition = undefined;
        }
        var node = this.nodes[this.nodes.length - 1];
        var transform = this.transforms[this.transforms.length - 1];
        var _cb = Utility.after(3, function() {
            this.nodes.splice(this.nodes.indexOf(node), 1);
            this.transforms.splice(this.transforms.indexOf(transform), 1);
            if (callback) callback.call(this);
        }.bind(this));
        if (!transition) transition = this.options.outTransition;
        transform.setTransform(this.options.outTransform, transition, _cb);
        transform.setOpacity(this.options.outOpacity, transition, _cb);
        transform.setOrigin(this.options.outOrigin, transition, _cb);
    };
    LightBox.prototype.render = function() {
        var result = [];
        for (var i = 0; i < this.nodes.length; i++) {
            result.push(this.nodes[i].render());
        }
        return result;
    };
    module.exports = LightBox;
}.bind(this));

require.register("famous_modules/famous/views/edge-swapper/_git_master/index.js", function(exports, require, module) {
    var Entity = require("famous/entity");
    var EventHandler = require("famous/event-handler");
    var Transform = require("famous/transform");
    var LightBox = require("famous/views/light-box");
    /**
     * @class Container which handles swapping renderables from edge 
     * @description
     * @name EdgeSwapper
     * @constructor
     * @example 
     *   var edgeSwapper = new EdgeSwapper();
     *   context.link(edgeSwapper); // links edgeSwapper to context
     *   edgeSwapper.show(mySurface); // slide in mySurface
     */
    function EdgeSwapper(options) {
        this.options = Object.create(EdgeSwapper.DEFAULT_OPTIONS);
        this._currTarget = undefined;
        this._size = [ window.innerWidth, window.innerHeight ];
        this.lightbox = new LightBox(this.options);
        this.eventInput = new EventHandler();
        EventHandler.setInputHandler(this, this.eventInput);
        this.id = Entity.register(this);
        if (options) this.setOptions(options);
    }
    EdgeSwapper.DEFAULT_OPTIONS = {
        inOrigin: [ 0, 0 ],
        outOrigin: [ 0, 0 ],
        showOrigin: [ 0, 0 ],
        inTransform: Transform.translate(window.innerWidth, 0, 0),
        outTransform: Transform.translate(window.innerWidth, 0, .01)
    };
    EdgeSwapper.prototype.show = function(content) {
        if (this._currTarget) this.eventInput.unpipe(this._currTarget);
        this._currTarget = content;
        if (this._currTarget) {
            if (this._currTarget.setSize) this._currTarget.setSize(this._size);
            if (this._currTarget.emit) this.eventInput.pipe(this._currTarget);
        }
        this.lightbox.show.apply(this.lightbox, arguments);
    };
    EdgeSwapper.prototype.setOptions = function(options) {
        this.lightbox.setOptions(options);
    };
    EdgeSwapper.prototype.render = function() {
        return this.id;
    };
    EdgeSwapper.prototype.commit = function(context) {
        var transform = context.transform;
        var opacity = context.opacity;
        var origin = context.origin;
        var size = context.size;
        if (size[0] != this._size[0] || size[1] != this._size[1]) {
            this._size = size;
            this.lightbox.setOptions({
                inTransform: Transform.translate(this._size[0], 0, 0),
                outTransform: Transform.translate(this._size[0], 0, .01)
            });
            if (this._currTarget && this._currTarget.setSize) this._currTarget.setSize(size);
        }
        return {
            transform: transform,
            opacity: opacity,
            origin: origin,
            size: size,
            target: this.lightbox.render()
        };
    };
    module.exports = EdgeSwapper;
}.bind(this));

require.register("famous_modules/famous/widgets/title-bar/_git_master/index.js", function(exports, require, module) {
    var Transform = require("famous/transform");
    var Surface = require("famous/surface");
    var LightBox = require("famous/views/light-box");
    function TitleBar(options) {
        this.options = Object.create(TitleBar.DEFAULT_OPTIONS);
        this.lightbox = new LightBox();
        this._surfaces = {};
        if (options) this.setOptions(options);
    }
    TitleBar.DEFAULT_OPTIONS = {
        widget: Surface,
        inOrigin: [ .5, 0 ],
        outOrigin: [ .5, 0 ],
        showOrigin: [ .5, 0 ],
        inTransition: true,
        outTransition: true,
        size: [ undefined, 50 ],
        look: undefined
    };
    TitleBar.prototype.show = function(title) {
        var widget = this.options.widget;
        if (!(title in this._surfaces)) {
            var surface = new widget({
                size: this.options.size
            });
            surface.setOptions(this.options.look);
            surface.setContent(title);
            this._surfaces[title] = surface;
        }
        this.lightbox.show(this._surfaces[title]);
    };
    TitleBar.prototype.getSize = function() {
        return this.options.size;
    };
    TitleBar.prototype.setOptions = function(options) {
        this.lightbox.setOptions(options);
        if (options.widget) {
            this.options.widget = options.widget;
            this._surfaces = {};
        }
        if (options.look) {
            this.options.look = options.look;
        }
        if (options.size) {
            this.options.size = options.size;
            var sourceTransform = Transform.translate(0, -this.options.size[1]);
            this.lightbox.setOptions({
                inTransform: sourceTransform,
                outTransform: sourceTransform
            });
        }
    };
    TitleBar.prototype.render = function() {
        return this.lightbox.render();
    };
    module.exports = TitleBar;
}.bind(this));

require.register("famous_modules/famous/view-sequence/_git_master/index.js", function(exports, require, module) {
    /**
     * @class ViewSequence
     *
     * @name ViewSequence
     * @constructor
     * @description
     *   Helper object used to iterate through items sequentially. Used in 
     *   famous views that deal with layout.
     *
     * @param {Array} array Array that will be viewed
     * @param {number} index Index of array to begin at
     * @param {boolean} loop Whether to loop around the array at end
     */
    function ViewSequence(array, index, loop) {
        this.array = array || [];
        this.index = index || 0;
        this.loop = loop || false;
        this._prev = null;
        this._prevIndex = undefined;
        this._next = null;
        this._nextIndex = undefined;
    }
    ViewSequence.prototype._createPrevious = function() {
        var prev = new this.constructor(this.array, this._prevIndex, this.loop);
        prev._next = this;
        prev._nextIndex = this.index;
        return prev;
    };
    ViewSequence.prototype._createNext = function() {
        var next = new this.constructor(this.array, this._nextIndex, this.loop);
        next._prev = this;
        next._prevIndex = this.index;
        return next;
    };
    ViewSequence.prototype.getPrevious = function() {
        var prevIndex = this.index - 1;
        if (this.index == 0) {
            if (this.loop) prevIndex = this.array.length - 1; else return null;
        }
        if (!this._prev || this._prevIndex != prevIndex) {
            this._prevIndex = prevIndex;
            this._prev = this._createPrevious();
        }
        return this._prev;
    };
    ViewSequence.prototype.getNext = function() {
        var nextIndex = this.index + 1;
        if (nextIndex >= this.array.length) {
            if (this.loop) nextIndex = 0; else return null;
        }
        if (!this._next || this._nextIndex != nextIndex) {
            this._nextIndex = nextIndex;
            this._next = this._createNext();
        }
        return this._next;
    };
    ViewSequence.prototype.toString = function() {
        return this.index;
    };
    ViewSequence.prototype.unshift = function(value) {
        if (!this._prev || this.index === 0) {
            var offset = arguments.length;
            this.array.unshift.apply(this.array, arguments);
            _reindex.call(this, offset);
        } else this._prev.unshift.apply(this._prev, arguments);
    };
    ViewSequence.prototype.push = function(value) {
        this.array.push.apply(this.array, arguments);
    };
    ViewSequence.prototype.splice = function(index, howMany, value) {
        if (!this._prev || this.index === index) {
            var offset = this.index >= index ? arguments.length - 2 - howMany : 0;
            this.array.splice.apply(this.array, arguments);
            if (offset) _reindex.call(this, offset);
        } else this._prev.splice.apply(this._prev, arguments);
    };
    function _reindex(offset) {
        var i = this.index;
        var currentNode = this;
        while (currentNode && i < this.array.length) {
            currentNode.index += offset;
            if (currentNode._prevIndex !== undefined) currentNode._prevIndex += offset;
            if (currentNode._nextIndex !== undefined) currentNode._nextIndex += offset;
            currentNode = currentNode._next;
        }
    }
    ViewSequence.prototype.get = function() {
        return this.array[this.index];
    };
    ViewSequence.prototype.getSize = function() {
        var target = this.get();
        if (!target) return;
        if (!target.getSize) return null;
        return target.getSize.apply(target, arguments);
    };
    ViewSequence.prototype.render = function() {
        var target = this.get();
        if (!target) return;
        return target.render.apply(target, arguments);
    };
    module.exports = ViewSequence;
}.bind(this));

require.register("famous_modules/famous/views/grid-layout/_git_master/index.js", function(exports, require, module) {
    var Entity = require("famous/entity");
    var RenderNode = require("famous/render-node");
    var Transform = require("famous/transform");
    var ViewSequence = require("famous/view-sequence");
    var Modifier = require("famous/modifier");
    var OptionsManager = require("famous/options-manager");
    /**
     * @class Layout which divides a context into several evenly-sized grid cells
     * @name GridLayout
     * @description
     *     If dimensions are provided, the grid is evenly subdivided with children
     *     cells representing their own context.
     *     If dimensions are not provided, the cellSize property is used to compute
     *     dimensions so that items of cellSize will fit.
     * @constructor
     * @example 
     *     var myLayout = new GridLayout({
     *         size: [5, 2]
     *     });
     *     var mySurfaces = new ViewSequence();
     *     for(var i = 0; i < 10; i++) {
     *         mySurfaces.push(new Surface({content: 'Item ' + i}));
     *     }
     *     myLayout.sequenceFrom(mySurfaces); // takes ViewSequence, autoboxes Array
     *     context.link(myLayout); // distribute the surfaces in a 5x2 grid
     *   });
     */
    function GridLayout(options) {
        this.options = Object.create(GridLayout.DEFAULT_OPTIONS);
        this.optionsManager = new OptionsManager(this.options);
        if (options) this.setOptions(options);
        this.id = Entity.register(this);
        this._modifiers = [];
        this._contextSizeCache = [ 0, 0 ];
        this._dimensionsCache = [ 0, 0 ];
        this._activeCount = 0;
    }
    GridLayout.DEFAULT_OPTIONS = {
        dimensions: [ 1, 1 ],
        cellSize: [ 250, 250 ],
        transition: false
    };
    GridLayout.prototype.render = function() {
        return this.id;
    };
    GridLayout.prototype.setOptions = function(options) {
        return this.optionsManager.setOptions(options);
    };
    GridLayout.prototype.sequenceFrom = function(sequence) {
        if (sequence instanceof Array) sequence = new ViewSequence(sequence);
        this.sequence = sequence;
    };
    GridLayout.prototype.commit = function(context) {
        var transform = context.transform;
        var opacity = context.opacity;
        var origin = context.origin;
        var size = context.size;
        var cols = this.options.dimensions[0];
        var rows = this.options.dimensions[1];
        if (size[0] !== this._contextSizeCache[0] || size[1] !== this._contextSizeCache[1] || cols !== this._dimensionsCache[0] || rows !== this._dimensionsCache[1]) {
            if (!rows) rows = Math.floor(size[1] / this.options.cellSize[1]);
            if (!cols) cols = Math.floor(size[0] / this.options.cellSize[0]);
            var rowSize = size[1] / rows;
            var colSize = size[0] / cols;
            for (var i = 0; i < rows; i++) {
                var currY = Math.round(rowSize * i);
                for (var j = 0; j < cols; j++) {
                    var currX = Math.round(colSize * j);
                    var currIndex = i * cols + j;
                    if (!(currIndex in this._modifiers)) this._modifiers[currIndex] = new Modifier({
                        opacity: 0
                    });
                    var currModifier = this._modifiers[currIndex];
                    currModifier.halt();
                    currModifier.setTransform(Transform.translate(currX, currY), this.options.transition);
                    currModifier.setSize([ Math.round(colSize * (j + 1)) - currX, Math.round(rowSize * (i + 1)) - currY ], this.options.transition);
                    currModifier.setOpacity(1, this.options.transition);
                }
            }
            this._dimensionsCache = [ this.options.dimensions[0], this.options.dimensions[1] ];
            this._contextSizeCache = [ size[0], size[1] ];
            this._activeCount = rows * cols;
            for (var i = this._activeCount; i < this._modifiers.length; i++) {
                var currModifier = this._modifiers[i];
                currModifier.halt();
                currModifier.setTransform(Transform.identity, this.options.transition);
                currModifier.setSize([ Math.round(colSize), Math.round(rowSize) ], this.options.transition);
                currModifier.setOpacity(0, this.options.transition);
            }
        }
        var sequence = this.sequence;
        var result = [];
        var currIndex = 0;
        while (sequence && currIndex < this._modifiers.length) {
            var item = sequence.get();
            var modifier = this._modifiers[currIndex];
            if (currIndex >= this._activeCount && !modifier.isActive()) this._modifiers.splice(currIndex);
            if (item) {
                result[currIndex] = modifier.modify({
                    origin: origin,
                    target: item.render()
                });
            }
            sequence = sequence.getNext();
            currIndex++;
        }
        if (size) transform = Transform.moveThen([ -size[0] * origin[0], -size[1] * origin[1], 0 ], transform);
        var nextSpec = {
            transform: transform,
            opacity: opacity,
            size: size,
            target: result
        };
        return nextSpec;
    };
    module.exports = GridLayout;
}.bind(this));

require.register("famous_modules/famous/views/fader/_git_master/index.js", function(exports, require, module) {
    var Transitionable = require("famous/transitions/transitionable");
    /*
     * @class Modifier which fades renderables in and out via opacity
     * @description
     * @name Fader
     * @constructor
     * @example 
     *     var fader = new Fader();
     *     var surface = new Surface();
     *     myContext.link(fader).link(surface);
     *     fader.show(); // fades in the surface
     */
    function FamousFader(options, startState) {
        this.options = {
            cull: false,
            transition: true,
            pulseInTransition: true,
            pulseOutTransition: true,
            visibilityThreshold: 0
        };
        if (options) this.setOptions(options);
        if (!startState) startState = 0;
        this.transitionHelper = new Transitionable(startState);
    }
    FamousFader.prototype.getOptions = function() {
        return this.options;
    };
    FamousFader.prototype.setOptions = function(options) {
        if (options.cull !== undefined) this.options.cull = options.cull;
        if (options.transition !== undefined) this.options.transition = options.transition;
        if (options.pulseInTransition !== undefined) this.options.pulseInTransition = options.pulseInTransition;
        if (options.pulseOutTransition !== undefined) this.options.pulseOutTransition = options.pulseOutTransition;
        if (options.visibilityThreshold !== undefined) this.options.visibilityThreshold = options.visibilityThreshold;
    };
    FamousFader.prototype.show = function(callback) {
        this.set(1, this.options.transition, callback);
    };
    FamousFader.prototype.hide = function(callback) {
        this.set(0, this.options.transition, callback);
    };
    FamousFader.prototype.pulse = function(state, callback) {
        if (state === undefined) state = 1;
        var startState = this.transitionHelper.get();
        this.transitionHelper.set(state, this.options.pulseInTransition);
        this.transitionHelper.set(startState, this.options.pulseOutTransition, callback);
    };
    FamousFader.prototype.set = function(state, transition, callback) {
        this.transitionHelper.halt();
        this.transitionHelper.set(state, transition, callback);
    };
    FamousFader.prototype.render = function(target) {
        var currOpacity = this.transitionHelper.get();
        if (this.options.cull && !currOpacity) return; else return {
            opacity: currOpacity,
            target: target
        };
    };
    FamousFader.prototype.isVisible = function() {
        var threshold = this.options.visibilityThreshold;
        if (threshold >= 1) return this.transitionHelper.get() == 1; else return this.transitionHelper.get() > threshold;
    };
    module.exports = FamousFader;
}.bind(this));

require.register("famous_modules/famous/views/image-fader/_git_master/index.js", function(exports, require, module) {
    var RenderNode = require("famous/render-node");
    var Fader = require("famous/views/fader");
    var Transform = require("famous/transform");
    /**
     * @name ImageFader
     * @constructor
     * To be deleted.
     */
    function ImageFader(options) {
        this.options = Object.create(ImageFader.DEFAULT_OPTIONS);
        this._nodes = [];
        this._faders = [];
        this._mode = -1;
        if (options) this.setOptions(options);
        this._output = [];
    }
    ImageFader.DEFAULT_OPTIONS = {
        crossfade: false
    };
    ImageFader.prototype.getMode = function() {
        return this._mode;
    };
    ImageFader.prototype.setMode = function(mode, transition, callback) {
        this._mode = mode;
        if (this.options.crossfade) {
            for (var i = 0; i < this._faders.length; i++) this._faders[i].set(0, transition);
            this._faders[mode].set(1, transition, callback);
        } else {
            this._faders[mode].set(1, transition, function() {
                if (this._mode != mode) return;
                for (var i = 0; i < this._faders.length; i++) if (i != mode) this._faders[i].set(0);
                if (callback) callback();
            }.bind(this));
        }
    };
    ImageFader.prototype.forMode = function(mode) {
        if (!this._nodes[mode]) {
            this._nodes[mode] = new RenderNode();
            this._faders[mode] = new Fader(this.options);
        }
        return this._nodes[mode];
    };
    ImageFader.prototype.setOptions = function(options) {
        if (options.crossfade !== undefined) this.options.crossfade = options.crossfade;
    };
    ImageFader.behindMatrix = Transform.translate(0, 0, -.01);
    ImageFader.prototype.render = function(input) {
        if (this._nodes.length > this._output.length) this._output.splice(this._nodes.length);
        for (var i = 0; i < this._nodes.length; i++) {
            var rendered = this._faders[i].render(this._nodes[i].render());
            if (i !== this._mode) rendered = {
                transform: ImageFader.behindMatrix,
                target: rendered
            };
            this._output[i] = rendered;
        }
        return this._output;
    };
    module.exports = ImageFader;
}.bind(this));

require.register("famous_modules/famous/widgets/toggle-button/_git_master/index.js", function(exports, require, module) {
    var Surface = require("famous/surface");
    var EventHandler = require("famous/event-handler");
    var ImageFader = require("famous/views/image-fader");
    function ToggleButton(options) {
        this.options = {
            content: "",
            offClasses: [ "off" ],
            onClasses: [ "on" ],
            size: undefined,
            outTransition: {
                curve: "easeInOut",
                duration: 300
            },
            inTransition: {
                curve: "easeInOut",
                duration: 300
            },
            toggleMode: ToggleButton.TOGGLE,
            crossfade: false
        };
        this.eventOutput = new EventHandler();
        EventHandler.setOutputHandler(this, this.eventOutput);
        this.offSurface = new Surface();
        this.offSurface.on("click", function() {
            if (this.options.toggleMode !== ToggleButton.OFF) this.select();
        }.bind(this));
        this.offSurface.pipe(this.eventOutput);
        this.onSurface = new Surface();
        this.onSurface.on("click", function() {
            if (this.options.toggleMode !== ToggleButton.ON) this.deselect();
        }.bind(this));
        this.onSurface.pipe(this.eventOutput);
        this.arbiter = new ImageFader({
            crossfade: this.options.crossfade
        });
        this.arbiter.forMode(ToggleButton.OFF).add(this.offSurface);
        this.arbiter.forMode(ToggleButton.ON).add(this.onSurface);
        this.arbiter.setMode(ToggleButton.OFF);
        this.selected = false;
        if (options) this.setOptions(options);
    }
    /** @const */
    ToggleButton.OFF = 0;
    /** @const */
    ToggleButton.ON = 1;
    /** @const */
    ToggleButton.TOGGLE = 2;
    // only used for mode
    ToggleButton.prototype.select = function() {
        this.selected = true;
        this.arbiter.setMode(ToggleButton.ON, this.options.inTransition);
        this.eventOutput.emit("select");
    };
    ToggleButton.prototype.deselect = function() {
        this.selected = false;
        this.arbiter.setMode(ToggleButton.OFF, this.options.outTransition);
        this.eventOutput.emit("deselect");
    };
    ToggleButton.prototype.isSelected = function() {
        return this.selected;
    };
    ToggleButton.prototype.setOptions = function(options) {
        if (options.content !== undefined) {
            this.options.content = options.content;
            this.offSurface.setContent(this.options.content);
            this.onSurface.setContent(this.options.content);
        }
        if (options.offClasses) {
            this.options.offClasses = options.offClasses;
            this.offSurface.setClasses(this.options.offClasses);
        }
        if (options.onClasses) {
            this.options.onClasses = options.onClasses;
            this.onSurface.setClasses(this.options.onClasses);
        }
        if (options.size !== undefined) {
            this.options.size = options.size;
            this.onSurface.setSize(this.options.size);
            this.offSurface.setSize(this.options.size);
        }
        if (options.toggleMode !== undefined) this.options.toggleMode = options.toggleMode;
        if (options.outTransition !== undefined) this.options.outTransition = options.outTransition;
        if (options.inTransition !== undefined) this.options.inTransition = options.inTransition;
        if (options.crossfade !== undefined) {
            this.options.crossfade = options.crossfade;
            this.arbiter.setOptions({
                crossfade: this.options.crossfade
            });
        }
    };
    ToggleButton.prototype.getSize = function() {
        return this.options.size;
    };
    ToggleButton.prototype.render = function() {
        return this.arbiter.render();
    };
    module.exports = ToggleButton;
}.bind(this));

require.register("famous_modules/famous/widgets/tab-bar/_git_master/index.js", function(exports, require, module) {
    var EventHandler = require("famous/event-handler");
    var Utility = require("famous/utilities/utility");
    var View = require("famous/view");
    var GridLayout = require("famous/views/grid-layout");
    var ToggleButton = require("famous/widgets/toggle-button");
    function TabBar(options) {
        View.apply(this, arguments);
        this.layout = new GridLayout();
        this.buttons = [];
        this._buttonIds = {};
        this._buttonCallbacks = {};
        this.layout.sequenceFrom(this.buttons);
        this._add(this.layout);
        this._optionsManager.on("change", _updateOptions.bind(this));
    }
    TabBar.prototype = Object.create(View.prototype);
    TabBar.prototype.constructor = TabBar;
    TabBar.DEFAULT_OPTIONS = {
        sections: [],
        widget: ToggleButton,
        size: [ undefined, 50 ],
        direction: Utility.Direction.X,
        buttons: {
            toggleMode: ToggleButton.ON
        }
    };
    function _updateOptions(data) {
        var id = data.id;
        var value = data.value;
        if (id === "direction") {
            this.layout.setOptions({
                dimensions: _resolveGridDimensions.call(this.buttons.length, this.options.direction)
            });
        } else if (id === "buttons") {
            for (var i in this.buttons) {
                this.buttons[i].setOptions(value);
            }
        } else if (id === "sections") {
            for (var id in this.options.sections) {
                this.defineSection(id, this.options.sections[id]);
            }
        }
    }
    function _resolveGridDimensions(count, direction) {
        if (direction === Utility.Direction.X) return [ count, 1 ]; else return [ 1, count ];
    }
    TabBar.prototype.defineSection = function(id, content) {
        var button;
        var i = this._buttonIds[id];
        if (i === undefined) {
            i = this.buttons.length;
            this._buttonIds[id] = i;
            var widget = this.options.widget;
            button = new widget();
            this.buttons[i] = button;
            this.layout.setOptions({
                dimensions: _resolveGridDimensions(this.buttons.length, this.options.direction)
            });
        } else {
            button = this.buttons[i];
            button.unbind("select", this._buttonCallbacks[id]);
        }
        if (this.options.buttons) button.setOptions(this.options.buttons);
        button.setOptions(content);
        this._buttonCallbacks[id] = this.select.bind(this, id);
        button.on("select", this._buttonCallbacks[id]);
    };
    TabBar.prototype.select = function(id) {
        var btn = this._buttonIds[id];
        // this prevents event loop
        if (this.buttons[btn] && this.buttons[btn].isSelected()) {
            this._eventOutput.emit("select", {
                id: id
            });
        } else {
            this.buttons[btn] && this.buttons[btn].select();
        }
        for (var i = 0; i < this.buttons.length; i++) {
            if (i != btn) this.buttons[i].deselect();
        }
    };
    module.exports = TabBar;
}.bind(this));

require.register("famous_modules/famous/group/_git_master/index.js", function(exports, require, module) {
    var Context = require("famous/context");
    var Transform = require("famous/transform");
    var Surface = require("famous/surface");
    /**
     * @class (DEPRECATED) An object designed to contain surfaces and set properties
     *   to be applied to all of them at once.
     *
     * @description
     *  NOTE: DEPRECATED, consider using ContainerSurface instead
     *  * A group will enforce these properties on the 
     *   surfaces it contains:
     *     * size (clips contained surfaces to its own width and height)
     *     * origin
     *     * its own opacity and transform, which will be automatically 
     *       applied to  all Surfaces contained directly and indirectly.
     *   These properties are maintained through a {@link 
     *   SurfaceManager} unique to this Container Surface.
     *   Implementation note: in the DOM case, this will generate a div with 
     *   the style 'containerSurface' applied.
     *   
     * @name Group
     * @extends Surface
     * @constructor
     */
    function Group(options) {
        Surface.call(this, options);
        this._shouldRecalculateSize = false;
        this._container = document.createDocumentFragment();
        this.context = new Context(this._container);
        this.setContent(this._container);
        this._groupSize = [ undefined, undefined ];
        this._origin = undefined;
        this._originTransfer = {
            render: function(input) {
                return {
                    origin: this._origin,
                    target: input
                };
            }.bind(this)
        };
    }
    /** @const */
    Group.SIZE_ZERO = [ 0, 0 ];
    Group.prototype = Object.create(Surface.prototype);
    Group.prototype.elementType = "div";
    Group.prototype.elementClass = "famous-group";
    Group.prototype.add = function() {
        var segment = this.context.add(this._originTransfer);
        return segment.add.apply(segment, arguments);
    };
    Group.prototype.add = function() {
        return this.context.add.apply(this.context, arguments);
    };
    Group.prototype.render = function() {
        return Surface.prototype.render.call(this);
    };
    Group.prototype.deploy = function(target) {
        this.context.migrate(target);
    };
    Group.prototype.recall = function(target) {
        this._container = document.createDocumentFragment();
        this.context.migrate(this._container);
    };
    Group.prototype.commit = function(context) {
        var transform = context.transform;
        var opacity = context.opacity;
        var origin = context.origin;
        var size = context.size;
        transform = Transform.moveThen([ -origin[0] * size[0], -origin[1] * size[1], 0 ], transform);
        var result = Surface.prototype.commit.call(this, context, transform, opacity, origin, Group.SIZE_ZERO);
        this._origin = origin;
        if (size[0] != this._groupSize[0] || size[1] != this._groupSize[1]) {
            this.context.setSize(size);
            this._groupSize[0] = size[0];
            this._groupSize[1] = size[1];
        }
        this.context.update();
        return result;
    };
    module.exports = Group;
}.bind(this));

require.register("famous_modules/famous/input/mouse-sync/_git_master/index.js", function(exports, require, module) {
    var EventHandler = require("famous/event-handler");
    /**
     * @class Handles piped in mouse drag events. Outputs an object with two
     *        properties, position and velocity.
     * @description
     * @name MouseSync
     * @constructor
     * @example
     * 
     *     var Engine = require('famous/Engine');
     *     var Surface = require('famous/Surface');
     *     var Modifier = require('famous/Modifier');
     *     var FM = require('famous/Matrix');
     *     var MouseSync = require('famous-sync/MouseSync');
     *     var Context = Engine.createContext();
     *
     *     var surface = new Surface({
     *         size: [200,200],
     *         properties: {
     *             backgroundColor: 'red'
     *         }
     *     });
     *
     *     var modifier = new Modifier({
     *         transform: undefined
     *     });
     *
     *     var position = 0;
     *     var sync = new MouseSync(function(){
     *         return position;
     *     }, {direction: MouseSync.DIRECTION_Y});  
     *
     *     surface.pipe(sync);
     *     sync.on('update', function(data) {
     *         var edge = window.innerHeight - (surface.getSize()[1])
     *         if (data.p > edge) {
     *             position = edge;
     *         } else if (data.p < 0) {
     *             position = 0;
     *         } else {
     *             position = data.p;
     *         }
     *         modifier.setTransform(FM.translate(0, position, 0));
     *         surface.setContent('position' + position + '<br>' + 'velocity' + data.v.toFixed(2));
     *     });
     *     Context.link(modifier).link(surface);
     * 
     */
    function MouseSync(targetGet, options) {
        this.targetGet = targetGet;
        this.options = {
            direction: undefined,
            rails: false,
            scale: 1,
            stallTime: 50,
            propogate: true
        };
        if (options) {
            this.setOptions(options);
        } else {
            this.setOptions(this.options);
        }
        this.input = new EventHandler();
        this.output = new EventHandler();
        EventHandler.setInputHandler(this, this.input);
        EventHandler.setOutputHandler(this, this.output);
        this._prevCoord = undefined;
        this._prevTime = undefined;
        this._prevVel = undefined;
        this.input.on("mousedown", _handleStart.bind(this));
        this.input.on("mousemove", _handleMove.bind(this));
        this.input.on("mouseup", _handleEnd.bind(this));
        this.options.propogate ? this.input.on("mouseleave", _handleLeave.bind(this)) : this.input.on("mouseleave", _handleEnd.bind(this));
    }
    /** @const */
    MouseSync.DIRECTION_X = 0;
    /** @const */
    MouseSync.DIRECTION_Y = 1;
    function _handleStart(e) {
        e.preventDefault();
        // prevent drag
        this._prevCoord = [ e.clientX, e.clientY ];
        this._prevTime = Date.now();
        this._prevVel = this.options.direction !== undefined ? 0 : [ 0, 0 ];
        this.output.emit("start");
    }
    function _handleMove(e) {
        if (!this._prevCoord) return;
        var prevCoord = this._prevCoord;
        var prevTime = this._prevTime;
        var currCoord = [ e.clientX, e.clientY ];
        var currTime = Date.now();
        var diffX = currCoord[0] - prevCoord[0];
        var diffY = currCoord[1] - prevCoord[1];
        if (this.options.rails) {
            if (Math.abs(diffX) > Math.abs(diffY)) diffY = 0; else diffX = 0;
        }
        var diffTime = Math.max(currTime - prevTime, 8);
        // minimum tick time
        var velX = diffX / diffTime;
        var velY = diffY / diffTime;
        var prevPos = this.targetGet();
        var scale = this.options.scale;
        var nextPos;
        var nextVel;
        if (this.options.direction == MouseSync.DIRECTION_X) {
            nextPos = prevPos + scale * diffX;
            nextVel = scale * velX;
        } else if (this.options.direction == MouseSync.DIRECTION_Y) {
            nextPos = prevPos + scale * diffY;
            nextVel = scale * velY;
        } else {
            nextPos = [ prevPos[0] + scale * diffX, prevPos[1] + scale * diffY ];
            nextVel = [ scale * velX, scale * velY ];
        }
        this.output.emit("update", {
            p: nextPos,
            v: nextVel
        });
        this._prevCoord = currCoord;
        this._prevTime = currTime;
        this._prevVel = nextVel;
    }
    function _handleEnd(e) {
        if (!this._prevCoord) return;
        var prevTime = this._prevTime;
        var currTime = Date.now();
        if (currTime - prevTime > this.options.stallTime) this._prevVel = this.options.direction == undefined ? [ 0, 0 ] : 0;
        var pos = this.targetGet();
        this.output.emit("end", {
            p: pos,
            v: this._prevVel
        });
        this._prevCoord = undefined;
        this._prevTime = undefined;
        this._prevVel = undefined;
    }
    function _handleLeave(e) {
        if (!this._prevCoord) return;
        var boundMove = function(e) {
            _handleMove.call(this, e);
        }.bind(this);
        var boundEnd = function(e) {
            _handleEnd.call(this, e);
            document.removeEventListener("mousemove", boundMove);
            document.removeEventListener("mouseup", boundEnd);
        }.bind(this);
        document.addEventListener("mousemove", boundMove);
        document.addEventListener("mouseup", boundEnd);
    }
    MouseSync.prototype.getOptions = function() {
        return this.options;
    };
    MouseSync.prototype.setOptions = function(options) {
        if (options.direction !== undefined) this.options.direction = options.direction;
        if (options.rails !== undefined) this.options.rails = options.rails;
        if (options.scale !== undefined) this.options.scale = options.scale;
        if (options.stallTime !== undefined) this.options.stallTime = options.stallTime;
        if (options.propogate !== undefined) this.options.propogate = options.propogate;
    };
    module.exports = MouseSync;
}.bind(this));

require.register("app/custom/up-down-transform/up-down-transform.js", function(exports, require, module) {
    var Transform = require("famous/transform");
    var Easing = require("famous/transitions/easing");
    function UpDownTransform(options) {
        this.options = {
            inTransform: Transform.translate(0, 1500, 0),
            inOpacity: 1,
            inOrigin: [ .5, .5 ],
            outTransform: Transform.translate(0, 600, 0),
            outOpacity: 1,
            outOrigin: [ .5, .5 ],
            showTransform: Transform.identity,
            showOpacity: 1,
            showOrigin: [ .5, .5 ],
            inTransition: {
                duration: 500,
                curve: Easing.inQuad()
            },
            outTransition: {
                duration: 100,
                curve: Easing.outQuint()
            },
            overlap: true
        };
    }
    module.exports = UpDownTransform;
}.bind(this));

require.register("app/custom/conversation-surface/conversation-surface.js", function(exports, require, module) {
    var Surface = require("famous/surface");
    function ConversationSurface(opts) {
        Surface.apply(this, arguments);
        this.setSize([ undefined, true ]);
    }
    ConversationSurface.prototype = Object.create(Surface.prototype);
    //ConversationSurface.prototype.surfaceEvents = Surface.prototype.surfaceEvents.concat(['load']);
    ConversationSurface.prototype.deploy = function(target) {
        Surface.prototype.deploy.apply(this, arguments);
        this.__size = [ target.offsetWidth, target.offsetHeight ];
    };
    ConversationSurface.prototype.getSize = function() {
        return this.__size || this._size || this.size;
    };
    module.exports = ConversationSurface;
}.bind(this));

require.register("app/custom/sound-player/sound-player.js", function(exports, require, module) {
    var BufferLoader = require("buffer-loader");
    /**
     * @constructor
     */
    function SoundPlayer(urls, callback) {
        this.context;
        this.node;
        this.buffersActive = [];
        try {
            window.AudioContext = window.AudioContext || window.webkitAudioContext;
            this.context = new AudioContext();
            this.bufferLoader = new BufferLoader(this.context, urls, this.setSounds.bind(this));
            this.sounds;
            this.callback = callback || undefined;
            this.bufferLoader.load();
        } catch (e) {}
    }
    SoundPlayer.prototype.setSounds = function(sounds) {
        this.sounds = sounds;
        if (this.callback != undefined) {
            this.callback();
        }
    };
    SoundPlayer.prototype.isPlaying = function() {
        if (this.buffersActive.length > 0) {
            return true;
        } else {
            return false;
        }
    };
    SoundPlayer.prototype.stopPlaying = function() {
        var len = this.buffersActive.length;
        if (len > 0) {
            for (var i = 0; i < len; i++) {
                var buffer = this.buffersActive[i];
                buffer.stop(0);
            }
        }
    };
    SoundPlayer.prototype.getContext = function() {
        return this.context;
    };
    SoundPlayer.prototype.addNode = function(node) {
        this.node = node;
    };
    SoundPlayer.prototype.playSound = function(i, volume, callback) {
        if (this.context && this.sounds) {
            var buffer = this.context.createBufferSource();
            var gain = this.context.createGainNode ? this.context.createGainNode() : this.context.createGain();
            gain.gain.value = typeof volume === "undefined" ? .5 : volume;
            buffer.buffer = this.sounds[i];
            buffer.connect(gain);
            var lastNode = gain;
            if (this.node) {
                lastNode.connect(this.node);
                lastNode = this.node;
            }
            lastNode.connect(this.context.destination);
            buffer.start(0);
            buffer.onended = function() {
                var index = this.buffersActive.indexOf(buffer);
                if (index !== -1) {
                    this.buffersActive.splice(index, 1);
                }
                if (callback) {
                    callback();
                }
            }.bind(this, buffer);
            this.buffersActive.push(buffer);
        }
    };
    module.exports = SoundPlayer;
}.bind(this));

require.register("app/custom/sound-player/buffer-loader.js", function(exports, require, module) {
    /**
     * @constructor
     */
    function BufferLoader(context, urlList, callback) {
        this.context = context;
        this.urlList = urlList;
        this.onload = callback;
        this.bufferList = [];
        this.loadCount = 0;
    }
    BufferLoader.prototype.loadBuffer = function(url, index) {
        // Load buffer asynchronously
        var request = new XMLHttpRequest();
        request.open("GET", url, true);
        request.responseType = "arraybuffer";
        var loader = this;
        request.onload = function() {
            // Asynchronously decode the audio file data in request.response
            loader.context.decodeAudioData(request.response, function(buffer) {
                if (!buffer) {
                    console.log("error decoding file data: " + url);
                    return;
                }
                loader.bufferList[index] = buffer;
                if (++loader.loadCount == loader.urlList.length) loader.onload(loader.bufferList);
            });
        };
        request.onerror = function() {
            console.log("BufferLoader: XHR error");
        };
        request.send();
    };
    BufferLoader.prototype.load = function() {
        for (var i = 0; i < this.urlList.length; ++i) {
            this.loadBuffer(this.urlList[i], i);
        }
    };
    module.exports = BufferLoader;
}.bind(this));

require.register("famous_modules/famous/input/touch-tracker/_git_master/index.js", function(exports, require, module) {
    var EventHandler = require("famous/event-handler");
    /**
     * @class Helper to TouchSync  tracks piped in touch events, organizes touch 
     *        events by ID, and emits track events back to TouchSync.
     * @description
     * @name TouchTracker
     * @constructor
     */
    function TouchTracker(selective) {
        this.selective = selective;
        this.touchHistory = {};
        this.eventInput = new EventHandler();
        this.eventOutput = new EventHandler();
        EventHandler.setInputHandler(this, this.eventInput);
        EventHandler.setOutputHandler(this, this.eventOutput);
        this.eventInput.on("touchstart", _handleStart.bind(this));
        this.eventInput.on("touchmove", _handleMove.bind(this));
        this.eventInput.on("touchend", _handleEnd.bind(this));
        this.eventInput.on("touchcancel", _handleEnd.bind(this));
        this.eventInput.on("unpipe", _handleUnpipe.bind(this));
    }
    function _timestampTouch(touch, origin, history, count) {
        var touchClone = {};
        for (var i in touch) touchClone[i] = touch[i];
        return {
            touch: touchClone,
            origin: origin,
            timestamp: Date.now(),
            count: count,
            history: history
        };
    }
    function _handleStart(event) {
        for (var i = 0; i < event.changedTouches.length; i++) {
            var touch = event.changedTouches[i];
            var data = _timestampTouch(touch, event.origin, undefined, event.touches.length);
            this.eventOutput.emit("trackstart", data);
            if (!this.selective && !this.touchHistory[touch.identifier]) this.track(data);
        }
    }
    function _handleMove(event) {
        for (var i = 0; i < event.changedTouches.length; i++) {
            var touch = event.changedTouches[i];
            var history = this.touchHistory[touch.identifier];
            if (history) {
                var data = _timestampTouch(touch, event.origin, history, event.touches.length);
                this.touchHistory[touch.identifier].push(data);
                this.eventOutput.emit("trackmove", data);
            }
        }
    }
    function _handleEnd(event) {
        for (var i = 0; i < event.changedTouches.length; i++) {
            var touch = event.changedTouches[i];
            var history = this.touchHistory[touch.identifier];
            if (history) {
                var data = _timestampTouch(touch, event.origin, history, event.touches.length);
                this.eventOutput.emit("trackend", data);
                delete this.touchHistory[touch.identifier];
            }
        }
    }
    function _handleUnpipe(event) {
        for (var i in this.touchHistory) {
            var history = this.touchHistory[i];
            this.eventOutput.emit("trackend", {
                touch: history[history.length - 1].touch,
                timestamp: Date.now(),
                count: 0,
                history: history
            });
            delete this.touchHistory[i];
        }
    }
    TouchTracker.prototype.track = function(data) {
        this.touchHistory[data.touch.identifier] = [ data ];
    };
    module.exports = TouchTracker;
}.bind(this));

require.register("famous_modules/famous/input/touch-sync/_git_master/index.js", function(exports, require, module) {
    var TouchTracker = require("famous/input/touch-tracker");
    var EventHandler = require("famous/event-handler");
    /**
     * @class Handles piped in touch events. On update it outputs an
     *        object with position, velocity, acceleration, and touch id. On end
     *        it outputs an object with position, velocity, count, and touch id.
     * @description
     * @name TouchSync
     * @constructor
     * @example
     * 
     *     var Engine = require('famous/Engine');
     *     var Surface = require('famous/Surface');
     *     var Modifier = require('famous/Modifier');
     *     var FM = require('famous/Matrix');
     *     var TouchSync = require('famous-sync/TouchSync');
     *     var Context = Engine.createContext();
     *
     *     var surface = new Surface({
     *         size: [200,200],
     *         properties: {
     *             backgroundColor: 'red'
     *         }
     *     });
     *
     *     var modifier = new Modifier({
     *         transform: undefined
     *     });
     *
     *     var position = 0;
     *     var sync = new TouchSync(function(){
     *         return position;
     *     }, {direction: TouchSync.DIRECTION_Y});  
     *
     *     surface.pipe(sync);
     *     sync.on('update', function(data) {
     *         var edge = window.innerHeight - (surface.getSize()[1])
     *         if (data.p > edge) {
     *             position = edge;
     *         } else if (data.p < 0) {
     *             position = 0;
     *         } else {
     *             position = data.p;
     *         }
     *         modifier.setTransform(FM.translate(0, position, 0));
     *         surface.setContent('position' + position + '<br>' + 'velocity' + data.v.toFixed(2));
     *     });
     *     Context.link(modifier).link(surface);
     * 
     */
    function TouchSync(targetSync, options) {
        this.targetGet = targetSync;
        this.output = new EventHandler();
        this.touchTracker = new TouchTracker();
        this.options = {
            direction: undefined,
            rails: false,
            scale: 1
        };
        if (options) {
            this.setOptions(options);
        } else {
            this.setOptions(this.options);
        }
        EventHandler.setOutputHandler(this, this.output);
        EventHandler.setInputHandler(this, this.touchTracker);
        this.touchTracker.on("trackstart", _handleStart.bind(this));
        this.touchTracker.on("trackmove", _handleMove.bind(this));
        this.touchTracker.on("trackend", _handleEnd.bind(this));
    }
    /** @const */
    TouchSync.DIRECTION_X = 0;
    /** @const */
    TouchSync.DIRECTION_Y = 1;
    function _handleStart(data) {
        this.output.emit("start", {
            count: data.count,
            touch: data.touch.identifier
        });
    }
    function _handleMove(data) {
        var history = data.history;
        var prevTime = history[history.length - 2].timestamp;
        var currTime = history[history.length - 1].timestamp;
        var prevTouch = history[history.length - 2].touch;
        var currTouch = history[history.length - 1].touch;
        var diffX = currTouch.pageX - prevTouch.pageX;
        var diffY = currTouch.pageY - prevTouch.pageY;
        if (this.options.rails) {
            if (Math.abs(diffX) > Math.abs(diffY)) diffY = 0; else diffX = 0;
        }
        var diffTime = Math.max(currTime - prevTime, 8);
        // minimum tick time
        var velX = diffX / diffTime;
        var velY = diffY / diffTime;
        //DV edits to send acceleration and velocity
        if (history.length > 2) {
            var prevprevTouch = history[history.length - 3].touch;
            var accelX = (currTouch.pageX - 2 * prevTouch.pageX + prevprevTouch.pageX) / (diffTime * diffTime);
            var accelY = (currTouch.pageY - 2 * prevTouch.pageY + prevprevTouch.pageY) / (diffTime * diffTime);
        } else {
            var accelX = 0;
            var accelY = 0;
        }
        var prevPos = this.targetGet();
        var scale = this.options.scale;
        var nextPos;
        var nextVel;
        var nextAccel;
        if (this.options.direction == TouchSync.DIRECTION_X) {
            nextPos = prevPos + scale * diffX;
            nextVel = scale * velX;
            nextAccel = scale * velY;
        } else if (this.options.direction == TouchSync.DIRECTION_Y) {
            nextPos = prevPos + scale * diffY;
            nextVel = scale * velY;
            nextAccel = scale * accelY;
        } else {
            nextPos = [ prevPos[0] + scale * diffX, prevPos[1] + scale * diffY ];
            nextVel = [ scale * velX, scale * velY ];
            nextAccel = [ scale * accelX, scale * accelY ];
        }
        this.output.emit("update", {
            p: nextPos,
            v: nextVel,
            a: nextAccel,
            touch: data.touch.identifier
        });
    }
    function _handleEnd(data) {
        var nextVel = this.options.direction !== undefined ? 0 : [ 0, 0 ];
        var history = data.history;
        var count = data.count;
        var pos = this.targetGet();
        if (history.length > 1) {
            var prevTime = history[history.length - 2].timestamp;
            var currTime = history[history.length - 1].timestamp;
            var prevTouch = history[history.length - 2].touch;
            var currTouch = history[history.length - 1].touch;
            var diffX = currTouch.pageX - prevTouch.pageX;
            var diffY = currTouch.pageY - prevTouch.pageY;
            if (this.options.rails) {
                if (Math.abs(diffX) > Math.abs(diffY)) diffY = 0; else diffX = 0;
            }
            var diffTime = Math.max(currTime - prevTime, 1);
            // minimum tick time
            var velX = diffX / diffTime;
            var velY = diffY / diffTime;
            var scale = this.options.scale;
            var nextVel;
            if (this.options.direction == TouchSync.DIRECTION_X) nextVel = scale * velX; else if (this.options.direction == TouchSync.DIRECTION_Y) nextVel = scale * velY; else nextVel = [ scale * velX, scale * velY ];
        }
        this.output.emit("end", {
            p: pos,
            v: nextVel,
            count: count,
            touch: data.touch.identifier
        });
    }
    TouchSync.prototype.setOptions = function(options) {
        if (options.direction !== undefined) this.options.direction = options.direction;
        if (options.rails !== undefined) this.options.rails = options.rails;
        if (options.scale !== undefined) this.options.scale = options.scale;
    };
    TouchSync.prototype.getOptions = function() {
        return this.options;
    };
    module.exports = TouchSync;
}.bind(this));

require.register("app/custom/custom-input-sync/index.js", function(exports, require, module) {
    module.exports = {
        TouchSync: require("touch-sync"),
        MouseSync: require("mouse-sync")
    };
}.bind(this));

require.register("app/custom/custom-input-sync/mouse-sync.js", function(exports, require, module) {
    var EventHandler = require("famous/event-handler");
    /**
     * @class Handles piped in mouse drag events. Outputs an object with two
     *        properties, position and velocity.
     * @description
     * @name MouseSync
     * @constructor
     * @example
     * 
     *     var Engine = require('famous/Engine');
     *     var Surface = require('famous/Surface');
     *     var Modifier = require('famous/Modifier');
     *     var FM = require('famous/Matrix');
     *     var MouseSync = require('famous-sync/MouseSync');
     *     var Context = Engine.createContext();
     *
     *     var surface = new Surface({
     *         size: [200,200],
     *         properties: {
     *             backgroundColor: 'red'
     *         }
     *     });
     *
     *     var modifier = new Modifier({
     *         transform: undefined
     *     });
     *
     *     var position = 0;
     *     var sync = new MouseSync(function(){
     *         return position;
     *     }, {direction: MouseSync.DIRECTION_Y});  
     *
     *     surface.pipe(sync);
     *     sync.on('update', function(data) {
     *         var edge = window.innerHeight - (surface.getSize()[1])
     *         if (data.p > edge) {
     *             position = edge;
     *         } else if (data.p < 0) {
     *             position = 0;
     *         } else {
     *             position = data.p;
     *         }
     *         modifier.setTransform(FM.translate(0, position, 0));
     *         surface.setContent('position' + position + '<br>' + 'velocity' + data.v.toFixed(2));
     *     });
     *     Context.link(modifier).link(surface);
     * 
     */
    function MouseSync(targetGet, options) {
        this.targetGet = targetGet;
        this.options = {
            direction: undefined,
            rails: false,
            scale: 1,
            stallTime: 50,
            propogate: true
        };
        if (options) {
            this.setOptions(options);
        } else {
            this.setOptions(this.options);
        }
        this.input = new EventHandler();
        this.output = new EventHandler();
        EventHandler.setInputHandler(this, this.input);
        EventHandler.setOutputHandler(this, this.output);
        this._prevCoord = undefined;
        this._prevTime = undefined;
        this._prevVel = undefined;
        this.input.on("mousedown", _handleStart.bind(this));
        this.input.on("mousemove", _handleMove.bind(this));
        this.input.on("mouseup", _handleEnd.bind(this));
        this.options.propogate ? this.input.on("mouseleave", _handleLeave.bind(this)) : this.input.on("mouseleave", _handleEnd.bind(this));
    }
    /** @const */
    MouseSync.DIRECTION_X = 0;
    /** @const */
    MouseSync.DIRECTION_Y = 1;
    function _handleStart(e) {
        e.preventDefault();
        // prevent drag
        this._prevCoord = [ e.clientX, e.clientY ];
        this._prevTime = Date.now();
        this._prevVel = this.options.direction !== undefined ? 0 : [ 0, 0 ];
        this.output.emit("start", {
            ap: this._prevCoord
        });
    }
    function _handleMove(e) {
        if (!this._prevCoord) return;
        var prevCoord = this._prevCoord;
        var prevTime = this._prevTime;
        var currCoord = [ e.clientX, e.clientY ];
        var currTime = Date.now();
        var diffX = currCoord[0] - prevCoord[0];
        var diffY = currCoord[1] - prevCoord[1];
        if (this.options.rails) {
            if (Math.abs(diffX) > Math.abs(diffY)) diffY = 0; else diffX = 0;
        }
        var diffTime = Math.max(currTime - prevTime, 8);
        // minimum tick time
        var velX = diffX / diffTime;
        var velY = diffY / diffTime;
        var prevPos = this.targetGet();
        var scale = this.options.scale;
        var nextPos;
        var nextVel;
        if (this.options.direction == MouseSync.DIRECTION_X) {
            nextPos = prevPos + scale * diffX;
            nextVel = scale * velX;
        } else if (this.options.direction == MouseSync.DIRECTION_Y) {
            nextPos = prevPos + scale * diffY;
            nextVel = scale * velY;
        } else {
            nextPos = [ prevPos[0] + scale * diffX, prevPos[1] + scale * diffY ];
            nextVel = [ scale * velX, scale * velY ];
        }
        this.output.emit("update", {
            ap: currCoord,
            p: nextPos,
            v: nextVel
        });
        this._prevCoord = currCoord;
        this._prevTime = currTime;
        this._prevVel = nextVel;
    }
    function _handleEnd(e) {
        if (!this._prevCoord) return;
        var prevTime = this._prevTime;
        var currTime = Date.now();
        if (currTime - prevTime > this.options.stallTime) this._prevVel = this.options.direction == undefined ? [ 0, 0 ] : 0;
        var pos = this.targetGet();
        this.output.emit("end", {
            p: pos,
            v: this._prevVel
        });
        this._prevCoord = undefined;
        this._prevTime = undefined;
        this._prevVel = undefined;
    }
    function _handleLeave(e) {
        if (!this._prevCoord) return;
        var boundMove = function(e) {
            _handleMove.call(this, e);
        }.bind(this);
        var boundEnd = function(e) {
            _handleEnd.call(this, e);
            document.removeEventListener("mousemove", boundMove);
            document.removeEventListener("mouseup", boundEnd);
        }.bind(this);
        document.addEventListener("mousemove", boundMove);
        document.addEventListener("mouseup", boundEnd);
    }
    MouseSync.prototype.getOptions = function() {
        return this.options;
    };
    MouseSync.prototype.setOptions = function(options) {
        if (options.direction !== undefined) this.options.direction = options.direction;
        if (options.rails !== undefined) this.options.rails = options.rails;
        if (options.scale !== undefined) this.options.scale = options.scale;
        if (options.stallTime !== undefined) this.options.stallTime = options.stallTime;
        if (options.propogate !== undefined) this.options.propogate = options.propogate;
    };
    module.exports = MouseSync;
}.bind(this));

require.register("app/custom/custom-input-sync/touch-sync.js", function(exports, require, module) {
    var FTT = require("famous/input/touch-tracker");
    var FEH = require("famous/event-handler");
    function TouchSync(targetSync, options) {
        this.targetGet = targetSync;
        this.output = new FEH();
        this.touchTracker = new FTT();
        this.options = {
            direction: undefined,
            rails: false,
            scale: 1
        };
        if (options) {
            this.setOptions(options);
        } else {
            this.setOptions(this.options);
        }
        FEH.setOutputHandler(this, this.output);
        FEH.setInputHandler(this, this.touchTracker);
        this.touchTracker.on("trackstart", _handleStart.bind(this));
        this.touchTracker.on("trackmove", _handleMove.bind(this));
        this.touchTracker.on("trackend", _handleEnd.bind(this));
    }
    /** @const */
    TouchSync.DIRECTION_X = 0;
    /** @const */
    TouchSync.DIRECTION_Y = 1;
    function _handleStart(data) {
        this.output.emit("start", {
            ap: [ data.touch.clientX, data.touch.clientY ],
            count: data.count,
            touch: data.touch.identifier
        });
    }
    function _handleMove(data) {
        var history = data.history;
        var prevTime = history[history.length - 2].timestamp;
        var currTime = history[history.length - 1].timestamp;
        var prevTouch = history[history.length - 2].touch;
        var currTouch = history[history.length - 1].touch;
        var diffX = currTouch.pageX - prevTouch.pageX;
        var diffY = currTouch.pageY - prevTouch.pageY;
        if (this.options.rails) {
            if (Math.abs(diffX) > Math.abs(diffY)) diffY = 0; else diffX = 0;
        }
        var diffTime = Math.max(currTime - prevTime, 8);
        // minimum tick time
        var velX = diffX / diffTime;
        var velY = diffY / diffTime;
        //DV edits to send acceleration and velocity
        if (history.length > 2) {
            var prevprevTouch = history[history.length - 3].touch;
            var accelX = (currTouch.pageX - 2 * prevTouch.pageX + prevprevTouch.pageX) / (diffTime * diffTime);
            var accelY = (currTouch.pageY - 2 * prevTouch.pageY + prevprevTouch.pageY) / (diffTime * diffTime);
        } else {
            var accelX = 0;
            var accelY = 0;
        }
        var prevPos = this.targetGet();
        var scale = this.options.scale;
        var nextPos;
        var nextVel;
        var nextAccel;
        if (this.options.direction == TouchSync.DIRECTION_X) {
            nextPos = prevPos + scale * diffX;
            nextVel = scale * velX;
            nextAccel = scale * velY;
        } else if (this.options.direction == TouchSync.DIRECTION_Y) {
            nextPos = prevPos + scale * diffY;
            nextVel = scale * velY;
            nextAccel = scale * accelY;
        } else {
            nextPos = [ prevPos[0] + scale * diffX, prevPos[1] + scale * diffY ];
            nextVel = [ scale * velX, scale * velY ];
            nextAccel = [ scale * accelX, scale * accelY ];
        }
        this.output.emit("update", {
            ap: [ currTouch.pageX, currTouch.pageY ],
            p: nextPos,
            v: nextVel,
            a: nextAccel,
            touch: data.touch.identifier
        });
    }
    function _handleEnd(data) {
        var nextVel = this.options.direction !== undefined ? 0 : [ 0, 0 ];
        var history = data.history;
        var count = data.count;
        var pos = this.targetGet();
        if (history.length > 1) {
            var prevTime = history[history.length - 2].timestamp;
            var currTime = history[history.length - 1].timestamp;
            var prevTouch = history[history.length - 2].touch;
            var currTouch = history[history.length - 1].touch;
            var diffX = currTouch.pageX - prevTouch.pageX;
            var diffY = currTouch.pageY - prevTouch.pageY;
            if (this.options.rails) {
                if (Math.abs(diffX) > Math.abs(diffY)) diffY = 0; else diffX = 0;
            }
            var diffTime = Math.max(currTime - prevTime, 1);
            // minimum tick time
            var velX = diffX / diffTime;
            var velY = diffY / diffTime;
            var scale = this.options.scale;
            var nextVel;
            if (this.options.direction == TouchSync.DIRECTION_X) nextVel = scale * velX; else if (this.options.direction == TouchSync.DIRECTION_Y) nextVel = scale * velY; else nextVel = [ scale * velX, scale * velY ];
        }
        this.output.emit("end", {
            p: pos,
            v: nextVel,
            count: count,
            touch: data.touch.identifier
        });
    }
    TouchSync.prototype.setOptions = function(options) {
        if (options.direction !== undefined) this.options.direction = options.direction;
        if (options.rails !== undefined) this.options.rails = options.rails;
        if (options.scale !== undefined) this.options.scale = options.scale;
    };
    TouchSync.prototype.getOptions = function() {
        return this.options;
    };
    module.exports = TouchSync;
}.bind(this));

require.register("famous_modules/famous/input/scroll-sync/_git_master/index.js", function(exports, require, module) {
    var EventHandler = require("famous/event-handler");
    var Engine = require("famous/engine");
    /**
     * @class Handles piped in mousewheel events. Can be used as delegate of
     *        GenericSync.
     * @description
     * @name ScrollSync
     * @constructor
     * @example
     * 
     *     var Engine = require('famous/Engine');
     *     var Surface = require('famous/Surface');
     *     var Modifier = require('famous/Modifier');
     *     var FM = require('famous/Matrix');
     *     var ScrollSync = require('famous-sync/ScrollSync');
     *     var Context = Engine.createContext();
     *
     *     var surface = new Surface({
     *         size: [200,200],
     *         properties: {
     *             backgroundColor: 'red'
     *         }
     *     });
     *
     *     var modifier = new Modifier({
     *         transform: undefined
     *     });
     *
     *     var position = 0;
     *     var sync = new ScrollSync(function(){
     *         return position;
     *     }, {direction: ScrollSync.DIRECTION_Y});  
     *
     *     surface.pipe(sync);
     *     sync.on('update', function(data) {
     *         var edge = window.innerHeight - (surface.getSize()[1])
     *         if (data.p > edge) {
     *             position = edge;
     *         } else if (data.p < 0) {
     *             position = 0;
     *         } else {
     *             position = data.p;
     *         }
     *         modifier.setTransform(FM.translate(0, position, 0));
     *         surface.setContent('position' + position + '<br>' + 'velocity' + data.v.toFixed(2));
     *     });
     *     Context.link(modifier).link(surface);
     * 
     */
    function ScrollSync(targetSync, options) {
        this.targetGet = targetSync;
        this.options = {
            direction: undefined,
            minimumEndSpeed: Infinity,
            rails: false,
            scale: 1,
            stallTime: 50,
            lineHeight: 40
        };
        if (options) {
            this.setOptions(options);
        } else {
            this.setOptions(this.options);
        }
        this.input = new EventHandler();
        this.output = new EventHandler();
        EventHandler.setInputHandler(this, this.input);
        EventHandler.setOutputHandler(this, this.output);
        this._prevTime = undefined;
        this._prevVel = undefined;
        this.input.on("mousewheel", _handleMove.bind(this));
        this.input.on("wheel", _handleMove.bind(this));
        this.inProgress = false;
        this._loopBound = false;
    }
    /** @const */
    ScrollSync.DIRECTION_X = 0;
    /** @const */
    ScrollSync.DIRECTION_Y = 1;
    function _newFrame() {
        var now = Date.now();
        if (this.inProgress && now - this._prevTime > this.options.stallTime) {
            var pos = this.targetGet();
            this.inProgress = false;
            var finalVel = 0;
            if (Math.abs(this._prevVel) >= this.options.minimumEndSpeed) finalVel = this._prevVel;
            this.output.emit("end", {
                p: pos,
                v: finalVel,
                slip: true
            });
        }
    }
    function _handleMove(e) {
        e.preventDefault();
        if (!this.inProgress) {
            this.inProgress = true;
            this.output.emit("start", {
                slip: true
            });
            if (!this._loopBound) {
                Engine.on("prerender", _newFrame.bind(this));
                this._loopBound = true;
            }
        }
        var prevTime = this._prevTime;
        var diffX = e.wheelDeltaX !== undefined ? e.wheelDeltaX : -e.deltaX;
        var diffY = e.wheelDeltaY !== undefined ? e.wheelDeltaY : -e.deltaY;
        if (e.deltaMode === 1) {
            // units in lines, not pixels
            diffX *= this.options.lineHeight;
            diffY *= this.options.lineHeight;
        }
        var currTime = Date.now();
        if (this.options.rails) {
            if (Math.abs(diffX) > Math.abs(diffY)) diffY = 0; else diffX = 0;
        }
        var diffTime = Math.max(currTime - prevTime, 8);
        // minimum tick time
        var velX = diffX / diffTime;
        var velY = diffY / diffTime;
        var prevPos = this.targetGet();
        var scale = this.options.scale;
        var nextPos;
        var nextVel;
        if (this.options.direction == ScrollSync.DIRECTION_X) {
            nextPos = prevPos + scale * diffX;
            nextVel = scale * velX;
        } else if (this.options.direction == ScrollSync.DIRECTION_Y) {
            nextPos = prevPos + scale * diffY;
            nextVel = scale * velY;
        } else {
            nextPos = [ prevPos[0] + scale * diffX, prevPos[1] + scale * diffY ];
            nextVel = [ scale * velX, scale * velY ];
        }
        this.output.emit("update", {
            p: nextPos,
            v: nextVel,
            slip: true
        });
        this._prevTime = currTime;
        this._prevVel = nextVel;
    }
    ScrollSync.prototype.getOptions = function() {
        return this.options;
    };
    ScrollSync.prototype.setOptions = function(options) {
        if (options.direction !== undefined) this.options.direction = options.direction;
        if (options.minimumEndSpeed !== undefined) this.options.minimumEndSpeed = options.minimumEndSpeed;
        if (options.rails !== undefined) this.options.rails = options.rails;
        if (options.scale !== undefined) this.options.scale = options.scale;
        if (options.stallTime !== undefined) this.options.stallTime = options.stallTime;
    };
    module.exports = ScrollSync;
}.bind(this));

require.register("famous_modules/famous/input/generic-sync/_git_master/index.js", function(exports, require, module) {
    var EventHandler = require("famous/event-handler");
    var TouchSync = require("famous/input/touch-sync");
    var ScrollSync = require("famous/input/scroll-sync");
    /**
     * @class Combines multiple types of event handling (e.g. touch, trackpad 
     *     scrolling) into one standardized interface for inclusion in  
     *     widgets. TouchSync and ScrollSync are enabled by default.
     * @description
     * @name GenericSync
     * @constructor
     * @example 
     * 
     *     var Engine = require('famous/Engine');
     *     var Surface = require('famous/Surface');
     *     var Modifier = require('famous/Modifier');
     *     var FM = require('famous/Matrix');
     *     var GenericSync = require('famous-sync/GenericSync');
     *     var Context = Engine.createContext();
     *
     *     var surface = new Surface({
     *         size: [200,200],
     *         properties: {
     *             backgroundColor: 'red'
     *         }
     *     });
     *
     *     var modifier = new Modifier({
     *         transform: undefined
     *     });
     *
     *     var position = 0;
     *     var sync = new GenericSync(function(){
     *         return position;
     *     }, {direction: GenericSync.DIRECTION_Y});  
     *
     *     surface.pipe(sync);
     *     sync.on('update', function(data) {
     *         var edge = window.innerHeight - (surface.getSize()[1])
     *         if (data.p > edge) {
     *             position = edge;
     *         } else if (data.p < 0) {
     *             position = 0;
     *         } else {
     *             position = data.p;
     *         }
     *         modifier.setTransform(FM.translate(0, position, 0));
     *         surface.setContent('position' + position + '<br>' + 'velocity' + data.v.toFixed(2));
     *     });
     *     Context.link(modifier).link(surface);
     * 
     */
    function GenericSync(targetGet, options) {
        this.targetGet = targetGet;
        this.eventInput = new EventHandler();
        EventHandler.setInputHandler(this, this.eventInput);
        this.eventOutput = new EventHandler();
        EventHandler.setOutputHandler(this, this.eventOutput);
        this._handlers = undefined;
        this.options = {
            syncClasses: defaultClasses
        };
        this._handlerOptions = this.options;
        if (options) this.setOptions(options);
        if (!this._handlers) _updateHandlers.call(this);
    }
    var defaultClasses = [ TouchSync, ScrollSync ];
    GenericSync.register = function(syncClass) {
        if (defaultClasses.indexOf(syncClass) < 0) defaultClasses.push(syncClass);
    };
    /** @const */
    GenericSync.DIRECTION_X = 0;
    /** @const */
    GenericSync.DIRECTION_Y = 1;
    /** @const */
    GenericSync.DIRECTION_Z = 2;
    function _updateHandlers() {
        if (this._handlers) {
            for (var i = 0; i < this._handlers.length; i++) {
                this.eventInput.unpipe(this._handlers[i]);
                this._handlers[i].unpipe(this.eventOutput);
            }
        }
        this._handlers = [];
        for (var i = 0; i < this.options.syncClasses.length; i++) {
            var _SyncClass = this.options.syncClasses[i];
            this._handlers[i] = new _SyncClass(this.targetGet, this._handlerOptions);
            this.eventInput.pipe(this._handlers[i]);
            this._handlers[i].pipe(this.eventOutput);
        }
    }
    GenericSync.prototype.setOptions = function(options) {
        this._handlerOptions = options;
        if (options.syncClasses) {
            this.options.syncClasses = options.syncClasses;
            _updateHandlers.call(this);
        }
        if (this._handlers) {
            for (var i = 0; i < this._handlers.length; i++) {
                this._handlers[i].setOptions(this._handlerOptions);
            }
        }
    };
    module.exports = GenericSync;
}.bind(this));

require.register("famous_modules/famous/math/vector/_git_master/index.js", function(exports, require, module) {
    /**
     * @class An immutable three-element floating point vector.
     *
     * @description Note that if not using the "out" parameter,
     *    then funtions return a common reference to an internal register.
     *
     * * Class/Namespace TODOs:
     *   * Are there any vector STANDARDS in JS that we can use instead of our own library?
     *   * Is it confusing that this is immutable?
     *   * All rotations are counter-clockwise in a right-hand system.  Need to doc this
     *     somewhere since Famous render engine's rotations are left-handed (clockwise)
     *
     * Constructor: Take three elts or an array and make new vec.
     *
     * @name Vector
     * @constructor
     */
    function Vector(x, y, z) {
        if (arguments.length === 1) this.set(x); else {
            this.x = x || 0;
            this.y = y || 0;
            this.z = z || 0;
        }
        return this;
    }
    var register = new Vector(0, 0, 0);
    /**
     * Add to another Vector, element-wise.
     *
     * @name Vector#add
     * @function
     * @returns {Vector}
     */
    Vector.prototype.add = function(v) {
        return register.setXYZ(this.x + (v.x || 0), this.y + (v.y || 0), this.z + (v.z || 0));
    };
    /**
     * Subtract from another Vector, element-wise.
     *
     * @name Vector#sub
     * @function
     * @returns {Vector}
     */
    Vector.prototype.sub = function(v) {
        return register.setXYZ(this.x - v.x, this.y - v.y, this.z - v.z);
    };
    /**
     * Scale Vector by floating point r.
     *
     * @name Vector#mult
     * @function
     * @returns {number}
     */
    Vector.prototype.mult = function(r) {
        return register.setXYZ(r * this.x, r * this.y, r * this.z);
    };
    /**
     * Scale Vector by floating point 1/r.
     *
     * @name Vector#div
     * @function
     * @returns {number}
     */
    Vector.prototype.div = function(r) {
        return this.mult(1 / r);
    };
    /**
     * Return cross product with another Vector (LHC)
     *
     * @name Vector#cross
     * @function
     * @returns {Vector}
     */
    Vector.prototype.cross = function(v) {
        var x = this.x, y = this.y, z = this.z;
        var vx = v.x, vy = v.y, vz = v.z;
        return register.setXYZ(z * vy - y * vz, x * vz - z * vx, y * vx - x * vy);
    };
    /**
     * Component-wise equality test between this and Vector v.
     * @name Vector#equals
     * @function
     * @returns {boolean}
     */
    Vector.prototype.equals = function(v) {
        return v.x == this.x && v.y == this.y && v.z == this.z;
    };
    /**
     * Rotate clockwise around x-axis by theta degrees.
     *
     * @name Vector#rotateX
     * @function
     * @returns {Vector}
     */
    Vector.prototype.rotateX = function(theta) {
        var x = this.x;
        var y = this.y;
        var z = this.z;
        var cosTheta = Math.cos(theta);
        var sinTheta = Math.sin(theta);
        return register.setXYZ(x, y * cosTheta - z * sinTheta, y * sinTheta + z * cosTheta);
    };
    /**
     * Rotate clockwise around y-axis by theta degrees.
     *
     * @name Vector#rotateY
     * @function
     * @returns {Vector}
     */
    Vector.prototype.rotateY = function(theta, out) {
        out = out || register;
        var x = this.x;
        var y = this.y;
        var z = this.z;
        var cosTheta = Math.cos(theta);
        var sinTheta = Math.sin(theta);
        return out.setXYZ(z * sinTheta + x * cosTheta, y, z * cosTheta - x * sinTheta);
    };
    /**
     * Rotate clockwise around z-axis by theta degrees.
     *
     * @name Vector#rotateZ
     * @function
     * @returns {Vector}
     */
    Vector.prototype.rotateZ = function(theta) {
        var x = this.x;
        var y = this.y;
        var z = this.z;
        var cosTheta = Math.cos(theta);
        var sinTheta = Math.sin(theta);
        return register.setXYZ(x * cosTheta - y * sinTheta, x * sinTheta + y * cosTheta, z);
    };
    /**
     * Take dot product of this with a second Vector
     *
     * @name Vector#dot
     * @function
     * @returns {number}
     */
    Vector.prototype.dot = function(v) {
        return this.x * v.x + this.y * v.y + this.z * v.z;
    };
    /**
     * Take dot product of this with a this Vector
     *
     * @name Vector#normSquared
     * @function
     * @returns {number}
     */
    Vector.prototype.normSquared = function() {
        return this.dot(this);
    };
    /**
     * Find Euclidean length of the Vector.
     *
     * @name Vector#norm
     * @function
     * @returns {number}
     */
    Vector.prototype.norm = function() {
        return Math.sqrt(this.normSquared());
    };
    /**
     * Scale Vector to specified length.
     * If length is less than internal tolerance, set vector to [length, 0, 0].
     *
     * * TODOs:
     *    * There looks to be a bug or unexplained behavior in here.  Why would
     *      we defer to a multiple of e_x for being below tolerance?
     *
     * @name Vector#normalize
     * @function
     * @returns {Vector}
     */
    Vector.prototype.normalize = function(length) {
        length = length !== undefined ? length : 1;
        var tolerance = 1e-7;
        var norm = this.norm();
        if (Math.abs(norm) > tolerance) return register.set(this.mult(length / norm)); else return register.setXYZ(length, 0, 0);
    };
    /**
     * Make a separate copy of the Vector.
     *
     * @name Vector#clone
     * @function
     * @returns {Vector}
     */
    Vector.prototype.clone = function() {
        return new Vector(this);
    };
    /**
     * True if and only if every value is 0 (or falsy)
     *
     * @name Vector#isZero
     * @function
     * @returns {boolean}
     */
    Vector.prototype.isZero = function() {
        return !(this.x || this.y || this.z);
    };
    Vector.prototype.setFromArray = function(v) {
        this.x = v[0];
        this.y = v[1];
        this.z = v[2] || 0;
        return this;
    };
    /**
     * Set this Vector to the values in the provided Array or Vector.
     *
     * TODO: set from Array disambiguation
     *
     * @name Vector#set
     * @function
     * @returns {Vector}
     */
    Vector.prototype.set = function(v) {
        if (v instanceof Array) {
            this.setFromArray(v);
        }
        if (v instanceof Vector) {
            this.x = v.x;
            this.y = v.y;
            this.z = v.z;
        }
        if (typeof v == "number") {
            this.x = v;
            this.y = 0;
            this.z = 0;
        }
        if (this !== register) register.clear();
        return this;
    };
    /**
     * Put result of last internal calculation in
     *   specified output vector.
     *
     * @name Vector#put
     * @function
     * @returns {Vector}
     */
    Vector.prototype.put = function(v) {
        v.set(register);
    };
    /**
     * Set elements directly and clear internal register.
     *   This is the a "mutating" method on this Vector.
     *
     *
     * @name Vector#setXYZ
     * @function
     */
    Vector.prototype.setXYZ = function(x, y, z) {
        register.clear();
        this.x = x;
        this.y = y;
        this.z = z;
        return this;
    };
    /**
     * Set elements to 0.
     *
     * @name Vector#clear
     * @function
     */
    Vector.prototype.clear = function() {
        this.x = 0;
        this.y = 0;
        this.z = 0;
    };
    /**
     * Scale this Vector down to specified "cap" length.
     * If Vector shorter than cap, or cap is Infinity, do nothing.
     *
     *
     * @name Vector#cap
     * @function
     * @returns {Vector}
     */
    Vector.prototype.cap = function(cap) {
        if (cap === Infinity) return register.set(this);
        var norm = this.norm();
        if (norm > cap) return register.set(this.mult(cap / norm)); else return register.set(this);
    };
    /**
     * Return projection of this Vector onto another.
     *
     * @name Vector#project
     * @function
     * @returns {Vector}
     */
    Vector.prototype.project = function(n) {
        return n.mult(this.dot(n));
    };
    /**
     * Reflect this Vector across provided vector.
     *
     * @name Vector#reflect
     * @function
     */
    Vector.prototype.reflectAcross = function(n) {
        n.set(n.normalize());
        return register.set(this.sub(this.project(n).mult(2)));
    };
    /**
     * Convert Vector to three-element array.
     *
     * * TODOs:
     *   * Why do we have this and get()?
     *
     * @name Vector#toArray
     * @function
     */
    Vector.prototype.toArray = function() {
        return [ this.x, this.y, this.z ];
    };
    /**
     * Convert Vector to three-element array.
     *
     * * TODOs:
     *   * Why do we have this and toArray()?
     *
     * @name Vector#get
     * @function
     */
    Vector.prototype.get = function() {
        return this.toArray();
    };
    module.exports = Vector;
}.bind(this));

require.register("famous_modules/famous/physics/bodies/particle/_git_master/index.js", function(exports, require, module) {
    var RenderNode = require("famous/render-node");
    var Vector = require("famous/math/vector");
    var Matrix = require("famous/transform");
    /**
     *
     * @class A unit controlled by the physics engine which serves to provide position. 
     *
     * @description This is essentially the state object for the a particle's
     *    fundamental properties of position, velocity, acceleration, and force,
     *    which makes its position available through the render() function.
     *    Legal opts: (p)osition, (v)elocity, (a)cceleration, (f)orce, (m)ass,
     *       restitution, and dissipation.
     * 
     *
     * * Class/Namespace TODOs
     *
     * @name Particle
     * @constructor
     */
    function Particle(opts) {
        opts = opts || {};
        this.p = opts.p ? new Vector(opts.p) : new Vector(0, 0, 0);
        this.v = opts.v ? new Vector(opts.v) : new Vector(0, 0, 0);
        this.f = opts.f ? new Vector(opts.f) : new Vector(0, 0, 0);
        //scalars
        this.m = opts.m !== undefined ? opts.m : 1;
        //mass
        this.restitution = opts.restitution !== undefined ? opts.restitution : .5;
        //collision damping
        this.dissipation = opts.dissipation !== undefined ? opts.dissipation : 0;
        //velocity damping
        this.axis = opts.axis !== undefined ? opts.axis : undefined;
        //TODO: find better solution
        this.setImmunity(opts.immunity || Particle.IMMUNITIES.NONE);
        this.mInv = 1 / this.m;
        this.size = [ 0, 0, 0 ];
        //bounding box
        this.node = undefined;
        this.spec = {
            size: [ false, false ],
            target: {
                origin: [ .5, .5 ],
                transform: undefined,
                target: undefined
            }
        };
    }
    Particle.AXIS = {
        X: 1,
        Y: 2,
        Z: 4
    };
    Particle.IMMUNITIES = {
        NONE: 0,
        POSITION: 1,
        VELOCITY: 2,
        ROTATION: 4,
        AGENTS: 8,
        UPDATE: 16
    };
    for (var key in Particle.IMMUNITIES) Particle.IMMUNITIES.ALL |= Particle.IMMUNITIES[key];
    /**
     * Basic setter function for position Vector  
     * @name Particle#setPos
     * @function
     */
    Particle.prototype.setPos = function(p) {
        this.p.set(p);
    };
    /**
     * Basic getter function for position Vector 
     * @name Particle#getPos
     * @function
     */
    Particle.prototype.getPos = function() {
        return this.p.get();
    };
    /**
     * Basic setter function for velocity Vector 
     * @name Particle#setVel
     * @function
     */
    Particle.prototype.setVel = function(v) {
        if (this.hasImmunity(Particle.IMMUNITIES.VELOCITY)) return;
        this.v.set(v);
    };
    /**
     * Basic getter function for velocity Vector 
     * @name Particle#getVel
     * @function
     */
    Particle.prototype.getVel = function() {
        return this.v.get();
    };
    /**
     * Basic setter function for mass quantity 
     * @name Particle#setMass
     * @function
     */
    Particle.prototype.setMass = function(m) {
        this.m = m;
        this.mInv = 1 / m;
    };
    /**
     * Basic getter function for mass quantity 
     * @name Particle#getMass
     * @function
     */
    Particle.prototype.getMass = function() {
        return this.m;
    };
    Particle.prototype.addImmunity = function(immunity) {
        if (typeof immunity == "string") immunity = Particle.IMMUNITIES[immunity.toUpperCase()];
        this.immunity |= immunity;
    };
    Particle.prototype.removeImmunity = function(immunity) {
        if (typeof immunity == "string") immunity = Particle.IMMUNITIES[immunity.toUpperCase()];
        this.immunity &= ~immunity;
    };
    Particle.prototype.setImmunity = function(immunity) {
        if (typeof immunity == "string") immunity = Particle.IMMUNITIES[immunity.toUpperCase()];
        this.immunity = immunity;
    };
    Particle.prototype.hasImmunity = function(immunity) {
        if (typeof immunity == "string") immunity = Particle.IMMUNITIES[immunity.toUpperCase()];
        return this.getImmunity() & immunity;
    };
    /**
     * Basic getter function for immunity
     * @name Particle#getImmunity
     * @function
     */
    Particle.prototype.getImmunity = function() {
        return this.immunity;
    };
    /**
     * Set position, velocity, force, and accel Vectors each to (0, 0, 0)
     * @name Particle#reset
     * @function
     */
    Particle.prototype.reset = function(p, v) {
        p = p || [ 0, 0, 0 ];
        v = v || [ 0, 0, 0 ];
        this.setPos(p);
        this.setVel(v);
    };
    /**
     * Add force Vector to existing internal force Vector
     * @name Particle#applyForce
     * @function
     */
    Particle.prototype.applyForce = function(force) {
        if (this.hasImmunity(Particle.IMMUNITIES.AGENTS)) return;
        this.f.set(this.f.add(force));
    };
    /**
     * Add impulse (force*time) Vector to this Vector's velocity. 
     * @name Particle#applyImpulse
     * @function
     */
    Particle.prototype.applyImpulse = function(impulse) {
        if (this.hasImmunity(Particle.IMMUNITIES.AGENTS)) return;
        this.setVel(this.v.add(impulse.mult(this.mInv)));
    };
    /**
     * Get kinetic energy of the particle.
     * @name Particle#getEnergy
     * @function
     */
    Particle.prototype.getEnergy = function() {
        return .5 * this.m * this.v.normSquared();
    };
    /**
     * Generate current positional transform from position (calculated)
     *   and rotation (provided only at construction time)
     * @name Particle#getTransform
     * @function
     */
    Particle.prototype.getTransform = function() {
        var p = this.p;
        var axis = this.axis;
        if (axis !== undefined) {
            if (axis & ~Particle.AXIS.X) {
                p.x = 0;
            }
            if (axis & ~Particle.AXIS.Y) {
                p.y = 0;
            }
            if (axis & ~Particle.AXIS.Z) {
                p.z = 0;
            }
        }
        return Matrix.translate(p.x, p.y, p.z);
    };
    /**
     * Declare that this Particle's position will affect the provided node
     *    in the render tree.
     * 
     * @name Particle#link
     * @function
     *    
     * @returns {FamousRenderNode} a new render node for the provided
     *    renderableComponent.
     */
    Particle.prototype.link = function(obj) {
        if (!this.node) this.node = new RenderNode();
        return this.node.link(obj);
    };
    Particle.prototype.add = function(obj) {
        if (!this.node) this.node = new RenderNode();
        return this.node.add(obj);
    };
    Particle.prototype.replace = function(obj) {
        this.node.object = obj;
    };
    /**
     * Return {@link renderSpec} of this particle.  This will render the render tree
     *   attached via #from and adjusted by the particle's caluculated position
     *
     * @name Particle#render
     * @function
     */
    Particle.prototype.render = function(target) {
        target = target !== undefined ? target : this.node.render();
        this.spec.target.transform = this.getTransform();
        this.spec.target.target = target;
        return this.spec;
    };
    module.exports = Particle;
}.bind(this));

require.register("famous_modules/famous/physics/forces/force/_git_master/index.js", function(exports, require, module) {
    var Vector = require("famous/math/vector");
    /** @constructor */
    function Force() {
        this.force = new Vector();
    }
    Force.prototype.setOpts = function(opts) {
        for (var key in opts) this.opts[key] = opts[key];
    };
    Force.prototype.applyConstraint = function() {};
    Force.prototype.setupSlider = function(slider, property) {
        property = property || slider.opts.name;
        slider.setOpts({
            value: this.opts[property]
        });
        if (slider.init) slider.init();
        slider.on("change", function(data) {
            this.opts[property] = data.value;
        }.bind(this));
    };
    Force.prototype.getEnergy = function() {
        return 0;
    };
    module.exports = Force;
}.bind(this));

require.register("famous_modules/famous/physics/forces/drag/_git_master/index.js", function(exports, require, module) {
    var Force = require("famous/physics/forces/force");
    /** @constructor */
    function Drag(opts) {
        this.opts = {
            strength: .01,
            forceFunction: Drag.FORCE_FUNCTIONS.LINEAR
        };
        if (opts) this.setOpts(opts);
        Force.call(this);
    }
    Drag.prototype = Object.create(Force.prototype);
    Drag.prototype.constructor = Force;
    Drag.FORCE_FUNCTIONS = {
        LINEAR: function(v) {
            return v;
        },
        QUADRATIC: function(v) {
            return v.mult(v.norm());
        }
    };
    Drag.prototype.applyForce = function(particles) {
        var strength = this.opts.strength;
        var forceFunction = this.opts.forceFunction;
        var force = this.force;
        for (var index = 0; index < particles.length; index++) {
            var particle = particles[index];
            forceFunction(particle.v).mult(-strength).put(force);
            particle.applyForce(force);
        }
    };
    Drag.prototype.setOpts = function(opts) {
        for (var key in opts) this.opts[key] = opts[key];
    };
    module.exports = Drag;
}.bind(this));

require.register("famous_modules/famous/physics/forces/spring/_git_master/index.js", function(exports, require, module) {
    var Force = require("famous/physics/forces/force");
    var Vector = require("famous/math/vector");
    var EventHandler = require("famous/event-handler");
    /** @constructor */
    function Spring(opts) {
        this.opts = {
            period: 300,
            dampingRatio: .1,
            length: 0,
            lMin: 0,
            lMax: Infinity,
            anchor: undefined,
            forceFunction: Spring.FORCE_FUNCTIONS.HOOK,
            restTolerance: 1e-5
        };
        if (opts) this.setOpts(opts);
        this.eventOutput = undefined;
        this._atRest = false;
        this.init();
        Force.call(this);
        //registers
        this.disp = new Vector(0, 0, 0);
    }
    Spring.prototype = Object.create(Force.prototype);
    Spring.prototype.constructor = Force;
    Spring.FORCE_FUNCTIONS = {
        FENE: function(dist, rMax) {
            var rMaxSmall = rMax * .99;
            var r = Math.max(Math.min(dist, rMaxSmall), -rMaxSmall);
            return r / (1 - r * r / (rMax * rMax));
        },
        HOOK: function(dist) {
            return dist;
        }
    };
    function setForceFunction(fn) {
        this.forceFunction = fn;
    }
    function calcStiffness() {
        var opts = this.opts;
        opts.stiffness = Math.pow(2 * Math.PI / opts.period, 2);
    }
    function calcDamping() {
        var opts = this.opts;
        opts.damping = 4 * Math.PI * opts.dampingRatio / opts.period;
    }
    function getEnergy(strength, dist) {
        return .5 * strength * dist * dist;
    }
    Spring.prototype.init = function() {
        setForceFunction.call(this, this.opts.forceFunction);
        calcStiffness.call(this);
        calcDamping.call(this);
    };
    Spring.prototype.applyForce = function(targets, source) {
        var force = this.force;
        var disp = this.disp;
        var opts = this.opts;
        var stiffness = opts.stiffness;
        var damping = opts.damping;
        var restLength = opts.length;
        var lMax = opts.lMax;
        var anchor = opts.anchor || source.p;
        for (var i = 0; i < targets.length; i++) {
            var target = targets[i];
            disp.set(anchor.sub(target.p));
            var dist = disp.norm() - restLength;
            if (dist == 0) return;
            //if dampingRatio specified, then override strength and damping
            var m = target.m;
            stiffness *= m;
            damping *= m;
            force.set(disp.normalize(stiffness * this.forceFunction(dist, lMax)));
            if (damping) if (source) force.set(force.add(target.v.sub(source.v).mult(-damping))); else force.set(force.add(target.v.mult(-damping)));
            target.applyForce(force);
            if (source) source.applyForce(force.mult(-1));
            if (this.eventOutput) {
                var energy = target.getEnergy() + getEnergy(stiffness, dist);
                _fireAtRest.call(this, energy, target);
            }
        }
    };
    function _fireAtRest(energy, target) {
        if (energy < this.opts.restTolerance) {
            if (!this._atRest) this.eventOutput.emit("atRest", {
                particle: target
            });
            this._atRest = true;
        } else this._atRest = false;
    }
    Spring.prototype.getEnergy = function(target, source) {
        var opts = this.opts;
        var restLength = opts.length, anchor = opts.anchor || source.p, strength = opts.stiffness;
        var dist = anchor.sub(target.p).norm() - restLength;
        return .5 * strength * dist * dist;
    };
    Spring.prototype.setOpts = function(opts) {
        if (opts.anchor !== undefined) {
            if (opts.anchor.p instanceof Vector) this.opts.anchor = opts.anchor.p;
            if (opts.anchor instanceof Vector) this.opts.anchor = opts.anchor;
            if (opts.anchor instanceof Array) this.opts.anchor = new Vector(opts.anchor);
        }
        if (opts.period !== undefined) this.opts.period = opts.period;
        if (opts.dampingRatio !== undefined) this.opts.dampingRatio = opts.dampingRatio;
        if (opts.length !== undefined) this.opts.length = opts.length;
        if (opts.lMin !== undefined) this.opts.lMin = opts.lMin;
        if (opts.lMax !== undefined) this.opts.lMax = opts.lMax;
        if (opts.forceFunction !== undefined) this.opts.forceFunction = opts.forceFunction;
        if (opts.restTolerance !== undefined) this.opts.restTolerance = opts.restTolerance;
        this.init();
    };
    Spring.prototype.setAnchor = function(anchor) {
        if (this.opts.anchor === undefined) this.opts.anchor = new Vector();
        this.opts.anchor.set(anchor);
    };
    function _createEventOutput() {
        this.eventOutput = new EventHandler();
        this.eventOutput.bindThis(this);
        EventHandler.setOutputHandler(this, this.eventOutput);
    }
    Spring.prototype.on = function() {
        _createEventOutput.call(this);
        return this.on.apply(this, arguments);
    };
    Spring.prototype.unbind = function() {
        _createEventOutput.call(this);
        return this.unbind.apply(this, arguments);
    };
    Spring.prototype.pipe = function() {
        _createEventOutput.call(this);
        return this.pipe.apply(this, arguments);
    };
    Spring.prototype.unpipe = function() {
        _createEventOutput.call(this);
        return this.unpipe.apply(this, arguments);
    };
    module.exports = Spring;
}.bind(this));

require.register("famous_modules/famous/physics/constraints/constraint/_git_master/index.js", function(exports, require, module) {
    /** @constructor */
    function Constraint() {}
    Constraint.prototype.setOpts = function(opts) {
        for (var key in opts) this.opts[key] = opts[key];
    };
    Constraint.prototype.applyConstraint = function() {};
    Constraint.prototype.setupSlider = function(slider, property) {
        property = property || slider.opts.name;
        slider.setOpts({
            value: this.opts[property]
        });
        if (slider.init) slider.init();
        slider.on("change", function(data) {
            this.opts[property] = data.value;
        }.bind(this));
    };
    module.exports = Constraint;
}.bind(this));

require.register("famous_modules/famous/physics/integrator/symplectic-euler/_git_master/index.js", function(exports, require, module) {
    /** @constructor */
    function SymplecticEuler(opts) {
        this.opts = {
            velocityCap: Infinity,
            angularVelocityCap: Infinity
        };
        if (opts) this.setOpts(opts);
    }
    SymplecticEuler.prototype.integrateVelocity = function(particle, dt) {
        var v = particle.v, m = particle.m, f = particle.f;
        if (f.isZero()) return;
        particle.setVel(v.add(f.mult(dt / m)));
        f.clear();
    };
    SymplecticEuler.prototype.integratePosition = function(particle, dt) {
        var p = particle.p, v = particle.v;
        if (v.isZero()) return;
        v.set(v.cap(this.opts.velocityCap));
        particle.setPos(p.add(v.mult(dt)));
    };
    SymplecticEuler.prototype.integrateAngularMomentum = function(particle, dt) {
        var L = particle.L, t = particle.t;
        if (t.isZero()) return;
        t.set(t.cap(this.opts.angularVelocityCap));
        L.add(t.mult(dt)).put(L);
        t.clear();
    };
    SymplecticEuler.prototype.integrateOrientation = function(particle, dt) {
        var q = particle.q, w = particle.w;
        if (w.isZero()) return;
        q.set(q.add(q.multiply(w).scalarMultiply(.5 * dt)));
        q.set(q.normalize());
    };
    SymplecticEuler.prototype.setOpts = function(opts) {
        for (var key in opts) this.opts[key] = opts[key];
    };
    module.exports = SymplecticEuler;
}.bind(this));

require.register("famous_modules/famous/math/quaternion/_git_master/index.js", function(exports, require, module) {
    /**
     * @constructor
     */
    function Quaternion(w, x, y, z) {
        if (arguments.length === 1) this.set(w); else {
            this.w = w !== undefined ? w : 1;
            //Angle
            this.x = x !== undefined ? x : 0;
            //Axis.x
            this.y = y !== undefined ? y : 0;
            //Axis.y
            this.z = z !== undefined ? z : 0;
        }
        return this;
    }
    var register = new Quaternion(1, 0, 0, 0);
    Quaternion.prototype.add = function(q) {
        return register.setWXYZ(this.w + q.w, this.x + q.x, this.y + q.y, this.z + q.z);
    };
    Quaternion.prototype.sub = function(q) {
        return register.setWXYZ(this.w - q.w, this.x - q.x, this.y - q.y, this.z - q.z);
    };
    Quaternion.prototype.scalarDivide = function(s) {
        return this.scalarMultiply(1 / s);
    };
    Quaternion.prototype.scalarMultiply = function(s) {
        return register.setWXYZ(this.w * s, this.x * s, this.y * s, this.z * s);
    };
    Quaternion.prototype.multiply = function(q) {
        //left-handed coordinate system multiplication
        var x1 = this.x, y1 = this.y, z1 = this.z, w1 = this.w;
        var x2 = q.x, y2 = q.y, z2 = q.z, w2 = q.w || 0;
        return register.setWXYZ(w1 * w2 - x1 * x2 - y1 * y2 - z1 * z2, x1 * w2 + x2 * w1 + y2 * z1 - y1 * z2, y1 * w2 + y2 * w1 + x1 * z2 - x2 * z1, z1 * w2 + z2 * w1 + x2 * y1 - x1 * y2);
    };
    var conj = new Quaternion(1, 0, 0, 0);
    Quaternion.prototype.rotateVector = function(v) {
        conj.set(this.conj());
        return register.set(this.multiply(v).multiply(conj));
    };
    Quaternion.prototype.inverse = function() {
        return register.set(this.conj().scalarDivide(this.normSquared()));
    };
    Quaternion.prototype.negate = function() {
        return this.scalarMultiply(-1);
    };
    Quaternion.prototype.conj = function() {
        return register.setWXYZ(this.w, -this.x, -this.y, -this.z);
    };
    Quaternion.prototype.normalize = function(length) {
        length = length === undefined ? 1 : length;
        return this.scalarDivide(length * this.norm());
    };
    Quaternion.prototype.makeFromAngleAndAxis = function(angle, v) {
        //left handed quaternion creation: theta -> -theta
        var n = v.normalize();
        var ha = angle * .5;
        var s = -Math.sin(ha);
        this.x = s * n.x;
        this.y = s * n.y;
        this.z = s * n.z;
        this.w = Math.cos(ha);
        return this;
    };
    Quaternion.prototype.setWXYZ = function(w, x, y, z) {
        register.clear();
        this.w = w;
        this.x = x;
        this.y = y;
        this.z = z;
        return this;
    };
    Quaternion.prototype.set = function(v) {
        if (v instanceof Array) {
            this.w = v[0];
            this.x = v[1];
            this.y = v[2];
            this.z = v[3];
        } else {
            this.w = v.w;
            this.x = v.x;
            this.y = v.y;
            this.z = v.z;
        }
        if (this !== register) register.clear();
        return this;
    };
    Quaternion.prototype.put = function(q) {
        q.set(register);
    };
    Quaternion.prototype.clone = function() {
        return new Quaternion(this);
    };
    Quaternion.prototype.clear = function() {
        this.w = 1;
        this.x = 0;
        this.y = 0;
        this.z = 0;
        return this;
    };
    Quaternion.prototype.isEqual = function(q) {
        return q.w == this.w && q.x == this.x && q.y == this.y && q.z == this.z;
    };
    Quaternion.prototype.dot = function(q) {
        return this.w * q.w + this.x * q.x + this.y * q.y + this.z * q.z;
    };
    Quaternion.prototype.normSquared = function() {
        return this.dot(this);
    };
    Quaternion.prototype.norm = function() {
        return Math.sqrt(this.normSquared());
    };
    Quaternion.prototype.isZero = function() {
        return !(this.x || this.y || this.z);
    };
    Quaternion.prototype.getMatrix = function() {
        var temp = this.normalize(1);
        var x = temp.x, y = temp.y, z = temp.z, w = temp.w;
        //LHC system flattened to column major = RHC flattened to row major
        return [ 1 - 2 * y * y - 2 * z * z, 2 * x * y - 2 * z * w, 2 * x * z + 2 * y * w, 0, 2 * x * y + 2 * z * w, 1 - 2 * x * x - 2 * z * z, 2 * y * z - 2 * x * w, 0, 2 * x * z - 2 * y * w, 2 * y * z + 2 * x * w, 1 - 2 * x * x - 2 * y * y, 0, 0, 0, 0, 1 ];
    };
    Quaternion.prototype.getMatrix3x3 = function() {
        var temp = this.normalize(1);
        var x = temp.x, y = temp.y, z = temp.z, w = temp.w;
        //LHC system flattened to row major
        return [ [ 1 - 2 * y * y - 2 * z * z, 2 * x * y + 2 * z * w, 2 * x * z - 2 * y * w ], [ 2 * x * y - 2 * z * w, 1 - 2 * x * x - 2 * z * z, 2 * y * z + 2 * x * w ], [ 2 * x * z + 2 * y * w, 2 * y * z - 2 * x * w, 1 - 2 * x * x - 2 * y * y ] ];
    };
    var epsilon = 1e-5;
    Quaternion.prototype.slerp = function(q, t) {
        var omega, cosomega, sinomega, scaleFrom, scaleTo;
        cosomega = this.dot(q);
        if (1 - cosomega > epsilon) {
            omega = Math.acos(cosomega);
            sinomega = Math.sin(omega);
            scaleFrom = Math.sin((1 - t) * omega) / sinomega;
            scaleTo = Math.sin(t * omega) / sinomega;
        } else {
            scaleFrom = 1 - t;
            scaleTo = t;
        }
        return register.set(this.scalarMultiply(scaleFrom / scaleTo).add(q).multiply(scaleTo));
    };
    module.exports = Quaternion;
}.bind(this));

require.register("famous_modules/famous/physics/bodies/body/_git_master/index.js", function(exports, require, module) {
    var Particle = require("famous/physics/bodies/particle");
    var Vector = require("famous/math/vector");
    var Quaternion = require("famous/math/quaternion");
    var Transform = require("famous/transform");
    function Body(opts) {
        Particle.call(this, opts);
        this.q = opts.q ? new Quaternion(opts.q) : new Quaternion();
        //orientation
        this.w = opts.w ? new Vector(opts.w) : new Vector();
        //angular velocity
        this.L = opts.L ? new Vector(opts.L) : new Vector();
        //angular momentum
        this.t = opts.t ? new Vector(opts.t) : new Vector();
        //torque
        this.I = [ 1, 0, 0, 1, 0, 0, 1, 0, 0 ];
        //inertia tensor
        this.Iinv = [ 1, 0, 0, 1, 0, 0, 1, 0, 0 ];
        //inverse inertia tensor
        this.w.w = 0;
        //quaternify the angular velocity
        //register
        this.pWorld = new Vector();
    }
    Body.prototype = Object.create(Particle.prototype);
    Body.prototype.constructor = Body;
    Body.IMMUNITIES = Particle.IMMUNITIES;
    Body.prototype.updateAngularVelocity = function() {
        var Iinv = this.Iinv;
        var L = this.L;
        var Lx = L.x, Ly = L.y, Lz = L.z;
        var I0 = Iinv[0], I1 = Iinv[1], I2 = Iinv[2];
        this.w.setXYZ(I0[0] * Lx + I0[1] * Ly + I0[2] * Lz, I1[0] * Lx + I1[1] * Ly + I1[2] * Lz, I2[0] * Lx + I2[1] * Ly + I2[2] * Lz);
    };
    Body.prototype.toWorldCoordinates = function(localPosition) {
        var q = this.q;
        localPosition.w = 0;
        return this.pWorld.set(q.inverse().multiply(localPosition).multiply(q));
    };
    Body.prototype.getEnergy = function() {
        var w = this.w;
        var I = this.I;
        var wx = w.x, wy = w.y, wz = w.z;
        var I0 = this.I[0], I1 = I[1], I2 = I[2];
        return .5 * (this.m * this.v.normSquared() + I0[0] * wx * wx + I0[1] * wx * wy + I0[2] * wx * wz + I1[0] * wy * wx + I1[1] * wy * wy + I1[2] * wy * wz + I2[0] * wz * wx + I2[1] * wz * wy + I2[2] * wz * wz);
    };
    Body.prototype.reset = function(p, v, q, L) {
        this.setPos(p || [ 0, 0, 0 ]);
        this.setVel(v || [ 0, 0, 0 ]);
        this.w.clear();
        this.setOrientation(q || [ 1, 0, 0, 0 ]);
        this.setAngularMomentum(L || [ 0, 0, 0 ]);
    };
    Body.prototype.setOrientation = function(q) {
        this.q.set(q);
    };
    Body.prototype.setAngularMomentum = function(L) {
        this.L.set(L);
    };
    Body.prototype.applyForce = function(force, location) {
        if (this.hasImmunity(Body.IMMUNITIES.AGENTS)) return;
        this.f.set(this.f.add(force));
        if (location !== undefined) this.applyTorque(location.cross(force));
    };
    Body.prototype.applyTorque = function(torque) {
        if (this.hasImmunity(Body.IMMUNITIES.ROTATION)) return;
        this.t.set(this.t.add(torque));
    };
    Body.prototype.getTransform = function() {
        return Transform.move(this.q.getMatrix(), this.p.get());
    };
    module.exports = Body;
}.bind(this));

require.register("famous_modules/famous/physics/bodies/circle/_git_master/index.js", function(exports, require, module) {
    var Body = require("famous/physics/bodies/body");
    /**
     * @class An elemental circle-shaped Particle in the physics engine.
     * 
     * @description This is a region defined by a radius.
     *    Its size is the dimension of the bounding square.
     *
     *
     * * Class/Namespace TODOs
     * 
     * * opts: 
     *    * r: radius
     *    * inherited opts from: {@link Particle}.
     * 
     * @name Circle
     * @extends Particle
     * @constructor
     * @example TODO
     */
    function Circle(opts) {
        Body.call(this, opts);
        opts = opts || {};
        this.r = opts.r || 0;
        //radius
        this.size = [ 2 * this.r, 2 * this.r ];
        var r = this.r;
        var m = this.m;
        this.I = [ [ .25 * m * r * r, 0, 0 ], [ 0, .25 * m * r * r, 0 ], [ 0, 0, .5 * m * r * r ] ];
        this.Iinv = [ [ 4 / (m * r * r), 0, 0 ], [ 0, 4 / (m * r * r), 0 ], [ 0, 0, 2 / (m * r * r) ] ];
    }
    Circle.prototype = Object.create(Body.prototype);
    Circle.prototype.constructor = Circle;
    Circle.IMMUNITIES = Body.IMMUNITIES;
    module.exports = Circle;
}.bind(this));

require.register("famous_modules/famous/physics/bodies/rectangle/_git_master/index.js", function(exports, require, module) {
    var Body = require("famous/physics/bodies/body");
    /*
     * @class An elemental rectangle-shaped Particle in the physics engine.
     * 
     * @description This is a region defined by a 2D box. 
     *
     * * Class/Namespace TODOs
     * 
     * * opts: 
     *   * size: ([height, width]) array
     *   * inherited opts from: {@link Particle}.
     *
     * @name Rectangle
     * @extends Particle
     * @example TODO
     * @constructor
     */
    function Rectangle(opts) {
        Body.call(this, opts);
        opts = opts || {};
        this.size = opts.size || [ 0, 0 ];
        var w = this.size[0];
        var h = this.size[1];
        this.I = [ [ h * h / 12, 0, 0 ], [ 0, w * w / 12, 0 ], [ 0, 0, (w * w + h * h) / 12 ] ];
        this.Iinv = [ [ 12 / (h * h), 0, 0 ], [ 0, 12 / (w * w), 0 ], [ 0, 0, 12 / (w * w + h * h) ] ];
    }
    Rectangle.prototype = Object.create(Body.prototype);
    Rectangle.prototype.constructor = Rectangle;
    Rectangle.IMMUNITIES = Body.IMMUNITIES;
    module.exports = Rectangle;
}.bind(this));

require.register("famous_modules/famous/physics/engine/_git_master/index.js", function(exports, require, module) {
    var Particle = require("famous/physics/bodies/particle");
    var Body = require("famous/physics/bodies/body");
    var Circle = require("famous/physics/bodies/circle");
    var Rectangle = require("famous/physics/bodies/rectangle");
    var Force = require("famous/physics/forces/force");
    var Constraint = require("famous/physics/constraints/constraint");
    var Integrator = require("famous/physics/integrator/symplectic-euler");
    /** @constructor */
    function PhysicsEngine(opts) {
        //default options
        this.opts = {
            speed: 1,
            steps: 1,
            velocityCap: Infinity,
            angularVelocityCap: Infinity,
            constraintSteps: 1,
            constraintTolerance: 1e-4
        };
        if (opts) this.setOpts(opts);
        this._particles = [];
        //list of managed particles
        this._agents = {};
        //list of managed agents
        this._forces = [];
        //list of IDs of agents that are forces
        this._constraints = [];
        //list of IDs of agents that are constraints
        this._playing = true;
        this._buffer = 0;
        this._timestep = 1e3 / 60 / this.opts.steps;
        this._prevTime = undefined;
        this._currTime = undefined;
        this._integrator = new Integrator({
            velocityCap: this.opts.velocityCap,
            angularVelocityCap: this.opts.angularVelocityCap
        });
        this._currAgentId = 0;
        this.BODIES = PhysicsEngine.BODIES;
    }
    /* enum */
    PhysicsEngine.BODIES = {
        POINT: Particle,
        BODY: Body,
        CIRCLE: Circle,
        RECTANGLE: Rectangle
    };
    PhysicsEngine.IMMUNITIES = Particle.IMMUNITIES;
    //PRIVATE METHODS
    function getTime() {
        return Date.now();
    }
    //PUBLIC METHODS
    PhysicsEngine.prototype.setOpts = function(opts) {
        for (var key in opts) if (this.opts[key]) this.opts[key] = opts[key];
    };
    PhysicsEngine.prototype.addBody = function(body) {
        this._particles.push(body);
        return body;
    };
    // TODO: deprecate
    PhysicsEngine.prototype.createParticle = function(opts) {
        return this.addBody(new Particle(opts));
    };
    PhysicsEngine.prototype.createBody = function(opts) {
        var shape = opts.shape || PhysicsEngine.BODIES.POINT;
        return this.addBody(new shape(opts));
    };
    PhysicsEngine.prototype.remove = function(target) {
        var index = this._particles.indexOf(target);
        if (index > -1) {
            for (var i = 0; i < Object.keys(this._agents); i++) this.detachFrom(i, target);
            this._particles.splice(index, 1);
        }
    };
    function attachOne(agent, targets, source) {
        if (targets === undefined) targets = this.getParticles();
        if (!(targets instanceof Array)) targets = [ targets ];
        this._agents[this._currAgentId] = {
            agent: agent,
            targets: targets,
            source: source
        };
        _mapAgentArray.call(this, agent).push(this._currAgentId);
        return this._currAgentId++;
    }
    PhysicsEngine.prototype.attach = function(agents, targets, source) {
        if (agents instanceof Array) {
            var agentIDs = [];
            for (var i = 0; i < agents.length; i++) agentIDs[i] = attachOne.call(this, agents[i], targets, source);
            return agentIDs;
        } else return attachOne.call(this, agents, targets, source);
    };
    PhysicsEngine.prototype.attachTo = function(agentID, target) {
        _getBoundAgent.call(this, agentID).targets.push(target);
    };
    PhysicsEngine.prototype.detach = function(id) {
        // detach from forces/constraints array
        var agent = this.getAgent(id);
        var agentArray = _mapAgentArray.call(this, agent);
        var index = agentArray.indexOf(id);
        agentArray.splice(index, 1);
        // detach agents array
        delete this._agents[id];
    };
    PhysicsEngine.prototype.detachFrom = function(id, target) {
        var boundAgent = _getBoundAgent.call(this, id);
        if (boundAgent.source === target) this.detach(id); else {
            var targets = boundAgent.targets;
            var index = targets.indexOf(target);
            if (index > -1) targets.splice(index, 1);
        }
    };
    PhysicsEngine.prototype.detachAll = function() {
        this._agents = {};
        this._forces = [];
        this._constraints = [];
        this._currAgentId = 0;
    };
    function _mapAgentArray(agent) {
        if (agent instanceof Force) return this._forces;
        if (agent instanceof Constraint) return this._constraints;
    }
    function _getBoundAgent(id) {
        return this._agents[id];
    }
    PhysicsEngine.prototype.getAgent = function(id) {
        return _getBoundAgent.call(this, id).agent;
    };
    PhysicsEngine.prototype.getParticles = function() {
        return this._particles;
    };
    PhysicsEngine.prototype.getParticlesExcept = function(particles) {
        var result = [];
        this.forEachParticle(function(particle) {
            if (particles.indexOf(particle) === -1) result.push(particle);
        });
        return result;
    };
    PhysicsEngine.prototype.getPos = function(particle) {
        return (particle || this._particles[0]).getPos();
    };
    PhysicsEngine.prototype.getVel = function(particle) {
        return (particle || this._particles[0]).getVel();
    };
    PhysicsEngine.prototype.getTransform = function(particle) {
        return (particle || this._particles[0]).getTransform();
    };
    PhysicsEngine.prototype.setPos = function(pos, particle) {
        (particle || this._particles[0]).setPos(pos);
    };
    PhysicsEngine.prototype.setVel = function(vel, particle) {
        (particle || this._particles[0]).setVel(vel);
    };
    PhysicsEngine.prototype.forEachParticle = function(fn, args) {
        var particles = this.getParticles();
        for (var index = 0, len = particles.length; index < len; index++) fn.call(this, particles[index], args);
    };
    function _updateForce(index) {
        var boundAgent = _getBoundAgent.call(this, this._forces[index]);
        boundAgent.agent.applyForce(boundAgent.targets, boundAgent.source);
    }
    function _updateConstraint(index, dt) {
        var boundAgent = this._agents[this._constraints[index]];
        return boundAgent.agent.applyConstraint(boundAgent.targets, boundAgent.source, dt);
    }
    function updateForces() {
        for (var index = this._forces.length - 1; index > -1; index--) _updateForce.call(this, index);
    }
    function updateConstraints(dt) {
        //Todo: while statement here until tolerance is met
        var err = Infinity;
        var iteration = 0;
        var tolerance = this.opts.constraintTolerance;
        while (iteration < this.opts.constraintSteps) {
            err = 0;
            for (var index = this._constraints.length - 1; index > -1; index--) err += _updateConstraint.call(this, index, dt);
            iteration++;
        }
    }
    function _updateVelocity(particle, dt) {
        if (particle.hasImmunity(Particle.IMMUNITIES.UPDATE)) return;
        this._integrator.integrateVelocity(particle, dt);
    }
    function _updateAngularVelocity(particle) {
        if (particle.hasImmunity(Particle.IMMUNITIES.ROTATION)) return;
        if (particle instanceof Body) particle.updateAngularVelocity();
    }
    function _updateAngularMomentum(particle, dt) {
        if (particle.hasImmunity(Particle.IMMUNITIES.ROTATION)) return;
        if (particle instanceof Body) this._integrator.integrateAngularMomentum(particle, dt);
    }
    function _updatePosition(particle, dt) {
        if (particle.hasImmunity(Particle.IMMUNITIES.UPDATE)) return;
        this._integrator.integratePosition(particle, dt);
    }
    function _updateOrientation(particle, dt) {
        if (particle.hasImmunity(Particle.IMMUNITIES.ROTATION)) return;
        if (particle instanceof Body) this._integrator.integrateOrientation(particle, dt);
    }
    function updateVelocities(dt) {
        this.forEachParticle(_updateVelocity, dt);
    }
    function updatePositions(dt) {
        this.forEachParticle(_updatePosition, dt);
    }
    function updateAngularVelocities() {
        this.forEachParticle(_updateAngularVelocity);
    }
    function updateAngularMomenta(dt) {
        this.forEachParticle(_updateAngularMomentum, dt);
    }
    function updateOrientations(dt) {
        this.forEachParticle(_updateOrientation, dt);
    }
    function integrate(dt) {
        updateForces.call(this);
        updateVelocities.call(this, dt);
        updateAngularMomenta.call(this, dt);
        updateAngularVelocities.call(this, dt);
        updateConstraints.call(this, dt);
        updatePositions.call(this, dt);
        updateOrientations.call(this, dt);
    }
    PhysicsEngine.prototype.step = function(dt) {
        if (!this._playing) return;
        //set previous time on initialization
        if (!this._prevTime) this._prevTime = getTime();
        //set current frame's time
        this._currTime = getTime();
        //milliseconds elapsed since last frame
        var dtFrame = this._currTime - this._prevTime;
        this._prevTime = this._currTime;
        if (dtFrame == 0) return;
        //robust integration
        // this._buffer += dtFrame;
        // while (this._buffer > this._timestep){
        //     integrate.call(this, this.opts.speed * this._timestep);
        //     this._buffer -= this._timestep;
        // };
        //simple integration
        integrate.call(this, this.opts.speed * this._timestep);
    };
    PhysicsEngine.prototype.render = function(target) {
        this.step();
        var result = [];
        this.forEachParticle(function(particle) {
            result.push(particle.render(target));
        });
        return result;
    };
    PhysicsEngine.prototype.play = function() {
        this._prevTime = getTime();
        this._playing = true;
    };
    PhysicsEngine.prototype.pause = function() {
        this._playing = false;
    };
    PhysicsEngine.prototype.toggle = function() {
        this._playing ? this.pause() : this.play();
    };
    PhysicsEngine.prototype.reverseTime = function() {
        this.opts.speed *= -1;
    };
    PhysicsEngine.prototype.reverseVelocities = function() {
        this.forEachParticle(function(particle) {
            particle.v.mult(-1, particle.v);
        });
    };
    module.exports = PhysicsEngine;
}.bind(this));

require.register("famous_modules/famous/views/scrollview/_git_master/index.js", function(exports, require, module) {
    var Utility = require("famous/utilities/utility");
    var PhysicsEngine = require("famous/physics/engine");
    var Particle = require("famous/physics/bodies/particle");
    var Drag = require("famous/physics/forces/drag");
    var Spring = require("famous/physics/forces/spring");
    var Transform = require("famous/transform");
    var EventHandler = require("famous/event-handler");
    var GenericSync = require("famous/input/generic-sync");
    var ViewSequence = require("famous/view-sequence");
    var Group = require("famous/group");
    var Entity = require("famous/entity");
    /**
     * @class Lays out the sequenced renderables sequentially and makes them scrollable.
     * @description Items outside the viewport are automatically culled.
     * @name Scrollview
     * @constructor
     * @example 
     *   var myScrollview = new Scrollview({
     *       itemSpacing: 20
     *   });
     * 
     *   var mySequence = new ViewSequence();
     *   for(var i = 0; i < 50; i++) {
     *       surfaces.push(new Surface({content: 'Item ' + i}));
     *   }
     *   myScrollview.sequenceFrom(surfaces); // link items into scrollview
     *
     *   Engine.pipe(myScrollview); // let events on root window control the scrollview
     *   myContext.link(myScrollview); // link scrollview into myContext
     */
    function Scrollview(options) {
        this.options = {
            direction: Utility.Direction.Y,
            rails: true,
            itemSpacing: 0,
            clipSize: undefined,
            margin: undefined,
            friction: .001,
            drag: 1e-4,
            edgeGrip: .5,
            edgePeriod: 300,
            edgeDamp: 1,
            paginated: false,
            pagePeriod: 500,
            pageDamp: .8,
            pageStopSpeed: Infinity,
            pageSwitchSpeed: 1,
            speedLimit: 10
        };
        this.node = null;
        this.physicsEngine = new PhysicsEngine();
        this.particle = new Particle();
        this.physicsEngine.addBody(this.particle);
        this.spring = new Spring({
            anchor: [ 0, 0, 0 ]
        });
        this.drag = new Drag({
            forceFunction: Drag.FORCE_FUNCTIONS.QUADRATIC
        });
        this.friction = new Drag({
            forceFunction: Drag.FORCE_FUNCTIONS.LINEAR
        });
        this.sync = new GenericSync(function() {
            return -this.getPosition();
        }.bind(this), {
            direction: this.options.direction == Utility.Direction.X ? GenericSync.DIRECTION_X : GenericSync.DIRECTION_Y
        });
        this.eventInput = new EventHandler();
        this.eventOutput = new EventHandler();
        this.rawInput = new EventHandler();
        this.rawInput.pipe(this.sync);
        this.sync.pipe(this.eventInput);
        this.sync.pipe(this.eventOutput);
        this.rawInput.pipe(this.eventInput);
        EventHandler.setInputHandler(this, this.rawInput);
        EventHandler.setOutputHandler(this, this.eventOutput);
        this._outputFunction = null;
        this._masterOutputFunction = null;
        this.setOutputFunction();
        // use default
        this.touchCount = 0;
        this._springAttached = false;
        this._onEdge = 0;
        // -1 for top, 1 for bottom
        this._springPosition = 0;
        this._touchVelocity = undefined;
        this._earlyEnd = false;
        this._masterOffset = 0;
        // minimize writes
        this._offsetDifferential = 0;
        // avoid batch
        this._lastFrameNode = null;
        if (options) this.setOptions(options); else this.setOptions({});
        _bindEvents.call(this);
        this.group = new Group();
        this.group.add({
            render: _innerRender.bind(this)
        });
        this._entityId = Entity.register(this);
        this._contextSize = [ window.innerWidth, window.innerHeight ];
        this._size = [ this._contextSize[0], this._contextSize[1] ];
        this._offsets = {};
    }
    function _handleStart(event) {
        this.touchCount = event.count;
        if (event.count === undefined) this.touchCount = 1;
        _detachAgents.call(this);
        this.setVelocity(0);
        this._touchVelocity = 0;
        this._earlyEnd = false;
    }
    function _handleMove(event) {
        var pos = -event.p;
        var vel = -event.v;
        if (this._onEdge && event.slip) {
            if (vel < 0 && this._onEdge < 0 || vel > 0 && this._onEdge > 0) {
                if (!this._earlyEnd) {
                    _handleEnd.call(this, event);
                    this._earlyEnd = true;
                }
            } else if (this._earlyEnd && Math.abs(vel) > Math.abs(this.particle.getVel()[0])) {
                _handleStart.call(this, event);
            }
        }
        if (this._earlyEnd) return;
        this._touchVelocity = vel;
        if (event.slip) this.setVelocity(vel); else this.setPosition(pos);
    }
    function _handleEnd(event) {
        this.touchCount = event.count || 0;
        if (!this.touchCount) {
            _detachAgents.call(this);
            if (this._onEdge) this._springAttached = true;
            _attachAgents.call(this);
            var vel = -event.v;
            var speedLimit = this.options.speedLimit;
            if (event.slip) speedLimit *= this.options.edgeGrip;
            if (vel < -speedLimit) vel = -speedLimit; else if (vel > speedLimit) vel = speedLimit;
            this.setVelocity(vel);
            this._touchVelocity = undefined;
        }
    }
    function _bindEvents() {
        this.eventInput.on("start", _handleStart.bind(this));
        this.eventInput.on("update", _handleMove.bind(this));
        this.eventInput.on("end", _handleEnd.bind(this));
    }
    function _attachAgents() {
        if (this._springAttached) this.physicsEngine.attach([ this.spring ], this.particle); else this.physicsEngine.attach([ this.drag, this.friction ], this.particle);
    }
    function _detachAgents() {
        this._springAttached = false;
        this.physicsEngine.detachAll();
    }
    function _sizeForDir(size) {
        if (!size) size = this._contextSize;
        var dimension = this.options.direction === Utility.Direction.X ? 0 : 1;
        return size[dimension] === undefined ? this._contextSize[dimension] : size[dimension];
    }
    function _shiftOrigin(amount) {
        this._springPosition += amount;
        this._offsetDifferential -= amount;
        this.setPosition(this.getPosition() + amount);
        this.spring.setOpts({
            anchor: [ this._springPosition, 0, 0 ]
        });
    }
    function _normalizeState() {
        var atEdge = false;
        while (!atEdge && this.getPosition() < 0) {
            var prevNode = this.node.getPrevious ? this.node.getPrevious() : null;
            if (prevNode) {
                var prevSize = prevNode.getSize ? prevNode.getSize() : this._contextSize;
                var dimSize = _sizeForDir.call(this, prevSize) + this.options.itemSpacing;
                _shiftOrigin.call(this, dimSize);
                this._masterOffset -= dimSize;
                this.node = prevNode;
            } else atEdge = true;
        }
        var size = this.node && this.node.getSize ? this.node.getSize() : this._contextSize;
        while (!atEdge && this.getPosition() >= _sizeForDir.call(this, size) + this.options.itemSpacing) {
            var nextNode = this.node.getNext ? this.node.getNext() : null;
            if (nextNode) {
                var dimSize = _sizeForDir.call(this, size) + this.options.itemSpacing;
                _shiftOrigin.call(this, -dimSize);
                this._masterOffset += dimSize;
                this.node = nextNode;
                size = this.node.getSize ? this.node.getSize() : this._contextSize;
            } else atEdge = true;
        }
        if (Math.abs(this._masterOffset) > _getClipSize.call(this) + this.options.margin) this._masterOffset = 0;
    }
    function _handleEdge(edgeDetected) {
        if (!this._onEdge && edgeDetected) {
            this.sync.setOptions({
                scale: this.options.edgeGrip
            });
            if (!this.touchCount && !this._springAttached) {
                this._springAttached = true;
                this.physicsEngine.attach([ this.spring ], this.particle);
            }
        } else if (this._onEdge && !edgeDetected) {
            this.sync.setOptions({
                scale: 1
            });
            if (this._springAttached && Math.abs(this.getVelocity()) < .001) {
                this.setVelocity(0);
                this.setPosition(this._springPosition);
                // reset agents, detaching the spring
                _detachAgents.call(this);
                _attachAgents.call(this);
            }
        }
        this._onEdge = edgeDetected;
    }
    function _handlePagination() {
        if (this.touchCount == 0 && !this._springAttached && !this._onEdge) {
            if (this.options.paginated && Math.abs(this.getVelocity()) < this.options.pageStopSpeed) {
                var nodeSize = this.node.getSize ? this.node.getSize() : this._contextSize;
                // parameters to determine when to switch
                var velSwitch = Math.abs(this.getVelocity()) > this.options.pageSwitchSpeed;
                var velNext = this.getVelocity() > 0;
                var posNext = this.getPosition() > .5 * _sizeForDir.call(this, nodeSize);
                if (velSwitch && velNext || !velSwitch && posNext) this.goToNextPage(); else _attachPageSpring.call(this);
            }
        }
    }
    function _attachPageSpring() {
        _setSpring.call(this, 0, {
            period: this.options.pagePeriod,
            damp: this.options.pageDamp
        });
        if (!this._springAttached) {
            this._springAttached = true;
            this.physicsEngine.attach([ this.spring ], this.particle);
        }
    }
    function _setSpring(position, parameters) {
        this._springPosition = position;
        this.spring.setOpts({
            anchor: [ this._springPosition, 0, 0 ],
            period: parameters ? parameters.period : this.options.edgePeriod,
            dampingRatio: parameters ? parameters.damp : this.options.edgeDamp
        });
    }
    function _output(node, offset, target) {
        var size = node.getSize ? node.getSize() : this._contextSize;
        var transform = this._outputFunction(offset);
        target.push({
            transform: transform,
            target: node.render()
        });
        return _sizeForDir.call(this, size);
    }
    function _getClipSize() {
        if (this.options.clipSize) return this.options.clipSize; else return _sizeForDir.call(this, this._contextSize);
    }
    Scrollview.prototype.getPosition = function(node) {
        var pos = this.particle.getPos()[0];
        if (node === undefined) return pos; else {
            var offset = this._offsets[node];
            if (offset !== undefined) return pos - offset + this._offsetDifferential; else return undefined;
        }
    };
    Scrollview.prototype.setPosition = function(pos) {
        this.particle.setPos([ pos, 0, 0 ]);
    };
    Scrollview.prototype.getVelocity = function() {
        return this.touchCount ? this._touchVelocity : this.particle.getVel()[0];
    };
    Scrollview.prototype.setVelocity = function(v) {
        this.particle.setVel([ v, 0, 0 ]);
    };
    Scrollview.prototype.getOptions = function() {
        return this.options;
    };
    Scrollview.prototype.setOptions = function(options) {
        if (options.direction !== undefined) {
            this.options.direction = options.direction;
            if (this.options.direction === "x") this.options.direction = Utility.Direction.X; else if (this.options.direction === "y") this.options.direction = Utility.Direction.Y;
        }
        if (options.rails !== undefined) this.options.rails = options.rails;
        if (options.itemSpacing !== undefined) this.options.itemSpacing = options.itemSpacing;
        if (options.clipSize !== undefined) {
            if (options.clipSize !== this.options.clipSize) this._onEdge = 0;
            // recalculate edge on resize
            this.options.clipSize = options.clipSize;
        }
        if (options.margin !== undefined) this.options.margin = options.margin;
        if (options.drag !== undefined) this.options.drag = options.drag;
        if (options.friction !== undefined) this.options.friction = options.friction;
        if (options.edgeGrip !== undefined) this.options.edgeGrip = options.edgeGrip;
        if (options.edgePeriod !== undefined) this.options.edgePeriod = options.edgePeriod;
        if (options.edgeDamp !== undefined) this.options.edgeDamp = options.edgeDamp;
        if (options.paginated !== undefined) this.options.paginated = options.paginated;
        if (options.pageStopSpeed !== undefined) this.options.pageStopSpeed = options.pageStopSpeed;
        if (options.pageSwitchSpeed !== undefined) this.options.pageSwitchSpeed = options.pageSwitchSpeed;
        if (options.pagePeriod !== undefined) this.options.pagePeriod = options.pagePeriod;
        if (options.pageDamp !== undefined) this.options.pageDamp = options.pageDamp;
        if (options.speedLimit !== undefined) this.options.speedLimit = options.speedLimit;
        if (this.options.margin === undefined) this.options.margin = .5 * Math.max(window.innerWidth, window.innerHeight);
        this.drag.setOpts({
            strength: this.options.drag
        });
        this.friction.setOpts({
            strength: this.options.friction
        });
        this.spring.setOpts({
            period: this.options.edgePeriod,
            dampingRatio: this.options.edgeDamp
        });
        this.sync.setOptions({
            rails: this.options.rails,
            direction: this.options.direction == Utility.Direction.X ? GenericSync.DIRECTION_X : GenericSync.DIRECTION_Y
        });
    };
    Scrollview.prototype.setOutputFunction = function(fn, masterFn) {
        if (!fn) {
            fn = function(offset) {
                return this.options.direction == Utility.Direction.X ? Transform.translate(offset, 0) : Transform.translate(0, offset);
            }.bind(this);
            if (!masterFn) masterFn = fn;
        }
        this._outputFunction = fn;
        this._masterOutputFunction = masterFn ? masterFn : function(offset) {
            return Transform.inverse(fn(-offset));
        };
    };
    Scrollview.prototype.goToPreviousPage = function() {
        if (!this.node) return;
        var prevNode = this.node.getPrevious ? this.node.getPrevious() : null;
        if (prevNode) {
            var positionModification = _sizeForDir.call(this, this.node.getSize()) + this.options.itemSpacing;
            this.node = prevNode;
            this._springPosition -= positionModification;
            _shiftOrigin.call(this, positionModification);
            _attachPageSpring.call(this);
        }
        return prevNode;
    };
    Scrollview.prototype.goToNextPage = function() {
        if (!this.node) return;
        var nextNode = this.node.getNext ? this.node.getNext() : null;
        if (nextNode) {
            var positionModification = _sizeForDir.call(this, this.node.getSize()) + this.options.itemSpacing;
            this.node = nextNode;
            this._springPosition += positionModification;
            _shiftOrigin.call(this, -positionModification);
            _attachPageSpring.call(this);
        }
        return nextNode;
    };
    Scrollview.prototype.getCurrentNode = function() {
        return this.node;
    };
    Scrollview.prototype.sequenceFrom = function(node) {
        if (node instanceof Array) node = new ViewSequence(node);
        this.node = node;
        this._lastFrameNode = node;
    };
    Scrollview.prototype.getSize = function() {
        return this._size;
    };
    Scrollview.prototype.render = function() {
        if (!this.node) return;
        this.physicsEngine.step();
        return this._entityId;
    };
    Scrollview.prototype.commit = function(context) {
        var transform = context.transform;
        var opacity = context.opacity;
        var origin = context.origin;
        var size = context.size;
        // reset edge detection on size change
        if (!this.options.clipSize && (size[0] !== this._contextSize[0] || size[1] !== this._contextSize[1])) {
            this._onEdge = 0;
            this._contextSize = size;
            if (this.options.direction === Utility.Direction.X) {
                this._size[0] = _getClipSize.call(this);
                this._size[1] = undefined;
            } else {
                this._size[0] = undefined;
                this._size[1] = _getClipSize.call(this);
            }
        }
        _normalizeState.call(this);
        var pos = this.getPosition();
        var scrollTransform = this._masterOutputFunction(-(pos + this._masterOffset));
        return {
            transform: Transform.moveThen([ -origin[0] * size[0], -origin[1] * size[1], 0 ], transform),
            opacity: opacity,
            origin: origin,
            size: size,
            target: {
                transform: scrollTransform,
                origin: origin,
                target: this.group.render()
            }
        };
    };
    function _innerRender() {
        var offsets = {};
        var pos = this.getPosition();
        var result = [];
        var edgeDetected = 0;
        // -1 for top, 1 for bottom
        // forwards
        var offset = 0;
        var currNode = this.node;
        offsets[currNode] = 0;
        while (currNode && offset - pos < _getClipSize.call(this) + this.options.margin) {
            offset += _output.call(this, currNode, offset + this._masterOffset, result) + this.options.itemSpacing;
            currNode = currNode.getNext ? currNode.getNext() : null;
            offsets[currNode] = offset;
            if (!currNode && offset - pos - this.options.itemSpacing <= _getClipSize.call(this)) {
                if (!this._onEdge) _setSpring.call(this, offset - _getClipSize.call(this) - this.options.itemSpacing);
                edgeDetected = 1;
            }
        }
        // backwards
        currNode = this.node && this.node.getPrevious ? this.node.getPrevious() : null;
        offset = 0;
        if (currNode) {
            var size = currNode.getSize ? currNode.getSize() : this._contextSize;
            offset -= _sizeForDir.call(this, size) + this.options.itemSpacing;
        } else {
            if (pos <= 0) {
                if (!this._onEdge) _setSpring.call(this, 0);
                edgeDetected = -1;
            }
        }
        while (currNode && offset - pos > -(_getClipSize.call(this) + this.options.margin)) {
            offsets[currNode] = offset;
            _output.call(this, currNode, offset + this._masterOffset, result);
            currNode = currNode.getPrevious ? currNode.getPrevious() : null;
            if (currNode) {
                var size = currNode.getSize ? currNode.getSize() : this._contextSize;
                offset -= _sizeForDir.call(this, size) + this.options.itemSpacing;
            }
        }
        this._offsetDifferential = 0;
        this._offsets = offsets;
        _handleEdge.call(this, edgeDetected);
        _handlePagination.call(this);
        if (this.options.paginated && this._lastFrameNode !== this.node) {
            this.eventOutput.emit("pageChange");
            this._lastFrameNode = this.node;
        }
        return result;
    }
    module.exports = Scrollview;
}.bind(this));

require.register("famous_modules/famous/transitions/spring-transition/_git_master/index.js", function(exports, require, module) {
    var PhysicsEngine = require("famous/physics/engine");
    var Spring = require("famous/physics/forces/spring");
    var Vector = require("famous/math/vector");
    /** @constructor */
    function SpringTransition(state) {
        state = state || 0;
        this.endState = new Vector(state);
        this.initState = new Vector();
        this._dimensions = undefined;
        this._restTolerance = 1e-8;
        this._absRestTolerance = this._restTolerance;
        this._active = false;
        this._callback = undefined;
        this.PhysicsEngine = new PhysicsEngine();
        this.spring = new Spring({
            anchor: this.endState
        });
        this.particle = this.PhysicsEngine.createParticle();
        this.PhysicsEngine.attach(this.spring, this.particle);
    }
    SpringTransition.SUPPORTS_MULTIPLE = 3;
    SpringTransition.DEFAULT_OPTIONS = {
        period: 300,
        dampingRatio: .5,
        velocity: 0
    };
    function _update() {
        if (!this._active) {
            if (this._callback) {
                var cb = this._callback;
                this._callback = undefined;
                cb();
            }
            return;
        }
        this.PhysicsEngine.step();
        if (_getEnergy.call(this) < this._absRestTolerance) {
            _setParticlePosition.call(this, this.endState);
            _setParticleVelocity.call(this, [ 0, 0, 0 ]);
            _sleep.call(this);
        }
    }
    function _getEnergy() {
        return this.particle.getEnergy() + this.spring.getEnergy(this.particle);
    }
    function _setupDefinition(def) {
        var defaults = SpringTransition.DEFAULT_OPTIONS;
        if (def.period === undefined) def.period = defaults.period;
        if (def.dampingRatio === undefined) def.dampingRatio = defaults.dampingRatio;
        if (def.velocity === undefined) def.velocity = defaults.velocity;
        if (def.period < 150) console.warn("period may be unstable, increase the period or use a stiff transition");
        //setup spring
        this.spring.setOpts({
            period: def.period,
            dampingRatio: def.dampingRatio
        });
        //setup particle
        _setParticleVelocity.call(this, def.velocity);
    }
    function _setAbsoluteRestTolerance() {
        var distance = this.endState.sub(this.initState).normSquared();
        this._absRestTolerance = distance === 0 ? this._restTolerance : this._restTolerance * distance;
    }
    function _setTarget(target) {
        this.endState.set(target);
        _setAbsoluteRestTolerance.call(this);
    }
    function _wake() {
        this.PhysicsEngine.play();
        this._active = true;
    }
    function _sleep() {
        this.PhysicsEngine.pause();
        this._active = false;
    }
    function _setParticlePosition(p) {
        this.particle.p.set(p);
    }
    function _setParticleVelocity(v) {
        this.particle.v.set(v);
    }
    function _getParticlePosition() {
        return this._dimensions === 0 ? this.particle.p.x : this.particle.p.get();
    }
    function _getParticleVelocity() {
        return this._dimensions === 0 ? this.particle.v.x : this.particle.v.get();
    }
    function _setCallback(callback) {
        this._callback = callback;
    }
    SpringTransition.prototype.reset = function(pos, vel) {
        this._dimensions = pos instanceof Array ? pos.length : 0;
        this.initState.set(pos);
        _setParticlePosition.call(this, pos);
        _setTarget.call(this, pos);
        if (vel) _setParticleVelocity.call(this, vel);
        _setCallback.call(this, undefined);
    };
    SpringTransition.prototype.getVelocity = function() {
        return _getParticleVelocity.call(this);
    };
    SpringTransition.prototype.setVelocity = function(v) {
        this.call(this, _setParticleVelocity(v));
    };
    SpringTransition.prototype.halt = function() {
        this.set(this.get());
    };
    SpringTransition.prototype.get = function() {
        _update.call(this);
        return _getParticlePosition.call(this);
    };
    SpringTransition.prototype.set = function(endState, definition, callback) {
        if (!definition) {
            this.reset(endState);
            if (callback) callback();
            return;
        }
        this._dimensions = endState instanceof Array ? endState.length : 0;
        _wake.call(this);
        _setupDefinition.call(this, definition);
        _setTarget.call(this, endState);
        _setCallback.call(this, callback);
    };
    module.exports = SpringTransition;
}.bind(this));

require.register("app/custom/vertical-scroll-view/vertical-scroll-view.js", function(exports, require, module) {
    var View = require("famous/view");
    var Utility = require("famous/utilities/utility");
    var Surface = require("famous/surface");
    var Scrollview = require("famous/views/scrollview");
    var Engine = require("famous/engine");
    function VerticalScrollView(options) {
        Scrollview.apply(this, arguments);
        this.prepareEmptySurface();
        this.prepareResize();
        this.itemArray = [];
        window.ss = this;
    }
    VerticalScrollView.prototype = Object.create(Scrollview.prototype);
    VerticalScrollView.prototype.constructor = VerticalScrollView;
    VerticalScrollView.prototype.setOptions = function(options) {
        this.options.startAt = "top";
        // 'bottom'
        this.options.direction = Utility.Direction.Y;
        this.options.margin = 1e4;
        Object.getPrototypeOf(VerticalScrollView.prototype).setOptions.apply(this, arguments);
        _.extend(this.options, options);
    };
    VerticalScrollView.prototype.prepareEmptySurface = function() {
        this.emptySurface = new Surface({
            properties: {
                backgroundColor: "transparent"
            },
            size: [ undefined, 1 ]
        });
        this.emptySurface.pipe(this);
    };
    VerticalScrollView.prototype.prepareResize = function() {
        var resizeTimeout;
        var onResize = function() {
            this.emptySurfaceResize();
        };
        Engine.on("resize", function() {
            if (resizeTimeout) clearTimeout(resizeTimeout);
            resizeTimeout = setTimeout(onResize.bind(this), 300);
        }.bind(this));
    };
    VerticalScrollView.prototype.sortBy = function(iterator) {
        this.sequenceFrom(_.sortBy(this.itemArray, iterator));
    };
    VerticalScrollView.prototype.filter = function(predicate) {
        // Not doing filter yet
        this.sequenceFrom(_.filter(this.itemArray, predicate));
    };
    VerticalScrollView.prototype.sequenceFrom = function(node) {
        this.itemArray = _.clone(node);
        //    _.each(this.itemArray, function(item) {
        //        item.pipe(this);
        //    }.bind(this));
        if (this.options.startAt == "top") {
            node.push(this.emptySurface);
        } else {
            node.unshift(this.emptySurface);
        }
        // TODO: this.sequence need garbage collection
        Object.getPrototypeOf(VerticalScrollView.prototype).sequenceFrom.apply(this, arguments);
        this.emptySurfaceResize();
    };
    VerticalScrollView.prototype.emptySurfaceResize = function(msg) {
        //    console.log(msg)
        if (this.emptySurface) {
            //        Engine.defer( doResize.bind(this));
            setTimeout(doResize.bind(this), 300);
        }
        function doResize() {
            var extraHeight = this.getSize()[1];
            if (this.node) {
                var itemSequence = _.filter(this.node.array, function(i) {
                    return i instanceof Surface == false;
                });
                for (var i = 0; i < itemSequence.length; i++) {
                    extraHeight -= itemSequence[i].getSize()[1];
                    if (extraHeight <= 1) {
                        extraHeight = 1;
                        break;
                    }
                }
            }
            this.emptySurface.setSize([ undefined, extraHeight ]);
        }
    };
    VerticalScrollView.prototype.scrollTo = function(index, position) {
        if (!index) index = 0;
        if (!position) position = 0;
        this.node.index = index;
        this.setPosition(position);
    };
    VerticalScrollView.prototype.removeByIndex = function(index) {
        if (index < 0) return;
        if (this.node) {
            var removedNode = this.itemArray.splice(index, 1)[0];
            removedNode.collapse(function() {
                Engine.defer(function() {
                    var i = this.node.array.indexOf(removedNode);
                    this.node.splice(i, 1);
                    // this fixes first item removal return index -1 bug
                    if (i == 0) this.node.index = 0;
                    this.emptySurfaceResize();
                }.bind(this));
            }.bind(this));
        }
    };
    VerticalScrollView.prototype.addByIndex = function(index, item) {
        //    item.pipe(this);
        this.itemArray.splice(index, 0, item);
        this.node.splice(index, 0, item);
        // reset position
        this.node.index = 0;
        this.emptySurfaceResize();
    };
    VerticalScrollView.prototype.push = function(item) {
        //  this will work for start at bottom only.
        this.itemArray.push(item);
        this.node.push(item);
        // reset position
        //    this.node.index = 0;
        this.emptySurfaceResize("push");
    };
    VerticalScrollView.prototype.scrollToEnd = function() {
        //    this.setVelocity(-1);
        var lastNode = this.node.array.length - 1;
        var currNode = this.node.index;
        var screenSize = this.getSize()[1];
        var currPos = this.getPosition();
        var heightArray = this.node.array.map(function(d) {
            if (d.getSize()[1] === true) return 100;
            return d.getSize()[1];
        });
        var sum = _.reduce(_(heightArray).last(lastNode - currNode + 1), function(memo, num) {
            return memo + num;
        }, 0);
        var totalPixelsToMove = sum - currPos - screenSize + 100;
        //    var totalPixelsToMove = _(heightArray).last(lastNode-currNode + 1).sum() - currPos - screenSize + 100;
        // 200ms animation, so avgVelocity = totalPixelsToMove/200ms, so v = 2*avgVelocity
        var v = Math.max(2 * totalPixelsToMove / 200, 0);
        // TODO: hack, so it will never onEdge when scrollToEnd
        if (this._onEdge == -1 && this.emptySurface.getSize()[1] <= 1 && this._springAttached) {
            this.scrollTo(1, 0);
            setTimeout(function() {
                this.setVelocity(v);
            }.bind(this), 300);
        } else {
            Engine.defer(function() {
                this.setVelocity(v);
            }.bind(this));
        }
    };
    VerticalScrollView.prototype.jumpToBottom = function() {
        //    console.log(this.emptySurface.getSize()[1], this._onEdge)
        if (this.emptySurface.getSize()[1] > 1) return;
        if (this._onEdge != 0) {
            var len = this.node.array.length;
            var index = Math.max(len - 15, 1);
            this.node.index = index;
        }
        //    setTimeout(function(){
        //        for (var i = index || this.node.index + 1; i< this.node.array.length; i++) {
        //            this.node.index = i;
        //            if (this._onEdge == 1) break
        //        }
        //    }.bind(this),100)
        setTimeout(function() {
            this.node.index = this.node.array.length - 1;
        }.bind(this), 100);
    };
    VerticalScrollView.prototype.jumpToEnd11 = function() {
        var h = this.getSize()[1];
        var rowH = 62;
        var index = Math.max(this.node.array.length - Math.ceil(h / rowH), 0);
        this.node.index = index;
        this.setVelocity(0);
    };
    VerticalScrollView.prototype.jumpToEnd = function() {
        this.node.index = this.node.array.length - 1;
    };
    module.exports = VerticalScrollView;
}.bind(this));

require.register("famous_modules/famous/physics/constraints/wall/_git_master/index.js", function(exports, require, module) {
    var Constraint = require("famous/physics/constraints/constraint");
    var Vector = require("famous/math/vector");
    var EventHandler = require("famous/event-handler");
    /** @constructor */
    function Wall(opts) {
        this.opts = {
            restitution: .7,
            k: 0,
            n: new Vector(),
            d: 0,
            onContact: Wall.ON_CONTACT.REFLECT
        };
        if (opts) this.setOpts(opts);
        //registers
        this.diff = new Vector();
        this.impulse = new Vector();
        this.slop = -1;
        this.eventOutput = undefined;
    }
    Wall.prototype = Object.create(Constraint.prototype);
    Wall.prototype.constructor = Constraint;
    Wall.ON_CONTACT = {
        REFLECT: 0,
        WRAP: 1,
        ABSORB: 2
    };
    Wall.prototype.setOpts = function(opts) {
        if (opts.restitution !== undefined) this.opts.restitution = opts.restitution;
        if (opts.k !== undefined) this.opts.k = opts.k;
        if (opts.d !== undefined) this.opts.d = opts.d;
        if (opts.onContact !== undefined) this.opts.onContact = opts.onContact;
        if (opts.n !== undefined) this.opts.n.set(opts.n);
    };
    Wall.prototype.getNormalVelocity = function(v) {
        var n = this.opts.n;
        return v.dot(n);
    };
    Wall.prototype.getDistance = function(p) {
        var n = this.opts.n, d = this.opts.d;
        return p.dot(n) + d;
    };
    Wall.prototype.onEnter = function(particle, overlap, dt) {
        var p = particle.p, v = particle.v, m = particle.m, n = this.opts.n, action = this.opts.onContact, restitution = this.opts.restitution, impulse = this.impulse;
        var k = this.opts.k;
        var gamma = 0;
        if (this.eventOutput) {
            var data = {
                particle: particle,
                wall: this,
                overlap: overlap
            };
            this.eventOutput.emit("preCollision", data);
            this.eventOutput.emit("collision", data);
        }
        switch (action) {
          case Wall.ON_CONTACT.REFLECT:
            var lambda = overlap < this.slop ? -((1 + restitution) * n.dot(v) + k / dt * (overlap - this.slop)) / (m * dt + gamma) : -((1 + restitution) * n.dot(v)) / (m * dt + gamma);
            impulse.set(n.mult(dt * lambda));
            particle.applyImpulse(impulse);
            particle.setPos(p.add(n.mult(-overlap)));
            break;

          case Wall.ON_CONTACT.ABSORB:
            var lambda = n.dot(v) / (m * dt + gamma);
            impulse.set(n.mult(dt * lambda));
            particle.applyImpulse(impulse);
            particle.setPos(p.add(n.mult(-overlap)));
            v.clear();
            break;

          case Wall.ON_CONTACT.WRAP:
            if (overlap < -particle.r) break;
        }
        if (this.eventOutput) this.eventOutput.emit("postCollision", data);
    };
    Wall.prototype.onExit = function(particle, overlap, dt) {
        var action = this.opts.onContact;
        var p = particle.p;
        var n = this.opts.n;
        if (action == Wall.ON_CONTACT.REFLECT) {
            particle.setPos(p.add(n.mult(-overlap)));
        } else if (action == Wall.ON_CONTACT.WRAP) {} else if (action == Wall.ON_CONTACT.ABSORB) {}
    };
    Wall.prototype.applyConstraint = function(particles, source, dt) {
        var n = this.opts.n;
        for (var i = 0; i < particles.length; i++) {
            var particle = particles[i], p = particle.p, v = particle.v, r = particle.r || 0;
            var overlap = this.getDistance(p.add(n.mult(-r)));
            //if semi-penetrable then detect nv as well
            var nv = this.getNormalVelocity(v);
            if (overlap <= 0) {
                if (nv < 0) this.onEnter(particle, overlap, dt); else this.onExit(particle, overlap, dt);
            }
        }
    };
    function _createEventOutput() {
        this.eventOutput = new EventHandler();
        this.eventOutput.bindThis(this);
        EventHandler.setOutputHandler(this, this.eventOutput);
    }
    Wall.prototype.on = function() {
        _createEventOutput.call(this);
        return this.on.apply(this, arguments);
    };
    Wall.prototype.unbind = function() {
        _createEventOutput.call(this);
        return this.unbind.apply(this, arguments);
    };
    Wall.prototype.pipe = function() {
        _createEventOutput.call(this);
        return this.pipe.apply(this, arguments);
    };
    Wall.prototype.unpipe = function() {
        _createEventOutput.call(this);
        return this.unpipe.apply(this, arguments);
    };
    module.exports = Wall;
}.bind(this));

require.register("famous_modules/famous/transitions/wall-transition/_git_master/index.js", function(exports, require, module) {
    var PhysicsEngine = require("famous/physics/engine");
    var Spring = require("famous/physics/forces/spring");
    var Wall = require("famous/physics/constraints/wall");
    var Vector = require("famous/math/vector");
    /*
    * Define a physical transition by attaching a spring and or wall to a target location
    * The definition for the transition allows one to specify the parameters of the
    * spring and wall and starting velocity
    */
    /** @constructor */
    function WallTransition(state) {
        state = state || 0;
        this.endState = new Vector(state);
        this.initState = new Vector();
        this._active = false;
        this.spring = new Spring({
            anchor: this.endState
        });
        this.wall = new Wall();
        this._restTolerance = 1e-8;
        this._absRestTolerance = this._restTolerance;
        this._callback = undefined;
        this.PhysicsEngine = new PhysicsEngine();
        this.particle = this.PhysicsEngine.createParticle({
            p: this.endState
        });
        this.PhysicsEngine.attach([ this.wall, this.spring ], this.particle);
    }
    WallTransition.SUPPORTS_MULTIPLE = 3;
    WallTransition.DEFAULT_OPTIONS = {
        period: 300,
        dampingRatio: 0,
        restitution: .5,
        velocity: 0
    };
    function _update() {
        if (!this._active) {
            if (this._callback) {
                var cb = this._callback;
                this._callback = undefined;
                cb();
            }
            return;
        }
        this.PhysicsEngine.step();
        var energy = _getEnergy.call(this);
        if (energy < this._absRestTolerance) {
            _sleep.call(this);
            _setParticlePosition.call(this, this.endState);
            _setParticleVelocity.call(this, [ 0, 0, 0 ]);
        }
    }
    function _getEnergy() {
        return this.particle.getEnergy() + this.spring.getEnergy(this.particle);
    }
    function _setAbsoluteRestTolerance() {
        var distance = this.endState.sub(this.initState).normSquared();
        this._absRestTolerance = distance === 0 ? this._restTolerance : this._restTolerance * distance;
    }
    function _setupDefinition(def) {
        var defaults = WallTransition.DEFAULT_OPTIONS;
        if (def.period === undefined) def.period = defaults.period;
        if (def.dampingRatio === undefined) def.dampingRatio = defaults.dampingRatio;
        if (def.velocity === undefined) def.velocity = defaults.velocity;
        if (def.restitution === undefined) def.restitution = defaults.restitution;
        //setup spring
        this.spring.setOpts({
            period: def.period,
            dampingRatio: def.dampingRatio
        });
        //setup wall
        this.wall.setOpts({
            restitution: def.restitution
        });
        //setup particle
        _setParticleVelocity.call(this, def.velocity);
    }
    function _wake() {
        this.PhysicsEngine.play();
        this._active = true;
    }
    function _sleep() {
        this.PhysicsEngine.pause();
        this._active = false;
    }
    function _setTarget(target) {
        this.endState.set(target);
        var dist = this.endState.sub(this.initState).norm();
        this.wall.setOpts({
            d: this.endState.norm(),
            n: dist == 0 ? this.particle.v.normalize(-1) : this.endState.sub(this.initState).normalize(-1)
        });
        _setAbsoluteRestTolerance.call(this);
    }
    function _setParticlePosition(p) {
        this.particle.p.set(p);
    }
    function _setParticleVelocity(v) {
        this.particle.v.set(v);
    }
    function _getParticlePosition() {
        return this.dimensions === 0 ? this.particle.p.x : this.particle.p.get();
    }
    function _getParticleVelocity() {
        return this.dimensions === 0 ? this.particle.v.x : this.particle.v.get();
    }
    function _setCallback(callback) {
        this._callback = callback;
    }
    WallTransition.prototype.reset = function(pos, vel) {
        this.dimensions = pos instanceof Array ? pos.length : 0;
        this.initState.set(pos);
        _setParticlePosition.call(this, pos);
        if (vel) _setParticleVelocity.call(this, vel);
        _setTarget.call(this, pos);
        _setCallback.call(this, undefined);
    };
    WallTransition.prototype.getVelocity = function() {
        return _getParticleVelocity.call(this);
    };
    WallTransition.prototype.setVelocity = function(v) {
        this.call(this, _setParticleVelocity(v));
    };
    WallTransition.prototype.halt = function() {
        this.set(this.get());
    };
    WallTransition.prototype.get = function() {
        _update.call(this);
        return _getParticlePosition.call(this);
    };
    WallTransition.prototype.set = function(endState, definition, callback) {
        if (!definition) {
            this.reset(endState);
            if (callback) callback();
            return;
        }
        this.dimensions = endState instanceof Array ? endState.length : 0;
        _wake.call(this);
        _setupDefinition.call(this, definition);
        _setTarget.call(this, endState);
        _setCallback.call(this, callback);
    };
    module.exports = WallTransition;
}.bind(this));

require.register("app/custom/row-view/header-bar.js", function(exports, require, module) {
    var TitleBar = require("famous/widgets/title-bar");
    var Modifier = require("famous/modifier");
    function HeaderBar(options) {
        TitleBar.apply(this, arguments);
        //    this.surfaces = new RenderNode ();
        this.surfacesMod = new Modifier();
    }
    HeaderBar.prototype = Object.create(TitleBar.prototype);
    HeaderBar.prototype.constructor = HeaderBar;
    HeaderBar.prototype.collapse = function(callback) {
        this.hide();
        this.headerResize = true;
        this.setOptions({
            size: [ undefined, -1 ]
        });
    };
    HeaderBar.prototype.expand = function(callback) {
        this.show();
        this.headerResize = true;
        this.setOptions({
            size: [ undefined, 50 ]
        });
    };
    //HeaderBar.prototype.getSize = function() {
    //    if (this.headerResize) {
    //        var n = -this.options.size[1];
    //        if (this.lightbox.transforms[0]) {
    //            n = this.lightbox.transforms[0].transformTranslateState.get()[1];
    //        };
    //        return [this.options.size[0], Math.floor(this.options.size[1] + n) || -1];
    //    } else {
    //        return this.options.size;
    //    }
    //};
    HeaderBar.prototype.show = function(title) {
        if (!title) title = this.curTitle; else this.curTitle = title;
        TitleBar.prototype.show.apply(this, [ title ]);
        this.headerResize = false;
    };
    HeaderBar.prototype.hide = function() {
        this.lightbox.hide();
        this.headerResize = false;
    };
    module.exports = HeaderBar;
}.bind(this));

require.register("app/custom/row-view/header-view.js", function(exports, require, module) {
    var Surface = require("famous/surface");
    var Modifier = require("famous/modifier");
    var Transform = require("famous/transform");
    var Engine = require("famous/engine");
    var Templates = require("templates");
    var RowView = require("row-view");
    function HeaderView(options) {
        RowView.call(this);
        //    this.model = options;
        this.options = {
            //        collection: undefined,
            header: undefined,
            buttonSizeY: 20,
            classes: [],
            content: "",
            size: [ true, 20 ]
        };
        this.setOptions(options);
        //    this.containElements = this.options.collection.lastnameInitial(this.options.header).length != 0;
        //    this.setItemSize();
        this.setupSurfaces();
        this.events();
        window.hh = this;
    }
    HeaderView.prototype = Object.create(RowView.prototype);
    HeaderView.prototype.constructor = HeaderView;
    HeaderView.prototype.setOptions = function(options) {
        _.extend(this.options, options);
    };
    HeaderView.prototype.setupSurfaces = function() {
        this.headerMod = new Modifier();
        this.headerSurface = new Surface({
            classes: this.options.classes,
            size: this.options.size,
            properties: {
                color: "white"
            },
            content: this.options.content
        });
        //    this.setContent();
        this.headerSurface.pipe(this._eventOutput);
        this.surfaces.add(this.headerMod).add(this.headerSurface);
    };
    //HeaderView.prototype.setContent = function (){
    //    if (this.containElements) {
    //        this.headerSurface.setContent(this.options.content);
    //    } else {
    //        this.headerSurface.setContent(Templates.fateHeaderItemView(0,0));
    //    }
    //};
    //
    //HeaderView.prototype.setItemSize = function (){
    //    this.itemHeight = this.options.buttonSizeY;
    //    this.options.size = [true, this.itemHeight];
    //    if (!this.containElements) this.collapse();
    //};
    HeaderView.prototype.resizeItem = function() {
        if (this.headerSurface._currTarget) this.headerSurface._currTarget.children[0].style.width = window.innerWidth + "px";
    };
    HeaderView.prototype.events = function() {
        Engine.on("resize", this.resizeItem.bind(this));
    };
    module.exports = HeaderView;
}.bind(this));

require.register("app/custom/row-view/index.js", function(exports, require, module) {
    module.exports = {
        RowView: require("row-view"),
        ItemView: require("item-view"),
        HeaderView: require("header-view"),
        HeaderBar: require("header-bar")
    };
}.bind(this));

require.register("app/custom/row-view/item-view.js", function(exports, require, module) {
    var RenderNode = require("famous/render-node");
    var Surface = require("famous/surface");
    var Modifier = require("famous/modifier");
    var GenericSync = require("famous/input/generic-sync");
    var MouseSync = require("famous/input/mouse-sync");
    var TouchSync = require("famous/input/touch-sync");
    var Transform = require("famous/transform");
    var Easing = require("famous/transitions/easing");
    var Transitionable = require("famous/transitions/transitionable");
    var WallTransition = require("famous/transitions/wall-transition");
    var SpringTransition = require("famous/transitions/spring-transition");
    var Engine = require("famous/engine");
    var Utility = require("famous/utilities/utility");
    var Templates = require("templates");
    var RowView = require("row-view");
    var Helpers = require("helpers");
    Transitionable.registerMethod("wall", WallTransition);
    Transitionable.registerMethod("spring", SpringTransition);
    function ItemView(options) {
        RowView.apply(this, arguments);
        this.model = options.model;
        this.options = {
            paddingLeft: 20,
            paddingRight: 20,
            buttonSizeX: 50,
            buttonSizeY: 50,
            _leftEndOrigin: [ 0, 0 ],
            _rightEndOrigin: [ 1, 0 ],
            size: [ true, 50 ]
        };
        this.setOptions(options);
        this.setupSurfaces();
        this.setupEvent();
        this.buttonsClickEvents();
        this.isEditingMode = false;
        this.areEditingMode = false;
        this.returnZeroOpacityTransition = {
            curve: Easing.linearNorm,
            duration: 100
        };
        this.wallTransition = {
            method: "wall",
            period: 300,
            dampingRatio: 1
        };
        Engine.on("resize", this.resizeItem.bind(this));
    }
    ItemView.prototype = Object.create(RowView.prototype);
    ItemView.prototype.constructor = ItemView;
    ItemView.prototype.setupEvent = function() {
        var sync = new GenericSync(function() {
            return this.pos;
        }.bind(this), {
            syncClasses: [ MouseSync, TouchSync ]
        });
        this.itemSurface.pipe(sync);
        this.itemSurface.pipe(this._eventOutput);
        this.pos = [ 0, 0 ];
        sync.on("start", function() {
            this.pos = this.isEditingMode ? [ this.options.nButtons * this.options.buttonSizeX, 0 ] : [ 0, 0 ];
            this._directionChosen = false;
            this.clickTimeout = setTimeout(function() {
                this.itemSurface.setProperties({
                    backgroundColor: "rgba(255,255,255,0.1)"
                });
            }.bind(this), 100);
        }.bind(this));
        sync.on("update", function(data) {
            if (this.clickTimeout) {
                clearTimeout(this.clickTimeout);
                delete this.clickTimeout;
            }
            this.itemSurface.setProperties({
                backgroundColor: "transparent"
            });
            this.pos = data.p;
            // the displacement from the start touch point.
            if (Helpers.isMobile() && !this._directionChosen) {
                var diffX = this.isEditingMode ? Math.abs(this.pos[0] - this.options.nButtons * this.options.buttonSizeX) : Math.abs(this.pos[0]), diffY = Math.abs(this.pos[1]);
                this.direction = diffX > diffY ? Utility.Direction.X : Utility.Direction.Y;
                this._directionChosen = true;
                if (this.direction == Utility.Direction.X) {
                    this.itemSurface.unpipe(this._eventOutput);
                } else {
                    this.itemSurface.pipe(this._eventOutput);
                }
            } else {
                if (!Helpers.isMobile() || this.direction == Utility.Direction.X) {
                    this.animateItem();
                    this.animateLeftButtons();
                    this.animateRightButtons();
                }
            }
        }.bind(this));
        sync.on("end", function(data) {
            setTimeout(function() {
                this.itemSurface.setProperties({
                    backgroundColor: "transparent"
                });
            }.bind(this), 300);
            this.pos = data.p;
            if (Helpers.isMobile() && this.direction != Utility.Direction.X) return;
            if (this.pos[0] > this.options.nButtons * this.options.buttonSizeX) {
                this.toggleEditing();
            } else {
                this.setEditingOff();
            }
            if (this.pos[0] < -.33 * window.innerWidth) {
                this._eventOutput.emit(this.options.rightButton.event, this.model);
                this.setEditingOff();
            }
        }.bind(this));
    };
    ItemView.prototype.setOptions = function(options) {
        _.extend(this.options, options);
        this.options.nButtons = options.leftButtons ? options.leftButtons.length : 0;
    };
    ItemView.prototype.setupSurfaces = function() {
        //        var bc = this.model.collection.indexOf(this.model)%2 ? 0.1 : 0.2;
        this.backgroundSurface = new Surface({
            content: Templates.itemFrame(this.options.paddingLeft, this.options.paddingRight),
            size: this.options.size,
            properties: {
                zIndex: -1
            }
        });
        this.surfaces.add(this.backgroundSurface);
        _(this.options.leftButtons).each(function(b, i) {
            this["leftButton" + i] = new Surface({
                content: b.content,
                size: [ this.options.buttonSizeX, this.options.buttonSizeY ]
            });
            this["leftButton" + i + "Mod"] = new Modifier({
                origin: this.options._leftEndOrigin,
                opacity: 0,
                transform: Transform.translate(this.options.paddingLeft + this.options.buttonSizeX * i, 0, 0)
            });
            this["leftButton" + i].pipe(this._eventOutput);
            this.surfaces.add(this["leftButton" + i + "Mod"]).add(this["leftButton" + i]);
        }.bind(this));
        if (this.options.rightButton) {
            this.rightButton = new Surface({
                content: this.options.rightButton.content,
                size: [ this.options.buttonSizeX, this.options.buttonSizeY ]
            });
            this.rightButtonMod = new Modifier({
                origin: this.options._rightEndOrigin,
                opacity: 0,
                transform: Transform.translate(-this.options.paddingRight, 0, 0)
            });
            this.surfaces.add(this.rightButtonMod).add(this.rightButton);
        }
        this.itemSurface = new Surface({
            classes: this.options.itemButton.classes,
            content: this.options.itemButton.content,
            size: this.options.size,
            properties: {
                backgroundColor: "transparent",
                zIndex: 9
            }
        });
        this.itemMod = new Modifier({
            origin: this.options._leftEndOrigin
        });
        this.surfaces.add(this.itemMod).add(this.itemSurface);
    };
    ItemView.prototype.updateItem = function() {
        this.itemSurface.setContent(Templates.recentItemView(this.model));
    };
    ItemView.prototype.animateItem = function() {
        this.itemMod.setTransform(Transform.translate(this.pos[0], 0, 0));
    };
    ItemView.prototype.animateItemEnd = function() {
        var translate = Transform.identity;
        if (this.isEditingMode) {
            translate = Transform.translate(this.options.nButtons * this.options.buttonSizeX, 0, 0);
        } else {
            translate = Transform.translate(0, 0, 0);
        }
        this.itemMod.setTransform(translate, this.wallTransition);
    };
    ItemView.prototype.animateLeftButtons = function() {
        for (var i = 0; i < this.options.nButtons; i++) {
            var Opacity = Math.min((this.pos[0] - this.options.buttonSizeX * i) / this.options.buttonSizeX, 1);
            this["leftButton" + i + "Mod"].setOpacity(Opacity);
        }
    };
    ItemView.prototype.animateLeftButtonsEnd = function() {
        for (var i = 0; i < this.options.nButtons; i++) {
            if (this.isEditingMode) {
                this["leftButton" + i + "Mod"].setOpacity(1, this.returnZeroOpacityTransition);
            } else {
                this["leftButton" + i + "Mod"].setOpacity(0, this.returnZeroOpacityTransition);
            }
        }
    };
    ItemView.prototype.animateRightButtons = function() {
        if (this.rightButton && this.pos[0] < 0) {
            this.rightButtonMod.setOpacity(Math.min(-1 * this.pos[0] / (.5 * window.innerWidth), 1));
        }
    };
    ItemView.prototype.animateRightButtonsEnd = function() {
        if (this.rightButton) this.rightButtonMod.setOpacity(0, this.returnZeroOpacityTransition);
    };
    ItemView.prototype.resizeItem = function() {
        if (this.itemSurface._currTarget) this.itemSurface._currTarget.children[0].style.width = window.innerWidth + "px";
        if (this.backgroundSurface._currTarget) {
            this.backgroundSurface._currTarget.children[0].style.width = window.innerWidth - this.options.paddingLeft - this.options.paddingRight + "px";
        }
    };
    ItemView.prototype.setEditingOn = function() {
        this.isEditingMode = true;
        this.animateItemEnd();
        this.animateLeftButtonsEnd();
        this.animateRightButtonsEnd();
    };
    ItemView.prototype.setEditingOff = function() {
        setTimeout(function() {
            this.isEditingMode = false;
            this.animateItemEnd();
            this.animateLeftButtonsEnd();
            this.animateRightButtonsEnd();
        }.bind(this), 100);
    };
    ItemView.prototype.toggleEditing = function() {
        this.isEditingMode = !this.isEditingMode;
        this.animateItemEnd();
        this.animateLeftButtonsEnd();
        this.animateRightButtonsEnd();
    };
    ItemView.prototype.onToggleAll = function() {
        //    console.log('toggleAll');
        if (this.areEditingMode == false) {
            this.setEditingOn();
        } else {
            this.setEditingOff();
        }
        this.areEditingMode = !this.areEditingMode;
    };
    ItemView.prototype.buttonsClickEvents = function() {
        _(this.options.leftButtons).each(function(b, i) {
            this["leftButton" + i].on("click", function(b) {
                //            console.log(b.event);
                this._eventOutput.emit(b.event, this.model);
            }.bind(this, b));
        }.bind(this));
        this.itemSurface.on("click", function() {
            if (this.pos[0] == 0 && this.pos[1] == 0 && this.isEditingMode == false) {
                this._eventOutput.emit(this.options.itemButton.event, this.model);
            }
        }.bind(this));
        this._eventInput.on("backToNoneEditing", function() {
            this.areEditingMode = false;
        }.bind(this));
    };
    module.exports = ItemView;
}.bind(this));

require.register("app/custom/row-view/row-view.js", function(exports, require, module) {
    var RenderNode = require("famous/render-node");
    var View = require("famous/view");
    var Modifier = require("famous/modifier");
    function RowView(options) {
        View.apply(this, arguments);
        this.surfaces = new RenderNode();
        this.surfacesMod = new Modifier();
        this._node.add(this.surfacesMod).add(this.surfaces);
    }
    RowView.prototype = Object.create(View.prototype);
    RowView.prototype.constructor = RowView;
    RowView.prototype.collapse = function(callback) {
        this.surfacesMod.setOpacity(0, {
            duration: 300
        }, callback);
    };
    RowView.prototype.expand = function(callback) {
        this.surfacesMod.setOpacity(1, {
            duration: 300
        }, callback);
    };
    RowView.prototype.getSize = function() {
        var sh = this.surfacesMod.opacityState.get();
        return [ this.options.size[0], Math.floor(this.options.size[1] * sh) || 0 ];
    };
    module.exports = RowView;
}.bind(this));

require.register("app/views/add-contact-view.js", function(exports, require, module) {
    // import famous modules
    var HeaderFooterLayout = require("famous/views/header-footer-layout");
    var Surface = require("famous/surface");
    var EventHandler = require("famous/event-handler");
    var View = require("famous/view");
    var EdgeSwapper = require("famous/views/edge-swapper");
    //import custom modules
    var UpDownTransform = require("up-down-transform");
    var Templates = require("templates");
    var Helpers = require("helpers");
    // import models
    var Models = require("models");
    var Contact = Models.Contact;
    var SocialContactCollection = Models.SocialContactCollection;
    // import views
    var ImportContactView = require("import-contact-view");
    function AddContactView(options) {
        View.call(this);
        this.formObject = {};
        this.socialCollection = {};
        this.socialView = {};
        this.headerFooterLayout = new HeaderFooterLayout({
            headerSize: 50,
            footerSize: 0
        });
        var upDownTransform = new UpDownTransform();
        if (options.inTransform === undefined) this.options.inTransform = upDownTransform.options.inTransform;
        if (options.outTransform === undefined) this.options.outTransform = upDownTransform.options.outTransform;
        if (options.inTransition === undefined) this.options.inTransition = upDownTransform.options.inTransition;
        if (options.outTransition === undefined) this.options.outTransition = upDownTransform.options.outTransition;
        if (options.inOpacity === undefined) this.options.inOpacity = upDownTransform.options.inOpacity;
        if (options.outOpacity === undefined) this.options.outOpacity = upDownTransform.options.outOpacity;
        this.options.showOrigin = [ 0, 0 ];
        this.options.inOrigin = [ 0, 0 ];
        this.options.outOrigin = [ 0, 0 ];
        this.model = options.model;
        // Set up event handlers
        // this.eventInput = new EventHandler();
        // EventHandler.setInputHandler(this, this.eventInput);
        // this.eventOutput = new EventHandler();
        // EventHandler.setOutputHandler(this, this.eventOutput);
        this.header = new Surface({
            classes: [ "header" ],
            size: [ undefined, 50 ],
            properties: {}
        });
        this.content = new Surface({
            classes: [ "add-contact-view" ],
            size: [ undefined, undefined ],
            properties: {
                padding: "20px",
                backgroundColor: "transparent"
            }
        });
        this.headerFooterLayout.id.header.add(this.header);
        this.headerFooterLayout.id.content.add(this.content);
        var edgeSwapper = new EdgeSwapper();
        this._add(edgeSwapper);
        edgeSwapper.show(this.headerFooterLayout);
        this.content.pipe(this._eventOutput);
        this.header.pipe(this._eventOutput);
        this.renderContact();
        this.header.on("click", function(e) {
            var target = $(e.target);
            if (target.hasClass("done-contact")) {
                this.submitForm();
                $("body").removeClass("editing");
                this._eventOutput.emit("triggerBackToNoneEditing");
                this._eventOutput.emit("showApp");
            } else if (target.hasClass("close-button")) {
                this._eventOutput.emit("showApp");
            }
        }.bind(this));
        this.collection = options.collection;
        this.content.on("click", function(e) {
            var target = $(e.target);
            function onDataHandler() {
                if (!this.socialView[source]) {
                    if (_.isArray(this.socialCollection[source].models)) {
                        //TODO: pull collections from server
                        this.socialView[source] = new ImportContactView({
                            title: Helpers.capitalize(source),
                            collection: this.socialCollection[source]
                        });
                        this.socialView[source].pipe(this._eventOutput);
                    } else {
                        alert("Your " + source + " contact list is empty.");
                        return;
                    }
                }
                edgeSwapper.show(this.socialView[source], true);
            }
            function onErrorHandler() {
                this._eventOutput.emit("onSocialLink", source);
                delete this.socialCollection[source];
            }
            if (target.hasClass("import-contact")) {
                var source = target[0].id;
                if (!this.socialCollection[source]) {
                    this.socialCollection[source] = new SocialContactCollection();
                    this.socialCollection[source].url = "/contact/" + source;
                    this.socialCollection[source].fetch({
                        success: onDataHandler.bind(this),
                        error: onErrorHandler.bind(this)
                    });
                } else {
                    onDataHandler.bind(this)();
                }
            } else if (target.hasClass("remove-button")) {
                var source = target[0].id;
                if (source) delete this.formObject[source];
                this.renderContact();
            }
        }.bind(this));
        //        this.eventOutput.on('importSource', onImportSource);
        this._eventOutput.on("goBack", onGoBack);
        function onImportSource(eventData) {
            if (!eventData || !eventData.attributes) return;
            this.getFormObject();
            if (eventData.attributes.provider) {
                this.formObject[eventData.attributes.provider] = eventData.attributes;
            } else {
                this.formObject = _.extend(this.formObject, eventData.attributes);
            }
            this.formObject.firstname = this.formObject.firstname ? this.formObject.firstname : eventData.attributes.firstname;
            this.formObject.lastname = this.formObject.lastname ? this.formObject.lastname : eventData.attributes.lastname;
            this.formObject.email = this.formObject.email ? this.formObject.email : eventData.attributes.email;
            this.renderContact();
        }
        function onGoBack(eventData) {
            edgeSwapper.show(this.headerFooterLayout, true, function() {
                onImportSource.bind(this)(eventData);
            }.bind(this));
        }
    }
    AddContactView.prototype = Object.create(View.prototype);
    AddContactView.prototype.constructor = AddContactView;
    AddContactView.prototype.renderContact = function() {
        var html = '<div class="initial">' + this.initial + "</div>";
        html += '<form role="form">';
        html += '<div class="form-group small">';
        html += '<input type="text" class="form-control" id="input-first-name" placeholder="First" name="firstname"';
        if (this.formObject.firstname) html += ' value="' + this.formObject.firstname + '"';
        html += "></div>";
        html += '<div class="form-group small">';
        html += '<input type="text" class="form-control" id="input-last-name" placeholder="Last" name="lastname"';
        if (this.formObject.lastname) html += ' value="' + this.formObject.lastname + '"';
        html += "></div>";
        html += '<div class="form-group small">';
        html += '<input type="email" class="form-control" id="input-email" placeholder="Email" name="email"';
        if (this.formObject.email) {
            html += ' value="' + this.formObject.email + '">';
            html += Templates.getEmailInvite(this.formObject);
            html += "</div>";
        } else {
            html += "></div>";
        }
        html += '<div class="form-group small">';
        html += '<input type="phone" class="form-control" id="input-phone" placeholder="Phone" name="phone"';
        if (this.formObject.phone) {
            html += ' value="' + this.formObject.phone + '">';
            html += Templates.getSMSInvite(this.formObject);
            html += "</div>";
        } else {
            html += "></div>";
        }
        //TODO: this is a hack. we used the same class "import-contact" and id for a target.
        html += '<div class="box">';
        html += '<div class="info import-contact touchable" id="google"><i class="fa fa-google-plus-square fa-lg import-contact" id="google"></i>';
        if (this.formObject.google) {
            var obj = this.formObject.google;
            html += '<span class="import-contact touchable" id="google">  ' + obj.firstname + " " + obj.lastname + "</span>";
            html += Templates.removeButton("google") + "</div>";
        } else {
            html += '<span class="import-contact touchable" id="google">  New Google Contact</span>';
            html += Templates.nextButton("google") + "</div>";
        }
        html += '<div class="info import-contact touchable" id="facebook"><i class="fa fa-facebook-square fa-lg import-contact" id="facebook"></i>';
        if (this.formObject.facebook) {
            var obj = this.formObject.facebook;
            html += '<span class="import-contact touchable" id="facebook">  ' + obj.firstname + " " + obj.lastname + "</span>";
            html += Templates.removeButton("facebook");
            html += Templates.getFacebookInvite(this.formObject) + "</div>";
        } else {
            html += '<span class="import-contact touchable" id="facebook">  New Facebook Contact</span>';
            html += Templates.nextButton("facebook") + "</div>";
        }
        html += "</form>";
        this.content.setContent(html);
        var html = Templates.editContactHeader(this.title);
        this.header.setContent(html);
    };
    AddContactView.prototype.getFormObject = function() {
        var formArr = $(".add-contact-view form").serializeArray();
        var formContact = {};
        for (var i in formArr) {
            if (formArr[i].name) formContact[formArr[i].name] = formArr[i].value;
        }
        this.formObject = _.extend(this.formObject, formContact);
        // remove undefined attributes
        for (var i in this.formObject) {
            if (this.formObject[i] === undefined) delete this.formObject[i];
        }
        return this.formObject;
    };
    AddContactView.prototype.submitForm = function() {
        var formContact = this.getFormObject();
        if (this.title == "Edit Contact") {
            this.model.set(formContact);
            this._eventOutput.emit("submitContact", this.model);
        } else {
            this.collection.add(formContact);
            this._eventOutput.emit("submitContact", new Contact(formContact));
        }
        // trigger contact list redraw
        this.collection.trigger("sync");
    };
    AddContactView.prototype.setContact = function(model) {
        if (model && model instanceof Contact) {
            this.formObject = _.omit(model.attributes, "id");
            this.title = "Edit Contact";
            this.initial = "";
            if (this.formObject.firstname) this.initial = this.formObject.firstname[0];
            if (this.formObject.lastname) this.initial += this.formObject.lastname[0];
            this.model = model;
        } else {
            this.formObject = {};
            if (model) this.formObject = _.omit(model.attributes, "id");
            this.title = "New Contact";
            this.initial = '<i class="fa fa-user fa-lg"></i>';
        }
    };
    module.exports = AddContactView;
}.bind(this));

require.register("app/views/alert-view.js", function(exports, require, module) {
    // Import core Famous dependencies
    var View = require("famous/view");
    var Surface = require("famous/surface");
    var EventHandler = require("famous/event-handler");
    var Transform = require("famous/transform");
    var Easing = require("famous/transitions/easing");
    var LightBox = require("light-box");
    function AlertView(message, okHidden) {
        View.call(this);
        // Set up event handlers
        // this.eventInput = new EventHandler();
        // EventHandler.setInputHandler(this, this.eventInput);
        // this.eventOutput = new EventHandler();
        // EventHandler.setOutputHandler(this, this.eventOutput);
        this.options = {
            inTransform: Transform.identity,
            //            inOpacity: 1,
            //            inOrigin: [0.5, 0.5],
            outTransform: Transform.identity,
            //            outOpacity: 1,
            //            outOrigin: [0.5, 0.5],
            showTransform: Transform.identity,
            //            showOpacity: 1,
            //            showOrigin: [0.5, 0.5],
            inTransition: {
                duration: 100
            },
            outTransition: {
                duration: 100
            },
            overlap: true
        };
        this.bigSurface = new Surface({
            size: [ undefined, undefined ],
            properties: {
                background: "rgba(0,0,0,0.5)",
                zIndex: 1e3
            }
        });
        this.alertSurface = new Surface({
            classes: [ "alert" ],
            size: [ 340, 220 ],
            properties: {
                borderRadius: "10px",
                background: "rgba(59, 59, 59, 0.90)",
                color: "rgba(245, 236, 236,1)",
                //                textAlign: "center",
                zIndex: 1001
            }
        });
        this.alertLightBox = new LightBox({
            inTransform: Transform.identity,
            inOpacity: .1,
            inOrigin: [ .5, .45 ],
            outTransform: Transform.scale(.001, .001, .001),
            outOpacity: 1,
            outOrigin: [ .5, .45 ],
            showTransform: Transform.identity,
            showOpacity: 1,
            showOrigin: [ .5, .45 ],
            inTransition: {
                duration: 200,
                curve: Easing.inQuad()
            },
            outTransition: {
                duration: 100,
                curve: Easing.outQuint()
            }
        });
        this.setAlertMessage(message, okHidden);
        this._add(this.bigSurface);
        this._add(this.alertLightBox);
        this.alertLightBox.show(this.alertSurface);
    }
    AlertView.prototype = Object.create(View.prototype);
    AlertView.prototype.constructor = AlertView;
    AlertView.prototype.setAlertMessage = function(message, okHidden) {
        var content = [ '<div class="alert-title"><b>Beepe</b></div><div id="message">', message, "</div>" ];
        if (!okHidden) content.push('<div id="close-alert"> OK </div>');
        this.alertSurface.setContent(content.join(""));
    };
    module.exports = AlertView;
}.bind(this));

require.register("app/views/camera-view.js", function(exports, require, module) {
    // Import core Famous dependencies
    var View = require("famous/view");
    var Surface = require("famous/surface");
    var EventHandler = require("famous/event-handler");
    var Modifier = require("famous/modifier");
    var Transform = require("famous/transform");
    function CameraView(options) {
        View.call(this);
        this.model = options.model;
        navigator.getUserMedia = navigator.getUserMedia || navigator.webkitGetUserMedia || navigator.mozGetUserMedia;
        // Set up event handlers
        // this.eventInput = new EventHandler();
        // EventHandler.setInputHandler(this, this.eventInput);
        // this.eventOutput = new EventHandler();
        // EventHandler.setOutputHandler(this, this.eventOutput);
        var videoHtml = '<div class="camera local-video blur off">';
        if (navigator.getUserMedia) videoHtml += '<video muted="true" autoplay poster="content/images/transparent.png"></video>';
        videoHtml += "</div>";
        this.localVideoSurface = new Surface({
            content: videoHtml
        });
        var videoHtml = '<div class="camera remote-video">';
        if (navigator.getUserMedia) videoHtml += '<video autoplay poster="content/images/transparent.png"></video>';
        videoHtml += "</div>";
        this.remoteVideoSurface = new Surface({
            properties: {
                zIndex: -3
            },
            content: videoHtml
        });
        this.localVideoSurface.pipe(this._eventOutput);
        this.remoteVideoSurface.pipe(this._eventOutput);
        this.transform = new Modifier({
            origin: [ .9, .1 ]
        });
        this._add(new Modifier({
            transform: Transform.translate(0, 0, -5)
        })).add(this.remoteVideoSurface);
        this._add(this.transform).add(this.localVideoSurface);
        this.turnOff();
    }
    CameraView.prototype = Object.create(View.prototype);
    CameraView.prototype.constructor = CameraView;
    CameraView.prototype.turnOn = function() {
        $(".remote-video").show();
        this.transform.setTransform(Transform.move(Transform.scale(.25, .25), [ 0, 0, -5 ]), {
            duration: 500
        });
    };
    CameraView.prototype.turnOff = function() {
        $(".remote-video").hide();
        this.transform.setTransform(Transform.move(Transform.scale(1, 1), [ 0, 0, -5 ]), {
            duration: 500
        });
    };
    module.exports = CameraView;
}.bind(this));

require.register("app/views/chat-item-view.js", function(exports, require, module) {
    var Templates = require("templates");
    var RowView = require("row-view");
    var ItemView = RowView.ItemView;
    function ChatItemView(options) {
        options.leftButtons = [ {
            content: Templates.crossButton(),
            event: "deleteItem"
        }, {
            content: Templates.editButton(),
            event: "editContact"
        } ];
        options.rightButton = {
            content: Templates.phoneButton(),
            event: "outgoingCall"
        };
        options.itemButton = {
            classes: [ "contact-item", "chat-item" ],
            content: Templates.chatItemView(options.model),
            event: "chatContact"
        };
        options.buttonSizeY = 60;
        options.size = [ true, 60 ];
        ItemView.apply(this, arguments);
        this._eventInput.on("toggleAllChat", this.onToggleAll.bind(this));
        this._eventInput.on("backToNoneEditing", this.setEditingOff.bind(this));
    }
    ChatItemView.prototype = Object.create(ItemView.prototype);
    ChatItemView.prototype.constructor = ChatItemView;
    ChatItemView.prototype.updateItem = function() {
        this.itemSurface.setContent(Templates.chatItemView(this.model));
    };
    module.exports = ChatItemView;
}.bind(this));

require.register("app/views/chats-section-view.js", function(exports, require, module) {
    // Import core Famous dependencies
    var View = require("famous/view");
    var Utility = require("famous/utilities/utility");
    var Surface = require("famous/surface");
    var VerticalScrollView = require("vertical-scroll-view");
    var Engine = require("famous/engine");
    var Templates = require("templates");
    var ChatItemView = require("chat-item-view");
    function ChatsSectionView(options) {
        View.call(this);
        this.title = Templates.chatsHeader();
        this.navigation = {
            caption: "Messages",
            icon: '<i class="fa fa-comments-o"></i>'
        };
        this.collection = options.collection;
        this.scrollview = new VerticalScrollView({
            startAt: "top"
        });
        this.pipe(this.scrollview);
        this._add(this.scrollview);
        this.scrollview.sequenceFrom([]);
        this.collection.on("all", function(e, model, collection, options) {
            //        console.log('chats ',e);
            switch (e) {
              case "remove":
                var index = options.index;
                console.log(index);
                this.scrollview.removeByIndex(index);
                break;

              case "add":
                this.addItem(model);
                this.collection.sort();
                this.scrollview.sortBy(function(item) {
                    return -1 * item.model.get("time");
                });
                break;

              case "change":
                this.collection.sort();
                this.scrollview.sortBy(function(item) {
                    return -1 * item.model.get("time");
                });
                break;
            }
            this.updateItems();
        }.bind(this));
    }
    ChatsSectionView.prototype = Object.create(View.prototype);
    ChatsSectionView.prototype.constructor = ChatsSectionView;
    ChatsSectionView.prototype.updateItems = function() {
        _.each(this.scrollview.node.array, function(itemView) {
            if (itemView.updateItem) itemView.updateItem();
        });
    };
    ChatsSectionView.prototype.loadItems = function() {
        //    this.collection.fetch();
        this.scrollview.setPosition(0);
        this.sequence = this.collection.map(function(item) {
            var surface = new ChatItemView({
                model: item
            });
            surface.pipe(this._eventOutput);
            this._eventInput.pipe(surface);
            return surface;
        }.bind(this));
        this.scrollview.sequenceFrom(this.sequence);
    };
    ChatsSectionView.prototype.addItem = function(call) {
        var surface = new ChatItemView({
            model: call
        });
        surface.pipe(this._eventOutput);
        this._eventInput.pipe(surface);
        this.scrollview.addByIndex(0, surface);
    };
    ChatsSectionView.prototype.removeItemByIndex = function(index) {
        this.scrollview.removeByIndex(index);
    };
    module.exports = ChatsSectionView;
}.bind(this));

require.register("app/views/connected-call-view.js", function(exports, require, module) {
    var View = require("famous/view");
    var Transform = require("famous/transform");
    var Surface = require("famous/surface");
    var EventHandler = require("famous/event-handler");
    var Templates = require("templates");
    var Call = require("models").Call;
    var ConversationView = require("conversation-view");
    var duration = 500;
    function ConnectedCallView(options) {
        View.call(this);
        this.collection = options.collection;
        this._eventOutput.on("menu-toggle-button", this.onMenuToggleButton);
        this.conversationView = new ConversationView();
        this.conversationView.pipe(this._eventOutput);
        this._eventInput.pipe(this.conversationView);
        this._add(this.conversationView);
    }
    ConnectedCallView.prototype = Object.create(View.prototype);
    ConnectedCallView.prototype.constructor = ConnectedCallView;
    ConnectedCallView.prototype.start = function(appSetting, call) {
        this.conversationView.start(appSetting, call);
        this.model = this.collection.models[0] || new Call();
        this.appSettings = appSetting;
        $(".camera").removeClass("blur");
    };
    ConnectedCallView.prototype.stop = function(evt) {
        this._eventOutput.emit("outgoingCallEnd", this.model);
        this._eventOutput.emit("incomingCallEnd", this.model);
        if (evt.exit) {
            this._eventOutput.emit("showApp");
        }
        this.conversationView.stop(evt);
    };
    module.exports = ConnectedCallView;
}.bind(this));

require.register("app/views/contact-item-view.js", function(exports, require, module) {
    var Templates = require("templates");
    var RowView = require("row-view");
    var ItemView = RowView.ItemView;
    function ContactItemView(options) {
        this.model = options.model;
        options.paddingRight = 40;
        options.leftButtons = [ {
            content: Templates.crossButton(),
            event: "deleteItem"
        }, {
            content: Templates.editButton(),
            event: "editContact"
        } ];
        options.rightButton = {
            content: Templates.phoneButton(),
            event: "outgoingCall"
        };
        options.itemButton = {
            classes: [ "contact-item", "editable" ],
            content: Templates.contactItemView(options.model),
            //        event: 'editContact'
            event: "chatContact"
        };
        ItemView.apply(this, arguments);
        this.model.on("all", function(e, model, collection, options) {
            switch (e) {
              case "change:favorite":
                $(this["leftButton1"]._currTarget).find(".favorite-button").toggleClass("active");
                break;
            }
        }.bind(this));
        this._eventInput.on("toggleAllContact", this.onToggleAll.bind(this));
        this._eventInput.on("backToNoneEditing", this.setEditingOff.bind(this));
        this.model.on("change", function() {
            this.changeItem();
        }.bind(this));
    }
    ContactItemView.prototype = Object.create(ItemView.prototype);
    ContactItemView.prototype.constructor = ContactItemView;
    ContactItemView.prototype.changeItem = function() {
        this.itemSurface.setContent(Templates.contactItemView(this.model));
    };
    module.exports = ContactItemView;
}.bind(this));

require.register("app/views/contacts-scroll-view.js", function(exports, require, module) {
    // import famous modules
    var View = require("famous/view");
    var HeaderFooterLayout = require("famous/views/header-footer-layout");
    var Utility = require("famous/utilities/utility");
    var Modifier = require("famous/modifier");
    var GenericSync = require("famous/input/generic-sync");
    var Surface = require("famous/surface");
    var Easing = require("famous/transitions/easing");
    // import custom modules
    var InputSync = require("custom-input-sync");
    var TouchSync = InputSync.TouchSync;
    var MouseSync = InputSync.MouseSync;
    var Templates = require("templates");
    var Transform = require("famous/transform");
    // import views
    var VerticalScrollView = require("vertical-scroll-view");
    var ContactItemView = require("contact-item-view");
    var RowView = require("row-view");
    var HeaderView = RowView.HeaderView;
    function ContactsScrollView(options) {
        View.call(this);
        this.sortKey = "lastname";
        this.searchKey = false;
        this.abcArray = "ABCDEFGHIJKLMNOPQRSTUVWXYZ#";
        this.setupLayout(options);
        this.renderHeaders();
        this.prepareSequences();
        this.collectionEvents();
        this.abcSurfaceEvents();
        this.searchSurfaceEvents();
    }
    ContactsScrollView.prototype = Object.create(View.prototype);
    ContactsScrollView.prototype.constructor = ContactsScrollView;
    ContactsScrollView.prototype.collectionEvents = function() {
        this.collection.on("all", function(e, model) {
            //        console.log('contacts ',e)
            switch (e) {
              case "change":
                this.changeItem(model);
                break;

              case "remove":
                this.removeItem(model);
                this.renderHeaders();
                break;

              case "add":
                this.addItem(model);
                break;

              case "sync":
                this.renderHeaders();
                // prevent collapse animation at init.
                setTimeout(this.renderScrollView.bind(this), this.scrollview.node.array.length > 1 ? 0 : 1e3);
                break;
            }
        }.bind(this));
    };
    ContactsScrollView.prototype.prepareSequences = function() {
        this.contactSequence = [];
        this.headerSequence = _.map("ABCDEFGHIJKLMNOPQRSTUVWXYZ#", function(i) {
            var headerSurface = new HeaderView({
                content: Templates.headerItemView(i, 0, 0),
                header: i
            });
            headerSurface.pipe(this.scrollview);
            return headerSurface;
        }.bind(this));
    };
    ContactsScrollView.prototype.setupLayout = function(options) {
        this.searchBarSize = 50;
        this.abcSurfaceWidth = 30;
        this.abcSurfaceHeight = undefined;
        this.headerFooterLayout = new HeaderFooterLayout({
            headerSize: this.searchBarSize,
            footerSize: 0
        });
        this.LayoutMod = new Modifier();
        this.searchSurface = new Surface({
            size: [ undefined, this.searchBarSize ],
            classes: [ "contact-section-search-bar" ],
            content: '<div><i class="fa fa-search"></i>   ' + '<input type="text" class="search-contact" placeholder = "Search" ><span class="cancel">cancel</span></input></div></div>',
            properties: {
                backgroundColor: "rgba(15,15,15,0.9)",
                color: "white",
                zIndex: 10
            }
        });
        this.searchSurfaceMod = new Modifier({
            transform: Transform.translate(0, 0, 3)
        });
        this.searhBarTransition = {
            duration: 0
        };
        this.searchMode = false;
        this.abcSurface = new Surface({
            size: [ this.abcSurfaceWidth, this.abcSurfaceHeight ],
            classes: [ "abcButton" ],
            content: Templates.abcButtons(),
            properties: {
                backgroundColor: "rgba(160,160,160,0.0)",
                zIndex: 2
            }
        });
        this._eventInput.pipe(this.searchSurface);
        this.abcMod = new Modifier({
            origin: [ 1, 0 ],
            transform: Transform.translate(0, 0, 10)
        });
        this.title = '<button class="left edit-button" id="contact-edit-contact"></button><div>All Contacts</div><button class="right add-contact" id="add-contact"><i class="fa fa-plus" id="add-contact"></i></button>';
        this.navigation = {
            caption: "Contacts",
            icon: '<i class="fa fa-users"></i>'
        };
        this.collection = options.collection;
        this.scrollview = new VerticalScrollView();
        this.scrollview.sequenceFrom([]);
        this.headerFooterLayout.id.header.add(this.searchSurfaceMod).add(this.searchSurface);
        this.headerFooterLayout.id.content.add(this.scrollview);
        this.headerFooterLayout.id.content.add(this.abcMod).add(this.abcSurface);
        this.pipe(this.scrollview);
        this._add(this.LayoutMod).add(this.headerFooterLayout);
    };
    ContactsScrollView.prototype.renderScrollView = function() {
        var sequence = this.headerSequence.concat(this.contactSequence);
        var newSequence = arrangeSequence(sequence, sortBy(this.sortKey), searchBy(this.searchKey));
        this.scrollview.sequenceFrom(newSequence);
    };
    function sortBy(key) {
        key = key || "lastname";
        return function(item) {
            var l, f, h;
            l = f = h = "";
            // " " is the earliest char
            if (item.model) l = item.model.get("lastname") || "#";
            if (item.model) f = item.model.get("firstname") || "#";
            if (item.options && item.options.header) h = item.options.header;
            var str;
            if (key.toLowerCase() == "firstname") str = h + f + " " + l; else str = h + l + " " + f;
            // "{" is the next char after "z"
            if (!/^[a-zA-Z]+$/.test(str[0])) str = "{" + str;
            return str.toUpperCase();
        };
    }
    function searchBy(key) {
        return function(item) {
            if (!key) return key === false; else {
                key = key.toLowerCase();
                if (!item.model) return false;
                if (item.model.get("firstname").toLowerCase().indexOf(key) != -1 || item.model.get("lastname").toLowerCase().indexOf(key) != -1) return true;
            }
            return false;
        };
    }
    function arrangeSequence(sequence, sortFunction, searchFunction) {
        return _.chain(sequence).filter(searchFunction).sortBy(sortFunction).value();
    }
    ContactsScrollView.prototype.createItem = function(item) {
        var surface = new ContactItemView({
            model: item
        });
        surface.pipe(this._eventOutput);
        this._eventInput.pipe(surface);
        return surface;
    };
    ContactsScrollView.prototype.addItem = function(item) {
        var newContact = this.createItem(item);
        this.contactSequence.push(newContact);
    };
    ContactsScrollView.prototype.removeItem = function(item) {
        var i = this.contactSequence.map(function(i) {
            return i.model;
        }).indexOf(item);
        this.contactSequence.splice(i, 1);
        var i = this.scrollview.node.array.map(function(i) {
            return i.model;
        }).indexOf(item);
        this.scrollview.removeByIndex(i);
    };
    ContactsScrollView.prototype.changeItem = function(item) {};
    ContactsScrollView.prototype.abcSurfaceEvents = function() {
        var mousePosition = [ 0, 0 ];
        var sync = new GenericSync(function() {
            return mousePosition;
        }, {
            syncClasses: [ MouseSync, TouchSync ]
        });
        this.abcSurface.pipe(sync);
        sync.on("start", function(data) {
            this.scrollToContact(data);
        }.bind(this));
        sync.on("update", function(data) {
            this.scrollToContact(data);
        }.bind(this));
    };
    ContactsScrollView.prototype.scrollToContact = function(data) {
        var target = document.elementFromPoint(data.ap[0], data.ap[1]);
        if (!target || !target.id) return;
        var i = this.abcArray.indexOf(target.id);
        var index = this.scrollview.node.array.indexOf(this.headerSequence[i]);
        this.scrollview.scrollTo(index, 0);
    };
    ContactsScrollView.prototype.searchSurfaceEvents = function() {
        this.searchSurface.on("click", function(e) {
            //        console.log(e);
            if (e.target.className == "search-contact") {
                this._eventInput.emit("searchOnFocus", e);
            } else if (e.target.className == "cancel") {
                this._eventInput.emit("searchOnCancel");
            }
        }.bind(this));
        this._eventInput.on("searchOnFocus", this.searchOnFocus.bind(this));
        this._eventInput.on("searchOnCancel", this.searchOnCancel.bind(this));
        this.searchSurface.on("keyup", function(e) {
            this.searchKey = this.getSearchKey();
            this.renderScrollView();
        }.bind(this));
    };
    ContactsScrollView.prototype.searchOnFocus = function(e) {
        this.searchKey = this.getSearchKey();
        if (!this.searchKey) {
            this._eventInput.emit("backToNoneEditing");
            this.abcSurface.setContent("");
            this.scrollview.scrollTo(0, 0);
            this.LayoutMod.setTransform(Transform.translate(0, -50, 0), this.searhBarTransition);
            this.searchSurface._currTarget.children[0].children[2].style.opacity = 1;
            this.searchSurface._currTarget.style.paddingRight = "100px";
            this.renderScrollView();
        }
    };
    ContactsScrollView.prototype.searchOnCancel = function() {
        this.abcSurface.setContent(Templates.abcButtons());
        this.LayoutMod.setTransform(Transform.translate(0, 0, 0), this.searhBarTransition);
        this.searchSurface._currTarget.children[0].children[2].style.opacity = 0;
        this.searchSurface._currTarget.style.paddingRight = "10px";
        document.getElementsByClassName("search-contact")[0].value = "";
        this.searchKey = this.getSearchKey();
        this.renderScrollView();
    };
    ContactsScrollView.prototype.renderHeaders = function() {
        var existedAbcArray = _.chain(this.collection.models).map(function(item) {
            return item.get(this.sortKey)[0] || "#";
        }.bind(this)).map(function(item) {
            return /^[a-zA-Z]+$/.test(item) ? item.toUpperCase() : "#";
        }).uniq().value();
        _.each(this.headerSequence, function(item) {
            existedAbcArray.indexOf(item.options.header) == -1 ? item.collapse() : item.expand();
        }.bind(this));
    };
    ContactsScrollView.prototype.getSearchKey = function() {
        if ($(document.activeElement).hasClass("search-contact")) return document.activeElement.value; else return false;
    };
    // TODO: search bar there is something blocking the seach input when focus
    module.exports = ContactsScrollView;
}.bind(this));

require.register("app/views/contacts-section-view.js", function(exports, require, module) {
    var ContactsScrollView = require("contacts-scroll-view");
    function ContactsSection(options) {
        ContactsScrollView.apply(this, arguments);
        this.title = '<button class="left edit-button touchable" id="contact-edit-contact"></button><div>All Contacts</div><button class="right add-contact touchable" id="add-contact"><i class="fa fa-plus" id="add-contact"></i></button>';
        this.navigation = {
            caption: "Contacts",
            icon: '<i class="fa fa-users"></i>'
        };
    }
    ContactsSection.prototype = Object.create(ContactsScrollView.prototype);
    ContactsSection.prototype.constructor = ContactsSection;
    module.exports = ContactsSection;
}.bind(this));

require.register("app/views/contacts-section-view2.js", function(exports, require, module) {
    // import famous modules
    var View = require("famous/view");
    var HeaderFooterLayout = require("famous/views/header-footer-layout");
    var Utility = require("famous/utilities/utility");
    var Modifier = require("famous/modifier");
    var GenericSync = require("famous/input/generic-sync");
    var Surface = require("famous/surface");
    var Easing = require("famous/transitions/easing");
    // import custom modules
    var InputSync = require("custom-input-sync");
    var TouchSync = InputSync.TouchSync;
    var MouseSync = InputSync.MouseSync;
    var Templates = require("templates");
    var Transform = require("famous/transform");
    // import views
    var VerticalScrollView = require("vertical-scroll-view");
    var ContactItemView = require("contact-item-view");
    var RowView = require("row-view");
    var HeaderView = RowView.HeaderView;
    function ContactsSection(options) {
        View.call(this);
        this.searchBarSize = 50;
        this.abcSurfaceWidth = 30;
        this.abcSurfaceHeight = undefined;
        this.a2zString = "ABCDEFGHIJKLMNOPQRSTUVWXYZ#";
        this.setupLayout(options);
        this.collectionEvents();
        this.abcSurfaceEvents();
        this.searchSurfaceEvents();
    }
    ContactsSection.prototype = Object.create(View.prototype);
    ContactsSection.prototype.constructor = ContactsSection;
    ContactsSection.prototype.setupLayout = function(options) {
        this.headerFooterLayout = new HeaderFooterLayout({
            headerSize: this.searchBarSize,
            footerSize: 0
        });
        this.LayoutMod = new Modifier();
        this.searchSurface = new Surface({
            size: [ undefined, this.searchBarSize ],
            classes: [ "contact-section-search-bar" ],
            content: '<div><i class="fa fa-search"></i>   ' + '<input type="text" class="search-contact" placeholder = "Search" ><span class="cancel">cancel</span></input></div></div>',
            properties: {
                backgroundColor: "rgba(15,15,15,0.9)",
                color: "white",
                zIndex: 10
            }
        });
        this.searchSurfaceMod = new Modifier({
            transform: Transform.translate(0, 0, 3)
        });
        this.searhBarTransition = {
            //        'curve' : Easing.linearNorm,
            duration: 0
        };
        this.searchMode = false;
        this.abcSurface = new Surface({
            size: [ this.abcSurfaceWidth, this.abcSurfaceHeight ],
            classes: [ "abcButton" ],
            content: '<button id="A">A</button><button id="B">B</button><button id="C">C</button><button id="D">D</button><button id="E">E</button><button id="F">F</button><button id="G">G</button><button id="H">H</button><button id="I">I</button><button id="J">J</button><button id="K">K</button><button id="L">L</button><button id="M">M</button><button id="N">N</button><button id="O">O</button><button id="P">P</button><button id="Q">Q</button><button id="R">R</button><button id="S">S</button><button id="T">T</button><button id="U">U</button><button id="V">V</button><button id="W">W</button><button id="X">X</button><button id="Y">Y</button><button id="Z">Z</button><button id="#">#</button>',
            properties: {
                backgroundColor: "rgba(160,160,160,0.0)",
                zIndex: 2
            }
        });
        this._eventInput.pipe(this.searchSurface);
        this.abcMod = new Modifier({
            origin: [ 1, 0 ],
            transform: Transform.translate(0, 0, 10)
        });
        this.title = '<button class="left edit-button" id="contact-edit-contact"></button><div>All Contacts</div><button class="right add-contact" id="add-contact"><i class="fa fa-plus" id="add-contact"></i></button>';
        this.navigation = {
            caption: "Contacts",
            icon: '<i class="fa fa-users"></i>'
        };
        this.collection = options.collection;
        this.scrollview = new VerticalScrollView({
            direction: Utility.Direction.Y,
            margin: 1e4
        });
        this.headerFooterLayout.id.header.add(this.searchSurfaceMod).add(this.searchSurface);
        this.headerFooterLayout.id.content.add(this.scrollview);
        this.headerFooterLayout.id.content.add(this.abcMod).add(this.abcSurface);
        this.pipe(this.scrollview);
        this._add(this.LayoutMod).add(this.headerFooterLayout);
    };
    ContactsSection.prototype.scrollTo = function(index, position) {
        if (index < 0) return;
        this.scrollview.setVelocity(0);
        this.scrollview.node.index = index;
        if (!position) position = 0;
        this.scrollview.setPosition(position);
    };
    ContactsSection.prototype.setupHeaderSurfaces = function() {
        return _.map(this.a2zString, function(i) {
            var headerSurface = new HeaderView({
                content: Templates.headerItemView(i, 0, 0),
                header: i,
                collection: this.collection
            });
            headerSurface.pipe(this.scrollview);
            return headerSurface;
        }.bind(this));
    };
    ContactsSection.prototype.refreshContacts = function(searchKey) {
        $("body").removeClass("editing");
        if (this.searchMode == true) {
            this.abcSurface.setContent("");
            this.currentSequence = [];
            if (searchKey == undefined || searchKey == "") {
                this.scrollview.sequenceFrom(this.currentSequence);
                return;
            }
            this.currentCollection = this.collection.searchContact(searchKey.toUpperCase());
        } else {
            this.currentCollection = this.collection.models;
            this.currentSequence = _.clone(this.headerSequence);
            this.abcSurface.setContent(Templates.abcButtons());
        }
        this.contactSequence = _.sortBy(this.contactSequence, sortByLastname);
        this.currentContactsSequence = _.map(this.currentCollection, function(item) {
            return this.contactSequence[item.collection.indexOf(item)];
        }.bind(this));
        this.currentSequence = this.currentSequence.concat(this.currentContactsSequence);
        this.sortByLastname();
        // added empty item
        // media access bar messed up the height so add 40
        //
        //    var lastGroupIndex = _.last(this.a2zIndexArray);
        //    var extraHeight = this.scrollview.getSize()[1] + 40;
        //    for (var i = lastGroupIndex; i<this.sequence.length; i++) {
        //        extraHeight -= this.sequence[i].getSize()[1];
        //    }
        //
        //    if (extraHeight > 0) {
        //        var emptySurface = new Surface({
        //            size: [undefined, extraHeight]
        //        });
        //        this.sequence.push(emptySurface);
        //        emptySurface.pipe(this.eventOutput);
        //
        //        if (this.collection.length == 0) {
        //            var firstAdd = '<div class="firstAdd"><div> <i class="fa fa-plus fa-5x" ></i> </div> <div> Your contact list is empty,</div><div> Please add your first contact</div></div>';
        //            emptySurface.setContent(firstAdd);
        //            emptySurface.on('click',function(e){
        //                if ($(e.target).hasClass('fa-plus'))
        //                    this.eventOutput.emit('editContact');
        //            }.bind(this))
        //        } else if (this.currentCollection.length == 0) {
        //            var noMatch = '<div class="no-match-found"><div> No match found</div></div>';
        //            emptySurface.setContent(noMatch);
        //        }
        //    }
        this.scrollview.sequenceFrom(this.currentSequence);
    };
    ContactsSection.prototype.initContacts = function() {
        this.headerSequence = this.setupHeaderSurfaces();
        this.contactSequence = this.collection.map(function(item) {
            return this.createItem(item);
        }.bind(this));
        this.refreshContacts();
    };
    ContactsSection.prototype.createItem = function(item) {
        var surface = new ContactItemView({
            model: item
        });
        surface.pipe(this._eventOutput);
        this._eventInput.pipe(surface);
        return surface;
    };
    ContactsSection.prototype.collectionEvents = function() {
        // When Firebase returns the data switch out of the loading screen
        this.collection.on("all", function(e, model, collection, options) {
            console.log(e, model, collection, options);
            switch (e) {
              case "change":
                this.changeItem(model);
                this.collection.sort();
                break;

              case "remove":
                this.removeItem(model);
                break;

              case "add":
                if (this.noInit == true) {
                    this.addItem(model);
                }
                break;

              case "sync":
                if (!this.noInit) {
                    this.noInit = true;
                    this.initContacts();
                }
                break;
            }
        }.bind(this));
    };
    ContactsSection.prototype.abcSurfaceEvents = function() {
        var mousePosition = [ 0, 0 ];
        var sync = new GenericSync(function() {
            return mousePosition;
        }, {
            syncClasses: [ MouseSync, TouchSync ]
        });
        this.abcSurface.pipe(sync);
        sync.on("start", function(data) {
            this.scrollToContact(data);
        }.bind(this));
        sync.on("update", function(data) {
            this.scrollToContact(data);
        }.bind(this));
    };
    ContactsSection.prototype.scrollToContact = function(data) {
        var target = document.elementFromPoint(data.ap[0], data.ap[1]);
        if (!target || !target.id) return;
        for (var i in this.headerSequence) {
            if (this.headerSequence[i].options.header == target.id) {
                var index = this.currentSequence.indexOf(this.headerSequence[i]);
                break;
            }
        }
        this.scrollTo(index);
    };
    ContactsSection.prototype.removeItem = function(item) {
        for (var i in this.contactSequence) {
            if (this.contactSequence[i].model == item) {
                var indexInContactSequence = i;
                break;
            }
        }
        this.contactSequence.splice(indexInContactSequence, 1);
        for (var i in this.currentSequence) {
            if (this.currentSequence[i].model == item) {
                var indexInScrollview = i;
                break;
            }
        }
        this.scrollview.removeByIndex(indexInScrollview);
    };
    ContactsSection.prototype.addItem = function(item) {
        var newContact = this.createItem(item);
        this.contactSequence.push(newContact);
        this.refreshContacts();
    };
    ContactsSection.prototype.changeItem = function(item) {
        this.refreshContacts();
    };
    ContactsSection.prototype.searchSurfaceEvents = function() {
        this.searchSurface.on("click", function(e) {
            //        console.log(e);
            if (e.target.className == "search-contact") {
                this._eventInput.emit("searchOnFocus");
            } else if (e.target.className == "cancel") {
                e.currentTarget.children[0].children[1].value = "";
                this._eventInput.emit("searchOnBlur");
                this.refreshContacts("");
            }
        }.bind(this));
        this._eventInput.on("searchOnFocus", this.searchOnFocus.bind(this));
        this._eventInput.on("searchOnBlur", this.searchOnBlur.bind(this));
        this.searchSurface.on("keyup", function(e) {
            this.refreshContacts(e.target.value);
        }.bind(this));
    };
    ContactsSection.prototype.getInitialChar = function(item) {
        if (item.get("lastname") != undefined && item.get("lastname") != "") {
            return isEnglish(item.get("lastname")) ? item.get("lastname")[0].toUpperCase() : "#";
        } else {
            return "#";
        }
        function isEnglish(words) {
            return /^[a-zA-Z]+$/.test(words[0]);
        }
    };
    ContactsSection.prototype.searchOnFocus = function() {
        this.searchMode = true;
        this._eventInput.emit("backToNoneEditing");
        this.scrollview.scrollTo(0, 0);
        this.refreshContacts();
        this.LayoutMod.setTransform(Transform.translate(0, -50, 0), this.searhBarTransition);
        this.searchSurface._currTarget.children[0].children[2].style.opacity = 1;
        this.searchSurface._currTarget.style.paddingRight = "100px";
    };
    ContactsSection.prototype.searchOnBlur = function() {
        this.searchMode = false;
        this.LayoutMod.setTransform(Transform.translate(0, 0, 0), this.searhBarTransition);
        this.searchSurface._currTarget.children[0].children[2].style.opacity = 0;
        this.searchSurface._currTarget.style.paddingRight = "10px";
    };
    ContactsSection.prototype.sortByLastname = function() {
        this.currentSequence = _.sortBy(this.currentSequence, sortByLastname);
    };
    ContactsSection.prototype.sortByFirstname = function() {
        this.currentSequence = _.sortBy(this.currentSequence, sortByFirstname);
    };
    function sortByLastname(item) {
        var l, f, h;
        l = f = h = "";
        if (item.model) l = item.model.get("lastname");
        if (item.model) f = item.model.get("firstname");
        if (item.options && item.options.header) h = item.options.header;
        var str = h + l + " " + f;
        if (!/^[a-zA-Z]+$/.test(str[0])) str = "zzzz" + str;
        return str.toUpperCase();
    }
    function sortByFirstname(item) {
        var l, f, h;
        l = f = h = "";
        if (item.model) l = item.model.get("lastname");
        if (item.model) f = item.model.get("firstname");
        if (item.options && item.options.header) h = item.options.header;
        var str = h + f + " " + l;
        if (!/^[a-zA-Z]+$/.test(str[0])) str = "zzzz" + str;
        return str.toUpperCase();
    }
    function dynamicSort(sortFunction) {
        return function(a, b) {
            var result = sortFunction(a) < sortFunction(b) ? -1 : sortFunction(a) > sortFunction(b) ? 1 : 0;
            return result;
        };
    }
    module.exports = ContactsSection;
}.bind(this));

require.register("app/views/conversation-item-view.js", function(exports, require, module) {
    // import famous modules
    var View = require("famous/view");
    var EventHandler = require("famous/event-handler");
    var Modifier = require("famous/modifier");
    // Import app specific dependencies
    var ConversationSurface = require("conversation-surface");
    var Helpers = require("helpers");
    function ConversationItemView(options) {
        View.call(this);
        this.model = options.model;
        // this.eventInput = new EventHandler();
        // EventHandler.setInputHandler(this, this.eventInput);
        // this.eventOutput = new EventHandler();
        // EventHandler.setOutputHandler(this, this.eventOutput);
        this.surface = new ConversationSurface({
            properties: {
                maxWidth: 300,
                zIndex: 2
            }
        });
        this.template();
        this.event();
        this.surface.pipe(this._eventOutput);
        this._add(this.surface);
    }
    ConversationItemView.prototype = Object.create(View.prototype);
    ConversationItemView.prototype.constructor = ConversationItemView;
    ConversationItemView.prototype.event = function() {
        this.surface.on("click", function(e) {
            if ($(e.target).hasClass("conversation-item")) return;
            this._eventOutput.emit("toggleMsg");
        }.bind(this));
    };
    ConversationItemView.prototype.template = function() {
        var content = this.getLink(this.model.get("content"));
        if (this.model.isLocal()) {
            content = '<div class="conversation-item triangle-border right">' + content + "</div>";
        } else content = '<div class="conversation-item triangle-border left">' + content + "</div>";
        this.surface.setContent(content);
    };
    ConversationItemView.prototype.getLink = function(message) {
        return Helpers.linkify(message);
    };
    module.exports = ConversationItemView;
}.bind(this));

require.register("app/views/conversation-view.js", function(exports, require, module) {
    // Import core Famous dependencies
    var View = require("famous/view");
    var Surface = require("famous/surface");
    var Modifier = require("famous/modifier");
    var Transform = require("famous/transform");
    var Scrollview = require("famous/views/scrollview");
    var Utility = require("famous/utilities/utility");
    var HeaderFooterLayout = require("famous/views/header-footer-layout");
    var Engine = require("famous/engine");
    var SoundPlayer = require("famous/audio/sound-player");
    var Transitionable = require("famous/transitions/transitionable");
    var WallTransition = require("famous/transitions/wall-transition");
    Transitionable.registerMethod("wall", WallTransition);
    var Templates = require("templates");
    var VerticalScrollView = require("vertical-scroll-view");
    var ConversationItemView = require("conversation-item-view");
    var ConversationCollection = require("models").ConversationCollection;
    var ChatCollection = require("models").ChatCollection;
    var Helpers = require("helpers");
    var startOpacity = 1;
    function ConversationView(appSettings, call) {
        window.con = this;
        View.call(this);
        this.setupBeepeTone();
        this.initHeader();
        this.initFooter();
        this.initConversation();
        this.setupLayout();
        this.setupTransition();
        this.onResize();
        this.buttonsEvents();
        this.textingEvents();
        // TODO: hack, for Dev;
        this.inputSourceLocal = true;
    }
    ConversationView.prototype = Object.create(View.prototype);
    ConversationView.prototype.constructor = ConversationView;
    ConversationView.prototype.setupBeepeTone = function() {
        this.messageTone = new SoundPlayer([ "content/audio/beep.mp3" ]);
        this.playBeepe = _.debounce(function() {
            this.messageTone.playSound(0, .3);
        }.bind(this), 300);
    };
    ConversationView.prototype.setupcall = function(appSettings, call) {
        this.appSettings = appSettings;
        this.settingsEvents = {
            "change:video": this._eventOutput.emit("setVideo"),
            "change:audio": this._eventOutput.emit("setAudio")
        };
        this.appSettings.on(this.settingsEvents);
        this.call = call;
        if (!Helpers.isDev()) {
            if (this.collection) this.collection.off();
            var url = appSettings.get("firebaseUrl") + "chats/" + appSettings.get("cid") + "/" + call.get("cid");
            this.collection = new ChatCollection([], {
                firebase: url
            });
        } else {
            this.collection = new ConversationCollection();
            this.call = undefined;
        }
        this.synced = false;
    };
    ConversationView.prototype.initHeader = function() {
        this.exitSurface = new Surface({
            size: [ window.innerWidth - 225, 50 ],
            classes: [ "conversation-exit" ],
            properties: {
                cursor: "pointer"
            }
        });
        this.exitSurface.pipe(this._eventOutput);
        this.exitSurfaceMod = new Modifier({
            transform: Transform.translate(0, 0, 3)
        });
        this.callSurface = new Surface({
            size: [ 225, 50 ],
            classes: [ "conversation-call" ],
            content: '<div class="touchable"><i class="fa fa-phone fa-lg"></i> Call</div>',
            properties: {
                cursor: "pointer"
            }
        });
        this.callSurfaceMod = new Modifier({
            origin: [ 1, 0 ],
            transform: Transform.translate(0, 0, 4)
        });
        this.endCallSurface = new Surface({
            size: [ 75, 50 ],
            classes: [ "conversation-endCall" ],
            content: '<div class="touchable"><i class="fa fa-phone fa-lg"></i></div>',
            properties: {
                cursor: "pointer"
            }
        });
        this.endCallSurface.pipe(this._eventOutput);
        this.endCallSurfaceMod = new Modifier({
            origin: [ 1, 0 ],
            transform: Transform.translate(-150, 0, 3)
        });
        this.audioSurface = new Surface({
            size: [ 75, 50 ],
            classes: [ "conversation-audio" ],
            properties: {
                cursor: "pointer"
            }
        });
        this.audioSurface.pipe(this._eventOutput);
        this.audioSurfaceMod = new Modifier({
            origin: [ 1, 0 ],
            transform: Transform.translate(0, 0, 3)
        });
        this.cameraSurface = new Surface({
            size: [ 75, 50 ],
            classes: [ "conversation-camera" ],
            properties: {
                cursor: "pointer"
            }
        });
        this.cameraSurfaceMod = new Modifier({
            origin: [ 1, 0 ],
            transform: Transform.translate(-75, 0, 3)
        });
    };
    ConversationView.prototype.cameraSurfaceSetContent = function() {
        if (this.appSettings.attributes.video == true) {
            this.cameraSurface.setContent('<button class="fa fa-video-camera fa-lg on touchable"></button>');
        } else {
            this.cameraSurface.setContent('<button class="fa fa-video-camera fa-lg off touchable"></button>');
        }
    };
    ConversationView.prototype.audioSurfaceSetContent = function() {
        if (this.appSettings.attributes.audio == true) {
            this.audioSurface.setContent('<button class="fa fa-microphone fa-lg on touchable"></button>');
        } else {
            this.audioSurface.setContent('<button class="fa fa-microphone fa-lg off touchable"></button>');
        }
    };
    ConversationView.prototype.initFooter = function() {
        this.inputSurface = new Surface({
            size: [ window.innerWidth - 100, 50 ],
            classes: [ "conversation-input-bar" ],
            content: '<textarea class="input-msg" name="message"></textarea>',
            properties: {
                backgroundColor: "black"
            }
        });
        this.inputSurfaceMod = new Modifier({
            transform: Transform.translate(0, 0, 9)
        });
        this.sendSurface = new Surface({
            size: [ 100, 50 ],
            classes: [ "conversation-input-bar" ],
            content: '<div class="touchable"><button class="send-text-button">Send</button></div>',
            properties: {
                backgroundColor: "black",
                cursor: "pointer"
            }
        });
        this.sendSurfaceMod = new Modifier({
            origin: [ 1, 0 ],
            transform: Transform.translate(0, 0, 9)
        });
    };
    ConversationView.prototype.initConversation = function() {
        this.scrollview = new VerticalScrollView({
            startAt: "bottom",
            direction: Utility.Direction.Y
        });
        this.pipe(this.scrollview);
        this.mod = new Modifier({
            opacity: startOpacity
        });
    };
    ConversationView.prototype.setupLayout = function() {
        this.headerFooterLayout = new HeaderFooterLayout({
            headerSize: 50,
            footerSize: 50
        });
        this.headerFooterLayout.id.header.add(this.exitSurfaceMod).add(this.exitSurface);
        this.headerFooterLayout.id.header.add(this.callSurfaceMod).add(this.callSurface);
        this.headerFooterLayout.id.header.add(this.endCallSurfaceMod).add(this.endCallSurface);
        this.headerFooterLayout.id.header.add(this.audioSurfaceMod).add(this.audioSurface);
        this.headerFooterLayout.id.header.add(this.cameraSurfaceMod).add(this.cameraSurface);
        this.headerFooterLayout.id.content.add(this.mod).add(this.scrollview);
        this.headerFooterLayout.id.footer.add(this.inputSurfaceMod).add(this.inputSurface);
        this.headerFooterLayout.id.footer.add(this.sendSurfaceMod).add(this.sendSurface);
        this._add(this.headerFooterLayout);
    };
    ConversationView.prototype.onResize = function() {
        var resizeTimeout;
        var onResize = function() {
            if (!this.scrollview) return;
            // just in case horizontal resize from wide to narrow
            //        if (!Helpers.isMobile())
            this.scrollview.setVelocity(-99);
        };
        //        Engine.on('resize', onResize.bind(this));
        Engine.on("resize", function() {
            //            if (Helpers.isMobile()) return;
            this.exitSurface.setSize([ window.innerWidth - 225, 50 ]);
            this.inputSurface.setSize([ window.innerWidth - 100, 50 ]);
            if (resizeTimeout) clearTimeout(resizeTimeout);
            resizeTimeout = setTimeout(onResize.bind(this), 300);
        }.bind(this));
    };
    ConversationView.prototype.setupTransition = function() {
        this.buttonTransition = {
            method: "wall",
            period: 200,
            dampingRatio: 1
        };
        this.chatOpacityTransition = {
            method: "wall",
            period: 300,
            dampingRatio: 1
        };
    };
    ConversationView.prototype.start = function(appSettings, call) {
        this.setupcall(appSettings, call);
        this.cameraSurfaceSetContent();
        this.audioSurfaceSetContent();
        this.exitSurface.setContent(Templates.conversationViewHeader(call));
        if (!Helpers.isDev() && this.call.get("success")) {
            this.hideCallButton();
        } else this.showCallButton();
        this.scrollview.sequenceFrom([]);
        this.collectionEvents();
        if (this.collection.size()) {
            // if locally loaded, then load right away
            setTimeout(this.loadMsg.bind(this), 400);
        }
        if (Helpers.isMobile()) window._disableResize = false;
    };
    ConversationView.prototype.stop = function(evt) {
        this.showCallButton();
        this.appSettings.save({
            video: true
        });
        this.appSettings.save({
            audio: true
        });
        if (evt.exit) {
            this.collection.off();
            this.appSettings.off(this.settingsEvents);
            if (Helpers.isMobile()) {
                setTimeout(function() {
                    window._disableResize = true;
                }, 500);
            }
        }
        if (evt.exit) this.mod.setOpacity(startOpacity);
    };
    ConversationView.prototype.collectionEvents = function() {
        this.collection.on("all", function(e, model, collection, options) {
            console.log(e);
            switch (e) {
              case "add":
                if (!this.synced) break;
                this.addMsg(model);
                this.playBeepe();
                // only keep at most 100 messages
                if (this.collection.size() >= 100) {
                    this.collection.shift();
                }
                setTimeout(function() {
                    this.scrollview.scrollToEnd();
                }.bind(this), 400);
                this.showConversation();
                this._eventOutput.emit("chatRead", this.call);
                break;

              case "sync":
                setTimeout(this.loadMsg.bind(this), 400);
                this._eventOutput.emit("chatRead", this.call);
                break;
            }
        }.bind(this));
    };
    ConversationView.prototype.showCallButton = function() {
        this.callSurfaceMod.setTransform(Transform.translate(0, 0, 4), this.buttonTransition);
    };
    ConversationView.prototype.hideCallButton = function() {
        this.callSurfaceMod.setTransform(Transform.translate(225, 0, 4), this.buttonTransition);
    };
    ConversationView.prototype.buttonsEvents = function() {
        this.exitSurface.on("click", function() {
            this.showCallButton();
            setTimeout(function() {
                this._eventOutput.emit("callEnd", {
                    exit: true,
                    chat: this.call
                });
            }.bind(this), 600);
        }.bind(this));
        this.callSurface.on("click", function() {
            this.hideCallButton();
            setTimeout(function() {
                this._eventOutput.emit("outgoingCall", this.call);
            }.bind(this), 600);
        }.bind(this));
        this.endCallSurface.on("click", function() {
            this.showCallButton();
            setTimeout(function() {
                this._eventOutput.emit("callEnd", {
                    exit: false
                });
            }.bind(this), 600);
        }.bind(this));
        this.audioSurface.on("click", function() {
            this.appSettings.save({
                audio: !this.appSettings.attributes.audio
            });
            this.audioSurfaceSetContent();
        }.bind(this));
        this.cameraSurface.on("click", function() {
            this.appSettings.save({
                video: !this.appSettings.attributes.video
            });
            this.cameraSurfaceSetContent();
        }.bind(this));
        this.sendSurface.on("click", function() {
            this.addChat();
        }.bind(this));
    };
    ConversationView.prototype.textingEvents = function() {
        this.inputSurface.on("keydown", function(e) {
            if (e.keyCode == 13) {
                this.addChat();
            }
        }.bind(this));
        this._eventInput.on("incomingChat", function(evt) {
            this.addRemote(evt.content);
        }.bind(this));
        this._eventOutput.on("toggleMsg", function() {
            // TODO: no toggle for now
            //        return;
            if (this.mod.getOpacity() == 1) this.mod.setOpacity(startOpacity, this.chatOpacityTransition); else this.mod.setOpacity(1, this.chatOpacityTransition);
        }.bind(this));
    };
    ConversationView.prototype.createMsgItem = function(model) {
        var surface = new ConversationItemView({
            model: model
        });
        surface.pipe(this._eventOutput);
        return surface;
    };
    ConversationView.prototype.addChat = function() {
        var message = document.getElementsByClassName("input-msg")[0].value;
        if (!message || message.replace(/[\s\t\r\n]/g, "") == "") return;
        document.getElementsByClassName("input-msg")[0].value = "";
        if (this.call) {
            // TODO: this is for testing
            if (Helpers.isDev()) return;
            this._eventOutput.emit("sendChat", {
                contact: this.call,
                message: message
            });
        } else {
            // TODO: this is for testing
            this.inputSourceLocal = !this.inputSourceLocal;
            if (this.inputSourceLocal) this.addLocal(message); else this.addRemote(message);
        }
    };
    ConversationView.prototype.addLocal = function(message) {
        var newMsg = {
            content: message,
            source: "local",
            type: "text",
            from: window._cola_g.cid,
            time: Date.now()
        };
        if (Helpers.isDev()) {
            this.collection.create(newMsg);
            return;
        }
        this.collection.add(newMsg);
        this._eventOutput.emit("outgoingChat", newMsg);
    };
    ConversationView.prototype.addRemote = function(message) {
        var newMsg = {
            content: message,
            source: "remote",
            type: "text",
            time: Date.now()
        };
        if (Helpers.isDev()) {
            this.collection.create(newMsg);
            return;
        }
        this.collection.add(newMsg);
    };
    ConversationView.prototype.showConversation = function() {
        this.mod.setOpacity(1, this.chatOpacityTransition);
    };
    ConversationView.prototype.addMsg = function(model) {
        this.scrollview.push(this.createMsgItem(model));
    };
    ConversationView.prototype.loadMsg = function() {
        this.synced = true;
        var sequence = this.collection.map(function(item) {
            return this.createMsgItem(item);
        }.bind(this));
        this.scrollview.sequenceFrom(sequence);
        this.scrollview.jumpToEnd();
    };
    module.exports = ConversationView;
}.bind(this));

require.register("app/views/favorite-item-view.js", function(exports, require, module) {
    var Templates = require("templates");
    var RowView = require("row-view");
    var ItemView = RowView.ItemView;
    function FavoriteItemView(options) {
        options.leftButtons = [ {
            content: Templates.crossButton(),
            event: "deleteFavorite"
        } ];
        options.rightButton = {
            content: Templates.phoneButton(),
            event: "outgoingCall"
        };
        options.itemButton = {
            classes: [ "contact-item", "favorite-item", "recent-item", "editable" ],
            content: Templates.favoriteItemView(options.model),
            event: "editContact"
        };
        ItemView.apply(this, arguments);
        this._eventInput.on("toggleAllFavorite", this.onToggleAll.bind(this));
        this._eventInput.on("backToNoneEditing", this.setEditingOff.bind(this));
    }
    FavoriteItemView.prototype = Object.create(ItemView.prototype);
    FavoriteItemView.prototype.constructor = FavoriteItemView;
    module.exports = FavoriteItemView;
}.bind(this));

require.register("app/views/favorites-section-view.js", function(exports, require, module) {
    // Import core Famous dependencies
    var View = require("famous/view");
    var Utility = require("famous/utilities/utility");
    var Surface = require("famous/surface");
    var VerticalScrollView = require("vertical-scroll-view");
    var Engine = require("famous/engine");
    var Templates = require("templates");
    var FavoriteItemView = require("favorite-item-view");
    function FavoritesSectionView(options) {
        View.call(this);
        this.title = Templates.favoriteHeader();
        this.navigation = {
            caption: "Favorites",
            icon: '<i class="fa fa-star"></i>'
        };
        this.collection = options.collection;
        this.scrollview = new VerticalScrollView({
            startAt: "top"
        });
        this.pipe(this.scrollview);
        this._add(this.scrollview);
        this.scrollview.sequenceFrom([]);
        this.collection.on("all", function(e, model, collection, options) {
            switch (e) {
              case "change:favorite":
                if (model.changed.favorite) this.addItem(model); else {
                    var i = this.pastCollection.indexOf(model);
                    this.removeItemByIndex(i);
                }
                break;

              case "remove":
                var i = this.pastCollection.indexOf(model);
                this.removeItemByIndex(i);
                break;

              case "add":
                this.addItem(model);
                break;
            }
        }.bind(this));
    }
    FavoritesSectionView.prototype = Object.create(View.prototype);
    FavoritesSectionView.prototype.constructor = FavoritesSectionView;
    FavoritesSectionView.prototype.loadItems = function() {
        this.pastCollection = this.collection.favorites();
        this.sequence = this.collection.favorites().map(function(item) {
            var surface = new FavoriteItemView({
                model: item
            });
            surface.pipe(this._eventOutput);
            this._eventInput.pipe(surface);
            return surface;
        }.bind(this));
        this.scrollview.sequenceFrom(this.sequence);
    };
    FavoritesSectionView.prototype.addItem = function(contact) {
        this.pastCollection = this.collection.favorites();
        var i = this.collection.favorites().indexOf(contact);
        if (i >= 0) {
            var surface = new FavoriteItemView({
                model: contact
            });
            surface.pipe(this._eventOutput);
            this._eventInput.pipe(surface);
            this.scrollview.addByIndex(i, surface);
        }
    };
    FavoritesSectionView.prototype.removeItemByIndex = function(index) {
        this.pastCollection = this.collection.favorites();
        this.scrollview.removeByIndex(index);
    };
    module.exports = FavoritesSectionView;
}.bind(this));

require.register("app/views/import-contact-view.js", function(exports, require, module) {
    // Import core Famous dependencies
    var HeaderFooterLayout = require("famous/views/header-footer-layout");
    var Surface = require("famous/surface");
    var View = require("famous/view");
    var SocialScrollView = require("social-scroll-view");
    function ImportContactView(options) {
        View.call(this);
        this.collection = options.collection;
        this.header = new Surface({
            content: '<button class="left back-button touchable">Back</button><div>' + options.title + " Contacts</div>",
            classes: [ "header" ],
            size: [ undefined, 50 ],
            properties: {}
        });
        this.content = new SocialScrollView({
            collection: this.collection
        });
        this.layout = new HeaderFooterLayout({
            headerSize: 50,
            footerSize: 0
        });
        this.layout.id.header.add(this.header);
        this.layout.id.content.add(this.content);
        this.header.pipe(this._eventOutput);
        this.content.pipe(this._eventOutput);
        this.header.on("click", function(e) {
            var target = $(e.target);
            if (target.hasClass(".edit-button")) {
                this.submitForm();
            }
        }.bind(this));
        this.header.on("click", function(e) {
            if ($(e.target).hasClass("back-button")) this._eventOutput.emit("goBack");
        }.bind(this));
        this._add(this.layout);
    }
    ImportContactView.prototype = Object.create(View.prototype);
    ImportContactView.prototype.constructor = ImportContactView;
    module.exports = ImportContactView;
}.bind(this));

require.register("app/views/incoming-call-view.js", function(exports, require, module) {
    var View = require("famous/view");
    var Transform = require("famous/transform");
    var Surface = require("famous/surface");
    var EventHandler = require("famous/event-handler");
    var Easing = require("famous/transitions/easing");
    var SoundPlayer = require("famous/audio/sound-player");
    var LightBox = require("light-box");
    var Templates = require("templates");
    var Models = require("models");
    var Contact = Models.Contact;
    var Call = Models.Call;
    var duration = 500;
    function IncomingCallView(options) {
        View.call(this);
        this.collection = options.collection;
        // Set up event handlers
        // this.eventInput = new EventHandler();
        // EventHandler.setInputHandler(this, this.eventInput);
        // this.eventOutput = new EventHandler();
        // EventHandler.setOutputHandler(this, this.eventOutput);
        this.headerLightBox = new LightBox({
            inTransition: false,
            outTransition: false,
            showOrigin: [ .5, .1 ]
        });
        this.footerLightBox = new LightBox({
            inTransform: Transform.translate(0, 900, 0),
            inTransition: {
                duration: duration,
                curve: Easing.inQuad()
            },
            inOpacity: 0,
            inOrigin: [ .5, .5 ],
            outTransform: Transform.translate(0, 900, 0),
            outOpacity: 0,
            outOrigin: [ .5, .5 ],
            outTransition: {
                duration: duration,
                curve: Easing.outQuad()
            },
            showTransform: Transform.identity,
            showOpacity: 1,
            showOrigin: [ .5, .9 ]
        });
        this.header = new Surface({
            classes: [ "outgoing-call-view" ],
            size: [ undefined, 300 ],
            _origin: [ .5, -.5 ],
            properties: {
                backgroundColor: "transparent"
            }
        });
        var declineButton = Templates.button({
            classes: [ "decline-button", "big-button" ],
            checked: true,
            content: "Decline",
            size: [ 160, 70 ]
        });
        var answerButton = Templates.button({
            classes: [ "answer-button", "big-button" ],
            checked: true,
            content: "Answer",
            size: [ 160, 70 ]
        });
        this.footer = new Surface({
            classes: [ "incoming-call-view-buttons" ],
            size: [ undefined, 80 ],
            properties: {
                backgroundColor: "transparent"
            },
            content: '<div class="box">' + declineButton + answerButton + "</div>"
        });
        this._add(this.headerLightBox);
        this._add(this.footerLightBox);
        _.bindAll(this, "template");
        this.collection.bind("add", this.template);
        this.ringtone = new SoundPlayer([ "content/audio/ringtone.mp3" ]);
        this.footer.on("click", function(e) {
            var target = $(e.target);
            if (target.hasClass("decline-button")) {
                this.stop();
            } else if (target.hasClass("answer-button")) {
                this.accept();
            }
        }.bind(this));
        this._eventInput.on("incomingCall", function() {});
        this._eventInput.on("incomingCallAnswerClick", function() {
            this.accept();
        }.bind(this));
    }
    IncomingCallView.prototype = Object.create(View.prototype);
    IncomingCallView.prototype.constructor = IncomingCallView;
    IncomingCallView.prototype.template = function() {
        this.model = this.collection.models[0] || new Call();
        var html = '<div class="box">';
        html += '<div class="caller-name">' + this.model.get("firstname") + " " + this.model.get("lastname") + "</div>";
        if (this.model.get("pictureUrl")) html += '<img class="caller-picture" src="' + this.model.get("pictureUrl") + '"></img>'; else {
            var initial = this.model.get("firstname")[0] + this.model.get("lastname")[0];
            html += '<div class="initial">' + initial + "</div>";
        }
        html += '<div class="caller-info"></div>';
        this.header.setContent(html);
    };
    IncomingCallView.prototype.startRingtone = function() {
        this.ringtone.playSound(0, 1);
        this.ringtoneRepeat = setInterval(function() {
            this.ringtone.playSound(0, 1);
        }.bind(this), 8e3);
        this.footerLightBox.show(this.footer);
        this.headerLightBox.show(this.header);
    };
    IncomingCallView.prototype.stopRingtone = function() {
        clearInterval(this.ringtoneRepeat);
        this.ringtone.stopPlaying();
    };
    IncomingCallView.prototype.start = function(eventData) {
        this.on = true;
        var data;
        if (eventData instanceof Contact || eventData instanceof Call) {
            data = eventData.attributes;
        } else {
            this.model = this.collection.models[0] || new Call();
            data = this.model.attributes;
        }
        this.model.set({
            roomId: data.roomId
        });
        this.startRingtone();
        $(".camera").removeClass("blur");
    };
    IncomingCallView.prototype.stop = function(evt) {
        var button = $(".decline-button");
        if (!this.on) return;
        this.on = false;
        if (button) {
            this.model.set({
                success: false
            });
            button.addClass("exiting");
        }
        this.stopRingtone();
        setTimeout(function() {
            this.footerLightBox.hide();
            this.headerLightBox.hide();
            this._eventOutput.emit("showApp", function() {
                if (button) button.removeClass("exiting");
            });
        }.bind(this), duration);
    };
    IncomingCallView.prototype.accept = function() {
        var button = $(".answer-button");
        this.on = false;
        this.model.set({
            success: true
        });
        if (button) button.addClass("exiting");
        this.stopRingtone();
        setTimeout(function() {
            this.footerLightBox.hide();
            this.headerLightBox.hide();
            setTimeout(function() {
                if (button) button.removeClass("exiting");
            }, 1e3);
            this._eventOutput.emit("connectedCall", this.model);
        }.bind(this), duration);
        if (button) {
            this._eventOutput.emit("incomingCallAnswer", this.model);
        }
    };
    module.exports = IncomingCallView;
}.bind(this));

require.register("app/views/index.js", function(exports, require, module) {
    module.exports = {
        AddContactView: require("add-contact-view"),
        AlertView: require("alert-view"),
        CameraView: require("camera-view"),
        ConnectedCallView: require("connected-call-view"),
        ContactsScrollView: require("contacts-scroll-view"),
        ContactsSectionView: require("contacts-section-view"),
        ConversationView: require("conversation-view"),
        FavoritesSectionView: require("favorites-section-view"),
        IncomingCallView: require("incoming-call-view"),
        OutgoingCallView: require("outgoing-call-view"),
        RecentsSectionView: require("recents-section-view"),
        ChatsSectionView: require("chats-section-view"),
        SettingsSectionView: require("settings-section-view"),
        SocialView: require("social-view"),
        SocialScrollView: require("social-scroll-view")
    };
}.bind(this));

require.register("app/views/outgoing-call-view.js", function(exports, require, module) {
    var View = require("famous/view");
    var Transform = require("famous/transform");
    var Surface = require("famous/surface");
    var EventHandler = require("famous/event-handler");
    var Easing = require("famous/transitions/easing");
    var SoundPlayer = require("famous/audio/sound-player");
    var LightBox = require("light-box");
    var Templates = require("templates");
    var Models = require("models");
    var Contact = Models.Contact;
    var Call = Models.Call;
    var duration = 500;
    function OutgoingCallView(options) {
        View.call(this);
        this.collection = options.collection;
        this.headerLightBox = new LightBox({
            inTransition: false,
            outTransition: false,
            showOrigin: [ .5, .1 ],
            overlap: true
        });
        this.footerLightBox = new LightBox({
            inTransform: Transform.translate(0, 900, 0),
            inTransition: {
                duration: duration,
                curve: Easing.inQuad()
            },
            inOpacity: 0,
            inOrigin: [ .5, .5 ],
            outTransform: Transform.translate(0, 900, 0),
            outOpacity: 0,
            outOrigin: [ .5, .5 ],
            outTransition: {
                duration: duration,
                curve: Easing.outQuad()
            },
            showTransform: Transform.identity,
            showOpacity: 1,
            showOrigin: [ .5, .9 ],
            overlap: true
        });
        // Set up event handlers
        // this.eventInput = new EventHandler();
        // EventHandler.setInputHandler(this, this.eventInput);
        // this.eventOutput = new EventHandler();
        // EventHandler.setOutputHandler(this, this.eventOutput);
        this.header = new Surface({
            classes: [ "outgoing-call-view" ],
            size: [ undefined, 300 ],
            _origin: [ .5, -.5 ],
            properties: {
                backgroundColor: "transparent"
            }
        });
        this.footer = new Surface({
            classes: [ "outgoing-call-view-buttons" ],
            size: [ undefined, 80 ],
            properties: {
                backgroundColor: "transparent"
            }
        });
        this._add(this.headerLightBox);
        this._add(this.footerLightBox);
        _.bindAll(this, "template");
        this.collection.bind("add", this.template);
        this.calltone = new SoundPlayer([ "content/audio/calltone.mp3", "content/audio/ringtone.mp3" ]);
        this.footer.on("click", function(e) {
            var target = $(e.target);
            if (target.hasClass("end-button")) {
                this.stop(target);
            }
        }.bind(this));
    }
    OutgoingCallView.prototype = Object.create(View.prototype);
    OutgoingCallView.prototype.constructor = OutgoingCallView;
    OutgoingCallView.prototype.template = function() {
        this.model = this.collection.models[0];
        var html = '<div class="box">';
        html += '<div class="caller-name">' + this.model.get("firstname") + " " + this.model.get("lastname") + "</div>";
        if (this.model.get("pictureUrl")) html += '<img class="caller-picture" src="' + this.model.get("pictureUrl") + '"></img>'; else {
            var initial = this.model.get("firstname")[0] + this.model.get("lastname")[0];
            html += '<div class="initial">' + initial + "</div>";
        }
        html += '<div class="caller-info"></div>';
        this.header.setContent(html);
        var videoButton = Templates.toggleButton({
            id: "video",
            classes: [ "video-button", "big-button" ],
            checked: this.appSettings ? this.appSettings.get("video") : true,
            onContent: '<i class="fa fa-eye fa-lg on"></i>',
            offContent: '<i class="fa fa-eye-slash fa-lg off"></i>',
            onBackgroundColor: "#dadbd9",
            offBackgroundColor: "#dadbd9",
            size: [ 70, 70 ]
        });
        var endButton = Templates.button({
            classes: [ "end-button", "big-button" ],
            checked: true,
            content: "End",
            size: [ 160, 70 ]
        });
        var audioButton = Templates.toggleButton({
            id: "audio",
            classes: [ "audio-button", "big-button" ],
            checked: this.appSettings ? this.appSettings.get("audio") : true,
            onContent: '<i class="fa fa-microphone fa-lg on"></i>',
            offContent: '<i class="fa fa-microphone-slash fa-lg off"></i>',
            onBackgroundColor: "#dadbd9",
            offBackgroundColor: "#dadbd9",
            size: [ 70, 70 ]
        });
        html = '<div class="box">' + videoButton + endButton + audioButton + "</div>";
        this.footer.setContent(html);
    };
    OutgoingCallView.prototype.startCalltone = function() {
        this.calltone.playSound(0, 1);
        this.calltoneRepeat = setInterval(function() {
            this.calltone.playSound(0, 1);
        }.bind(this), 2500);
        this.footerLightBox.show(this.footer);
        this.headerLightBox.show(this.header);
    };
    OutgoingCallView.prototype.stopCalltone = function() {
        clearInterval(this.calltoneRepeat);
        this.calltone.stopPlaying();
    };
    OutgoingCallView.prototype.start = function(eventData, appSettings) {
        this.appSettings = appSettings;
        this.on = true;
        var data;
        if (eventData instanceof Contact || eventData instanceof Call) {
            data = eventData;
        } else {
            this.model = this.collection.models[0] || new Call();
            data = this.model;
        }
        // TODO: extend data
        var newCall = {
            firstname: data.get("firstname"),
            lastname: data.get("lastname"),
            email: data.get("email"),
            //        facebook: data.get('facebook'),
            pictureUrl: false,
            type: "outgoing",
            time: Date.now(),
            cid: data.get("cid")
        };
        this.collection.create(newCall);
        this.startCalltone();
        $(".camera").removeClass("blur");
    };
    OutgoingCallView.prototype.stop = function(button) {
        if (!this.on) return;
        this.on = false;
        if (button) {
            this.model.set({
                success: false
            });
            button.addClass("exiting");
        }
        this.stopCalltone();
        setTimeout(function() {
            this.footerLightBox.hide();
            this.headerLightBox.hide();
            this._eventOutput.emit("showApp", function() {
                if (button) button.removeClass("exiting");
            });
        }.bind(this), duration);
        if (button) {
            this._eventOutput.emit("outgoingCallEnd", this.model);
        }
    };
    OutgoingCallView.prototype.accept = function(call) {
        this.on = false;
        this.model.set({
            success: true
        });
        this.stopCalltone();
        setTimeout(function() {
            this.footerLightBox.hide();
            this.headerLightBox.hide();
            this._eventOutput.emit("connectedCall", this.model);
        }.bind(this), duration);
    };
    module.exports = OutgoingCallView;
}.bind(this));

require.register("app/views/recent-item-view.js", function(exports, require, module) {
    var Templates = require("templates");
    var RowView = require("row-view");
    var ItemView = RowView.ItemView;
    function RecentItemView(options) {
        options.leftButtons = [ {
            content: Templates.crossButton(),
            event: "deleteItem"
        }, {
            content: Templates.editButton(),
            event: "editContact"
        } ];
        options.rightButton = {
            content: Templates.phoneButton(),
            event: "outgoingCall"
        };
        options.itemButton = {
            classes: [ "contact-item", "recent-item" ],
            content: Templates.recentItemView(options.model),
            event: "chatContact"
        };
        ItemView.apply(this, arguments);
        this._eventInput.on("toggleAllRecent", this.onToggleAll.bind(this));
        this._eventInput.on("backToNoneEditing", this.setEditingOff.bind(this));
    }
    RecentItemView.prototype = Object.create(ItemView.prototype);
    RecentItemView.prototype.constructor = RecentItemView;
    RecentItemView.prototype.updateItem = function() {
        this.itemSurface.setContent(Templates.recentItemView(this.model));
    };
    module.exports = RecentItemView;
}.bind(this));

require.register("app/views/recents-section-view.js", function(exports, require, module) {
    // Import core Famous dependencies
    var View = require("famous/view");
    var Utility = require("famous/utilities/utility");
    var Surface = require("famous/surface");
    var VerticalScrollView = require("vertical-scroll-view");
    var Engine = require("famous/engine");
    var Templates = require("templates");
    var RecentItemView = require("recent-item-view");
    var RECENT_VIEW_SIZE = 40;
    function RecentsSectionView(options) {
        View.call(this);
        window.rec = this;
        this.title = Templates.recentsHeader();
        this.navigation = {
            caption: "Calls",
            icon: '<i class="fa fa-phone"></i>'
        };
        this.collection = options.collection;
        this.scrollview = new VerticalScrollView({
            startAt: "top"
        });
        this.pipe(this.scrollview);
        this._add(this.scrollview);
        this.collection.once("sync", function() {
            this.loadItems();
            this.collection.on("all", function(e, model, collection, options) {
                console.log("recents ", e);
                switch (e) {
                  case "remove":
                    this.scrollview.removeByIndex(options.index);
                    break;

                  case "add":
                    this.addItem(model);
                    while (this.collection.size() > RECENT_VIEW_SIZE) {
                        this.collection.pop();
                    }
                    break;

                  case "change":
                    var i = model.collection.indexOf(model);
                    this.sequence[i].updateItem();
                    break;
                }
            }.bind(this));
        }.bind(this));
    }
    RecentsSectionView.prototype = Object.create(View.prototype);
    RecentsSectionView.prototype.constructor = RecentsSectionView;
    RecentsSectionView.prototype.updateItems = function() {
        _.each(this.sequence, function(itemView) {
            if (itemView.updateItem) itemView.updateItem();
        });
    };
    RecentsSectionView.prototype.loadItems = function() {
        //    this.collection.fetch();
        this.scrollview.setPosition(0);
        this.sequence = this.collection.map(function(item) {
            var surface = new RecentItemView({
                model: item
            });
            surface.pipe(this._eventOutput);
            this._eventInput.pipe(surface);
            return surface;
        }.bind(this));
        this.scrollview.sequenceFrom(this.sequence);
    };
    RecentsSectionView.prototype.addItem = function(call) {
        var surface = new RecentItemView({
            model: call
        });
        surface.pipe(this._eventOutput);
        this._eventInput.pipe(surface);
        this.scrollview.addByIndex(0, surface);
    };
    RecentsSectionView.prototype.removeItemByIndex = function(index) {
        this.scrollview.removeByIndex(index);
    };
    RecentsSectionView.prototype.clearAll = function() {
        //    _.invoke(this.collection.all(), 'destroy');
        _(this.collection.all()).each(function(item) {
            item.collection.remove(item);
        });
    };
    RecentsSectionView.prototype.setMissedOnly = function(miss) {
        var missedOnly = miss == "missed";
        if (missedOnly) {
            _.each(this.sequence, function(itemView) {
                if (itemView.collapse && !itemView.model.isMissed()) {
                    itemView.collapse();
                }
            }.bind(this));
        } else {
            this.scrollview.setVelocity(-1);
            _.each(this.sequence, function(itemView) {
                if (itemView.expand) itemView.expand();
            }.bind(this));
        }
    };
    module.exports = RecentsSectionView;
}.bind(this));

require.register("app/views/settings-section-view.js", function(exports, require, module) {
    // Import core Famous dependencies
    var View = require("famous/view");
    var Utility = require("famous/utilities/utility");
    var Surface = require("famous/surface");
    var Scrollview = require("famous/views/scrollview");
    var Templates = require("templates");
    function SettingsSectionView(options) {
        View.call(this);
        this.appSettings = options.model;
        // Set up navigation and title bar information
        this.title = "<div>Settings</div>";
        this.navigation = {
            caption: "Settings",
            icon: '<i class="fa fa-gear"></i>'
        };
        this.scrollview = new Scrollview({
            direction: Utility.Direction.Y,
            margin: 1e4
        });
        this.pipe(this.scrollview);
        this.surface = new Surface({
            properties: {
                padding: "20px"
            },
            size: [ undefined, 700 ]
        });
        this.template();
        this.surface.pipe(this._eventOutput);
        this.scrollview.sequenceFrom([ this.surface ]);
        this._add(this.scrollview);
        function onPermissionGranted() {
            myNotification.show();
        }
        function onPermissionDenied() {
            if (this.appSettings.get("notification")) {
                alert("Unblock notification for beepe.me:443 in chrome://settings/contentExceptions#notifications");
                this.appSettings.set("notification", false);
                $("#notification").prop("checked", false);
            }
        }
        var myNotification = new Notify("Settings", {
            body: "Notification is on.",
            tag: "notificationSettings",
            permissionGranted: onPermissionGranted.bind(this),
            permissionDenied: onPermissionDenied.bind(this)
        });
        $(document).on("click", "#notification", function() {
            this.appSettings.save({
                notification: JSON.parse($("#notification").prop("checked"))
            });
            if (!this.appSettings.get("notification")) return;
            if (myNotification.needsPermission()) {
                myNotification.requestPermission();
            } else {
                myNotification.show();
            }
        }.bind(this));
        this.surface.on("click", function(e) {
            //TODO: dont know why the surface is call twice: first time for the surface and the second time for the toggle button.
            //            console.log(e);
            switch (e.target.id) {
              case "camera":
                this.appSettings.save({
                    camera: JSON.parse($("#camera").prop("checked"))
                });
                break;

              case "video":
                this.appSettings.save({
                    video: JSON.parse($("#video").prop("checked"))
                });
                break;

              case "audio":
                this.appSettings.save({
                    audio: JSON.parse($("#audio").prop("checked"))
                });
                break;

              case "blur":
                this.appSettings.save({
                    blur: JSON.parse($("#blur").prop("checked"))
                });
                break;

              case "facebook":
                if (JSON.parse($("#facebook").prop("checked"))) this._eventOutput.emit("onSocialLink", e.target.id); else window.location = "/disconnect/facebook";
                break;

              case "google":
                if (JSON.parse($("#google").prop("checked"))) this._eventOutput.emit("onSocialLink", e.target.id); else window.location = "/disconnect/google";
                break;

              case "linkedin":
              case "github":
              case "yammer":
                alert("Coming Soon.");
                break;
            }
        }.bind(this));
        this.surface.on("click", function(e) {
            switch (e.target.className) {
              //                case "call-button":
                //                    this.eventOutput.emit('outgoingCall');
                //                    break;
                //                case "incoming-button":
                //                    this.eventOutput.emit('imcomingCall');
                //                    break;
                case "connected-button":
                this._eventOutput.emit("connectedCall", "o9ycaGmnq0");
                break;

              case "conversations-button":
                this._eventOutput.emit("conversations");
                break;

              case "logout-button":
                window.location = "/logout";
                break;
            }
        }.bind(this));
        var settingsEvents = {
            "change:camera": onCamera.bind(this),
            "change:audio": onAudio.bind(this),
            "change:video": onVideo.bind(this),
            "change:blur": onBlur.bind(this),
            change: onChange.bind(this)
        };
        this.appSettings.on(settingsEvents);
        function onChange() {
            this.template();
        }
        function onCamera() {
            console.log("camera change");
            //            $("#camera").prop('checked', this.appSettings.get('camera'));
            this._eventOutput.emit("setCamera");
        }
        function onAudio() {
            console.log("audio change");
            //            $("#audio").prop('checked', this.appSettings.get('audio'));
            this._eventOutput.emit("setAudio");
        }
        function onVideo() {
            console.log("video change");
            //            $("#video").prop('checked', this.appSettings.get('video'));
            this._eventOutput.emit("setVideo");
        }
        function onBlur() {
            console.log("blur change");
            //            $("#blur").prop('checked', this.appSettings.get('blur'));
            this._eventOutput.emit("setBlur");
        }
    }
    SettingsSectionView.prototype = Object.create(View.prototype);
    SettingsSectionView.prototype.constructor = SettingsSectionView;
    SettingsSectionView.prototype.template = function() {
        this.surface.setContent(Templates.settingsPage(this.appSettings));
    };
    module.exports = SettingsSectionView;
}.bind(this));

require.register("app/views/social-item-view.js", function(exports, require, module) {
    var GenericSync = require("famous/input/generic-sync");
    var MouseSync = require("famous/input/mouse-sync");
    var TouchSync = require("famous/input/touch-sync");
    var Utility = require("famous/utilities/utility");
    var Templates = require("templates");
    var RowView = require("row-view");
    var ItemView = RowView.ItemView;
    var Helpers = require("helpers");
    function SocialItemView(options) {
        this.model = options.model;
        options.paddingRight = 40;
        options.itemButton = {
            classes: [ "contact-item", "editable" ],
            content: Templates.socialItemView(options.model),
            event: "goBack"
        };
        ItemView.apply(this, arguments);
    }
    SocialItemView.prototype = Object.create(ItemView.prototype);
    SocialItemView.prototype.constructor = SocialItemView;
    // Overwrite the events functions since there is only one button event in Social-view,
    SocialItemView.prototype.setupEvent = function() {
        var sync = new GenericSync(function() {
            return this.pos;
        }.bind(this), {
            syncClasses: [ MouseSync, TouchSync ]
        });
        this.itemSurface.pipe(sync);
        this.itemSurface.pipe(this._eventOutput);
        this.pos = [ 0, 0 ];
        sync.on("start", function() {
            this.pos = [ 0, 0 ];
            this._directionChosen = false;
            this.clickTimeout = setTimeout(function() {
                this.itemSurface.setProperties({
                    backgroundColor: "rgba(255,255,255,0.1)"
                });
            }.bind(this), 100);
        }.bind(this));
        sync.on("update", function(data) {
            if (this.clickTimeout) {
                clearTimeout(this.clickTimeout);
                delete this.clickTimeout;
            }
            this.itemSurface.setProperties({
                backgroundColor: "transparent"
            });
            this.pos = data.p;
            // the displacement from the start touch point.
            if (Helpers.isMobile() && !this._directionChosen) {
                var diffX = Math.abs(this.pos[0]), diffY = Math.abs(this.pos[1]);
                this.direction = diffX > diffY ? Utility.Direction.X : Utility.Direction.Y;
                this._directionChosen = true;
                if (this.direction == Utility.Direction.X) {
                    this.itemSurface.unpipe(this._eventOutput);
                } else {
                    this.itemSurface.pipe(this._eventOutput);
                }
            }
        }.bind(this));
        sync.on("end", function() {
            setTimeout(function() {
                this.itemSurface.setProperties({
                    backgroundColor: "transparent"
                });
            }.bind(this), 300);
        }.bind(this));
        if (Helpers.isMobile() && this.direction != Utility.Direction.X) return;
    };
    SocialItemView.prototype.buttonsClickEvents = function() {
        this.itemSurface.on("click", function() {
            this._eventOutput.emit(this.options.itemButton.event, this.model);
        }.bind(this));
    };
    module.exports = SocialItemView;
}.bind(this));

require.register("app/views/social-scroll-view.js", function(exports, require, module) {
    // import views
    var SocialItemView = require("social-item-view");
    var ContactsScrollView = require("contacts-scroll-view");
    function SocialScrollView(options) {
        ContactsScrollView.apply(this, arguments);
        this._eventOutput.on("goBack", function(ii) {
            console.log("onGoBack", ii);
        });
    }
    SocialScrollView.prototype = Object.create(ContactsScrollView.prototype);
    SocialScrollView.prototype.constructor = SocialScrollView;
    SocialScrollView.prototype.collectionEvents = function() {
        this.collection.on("all", function(e, model) {
            console.log(e, model);
            switch (e) {
              case "sync":
                this.renderHeaders();
                this.createSocialContacts();
                setTimeout(this.renderScrollView.bind(this), this.scrollview.node ? 0 : 1e3);
                break;
            }
        }.bind(this));
    };
    SocialScrollView.prototype.createItem = function(item) {
        var surface = new SocialItemView({
            model: item
        });
        surface.pipe(this._eventOutput);
        this._eventInput.pipe(surface);
        return surface;
    };
    SocialScrollView.prototype.createSocialContacts = function() {
        this.contactSequence = this.collection.map(function(item) {
            return this.createItem(item);
        }.bind(this));
    };
    module.exports = SocialScrollView;
}.bind(this));

require.register("app/views/social-view.js", function(exports, require, module) {
    // import famous modules
    var View = require("famous/view");
    var Utility = require("famous/utilities/utility");
    var Scrollview = require("famous/views/scrollview");
    var HeaderFooterLayout = require("famous/views/header-footer-layout");
    var EventHandler = require("famous/event-handler");
    var Modifier = require("famous/modifier");
    var GenericSync = require("famous/input/generic-sync");
    var Surface = require("famous/surface");
    // import custom modules
    var InputSync = require("custom-input-sync");
    var TouchSync = InputSync.TouchSync;
    var MouseSync = InputSync.MouseSync;
    // import views
    var SocialItemView = require("social-item-view");
    function SocialView(options) {
        View.call(this);
        this.searchBarSize = 50;
        this.abcSurfaceWidth = 30;
        this.abcSurfaceHeight = undefined;
        this.a2zString = "ABCDEFGHIJKLMNOPQRSTUVWXYZ#";
        // Set up event handlers
        // this.eventInput = new EventHandler();
        // EventHandler.setInputHandler(this, this.eventInput);
        // this.eventOutput = new EventHandler();
        // EventHandler.setOutputHandler(this, this.eventOutput);
        this.headerFooterLayout = new HeaderFooterLayout({
            headerSize: this.searchBarSize,
            footerSize: 0
        });
        this.searchSurface = new Surface({
            size: [ undefined, this.searchBarSize ],
            classes: [ "import-section-search-bar" ],
            content: '<div><i class="fa fa-search"></i>   ' + '<input type="text" class="search-import" placeholder = "Search" ></div></div>',
            properties: {
                backgroundColor: "rgba(15,15,15,0.9)",
                color: "white",
                zIndex: 2
            }
        });
        this.abcSurface = new Surface({
            size: [ this.abcSurfaceWidth, this.abcSurfaceHeight ],
            classes: [ "abcButton" ],
            content: '<button id="A">A</button><button id="B">B</button><button id="C">C</button><button id="D">D</button><button id="E">E</button><button id="F">F</button><button id="G">G</button><button id="H">H</button><button id="I">I</button><button id="J">J</button><button id="K">K</button><button id="L">L</button><button id="M">M</button><button id="N">N</button><button id="O">O</button><button id="P">P</button><button id="Q">Q</button><button id="R">R</button><button id="S">S</button><button id="T">T</button><button id="U">U</button><button id="V">V</button><button id="W">W</button><button id="X">X</button><button id="Y">Y</button><button id="Z">Z</button><button id="#">#</button>',
            properties: {
                backgroundColor: "rgba(160,160,160,0.0)",
                zIndex: 2
            }
        });
        this.abcMod = new Modifier({
            origin: [ 1, 0 ]
        });
        this.collection = options.collection;
        this.scrollview = new Scrollview({
            direction: Utility.Direction.Y,
            margin: 1e4
        });
        this.headerFooterLayout.id.header.add(this.searchSurface);
        this.headerFooterLayout.id.content.add(this.scrollview);
        this.headerFooterLayout.id.content.add(this.abcMod).add(this.abcSurface);
        this.pipe(this.scrollview);
        this._add(this.headerFooterLayout);
        this.loadContacts();
        this.searchSurface.on("keyup", function(e) {
            this.loadContacts(e.target.value);
        }.bind(this));
        //    this.abcSurface.on('mousemove',function(e){
        //        this.onAbcTouch(e);
        //    }.bind(this));
        // abc-bar effect for cellphone
        var mousePosition = [ 0, 0 ];
        var sync = new GenericSync(function() {
            return mousePosition;
        }, {
            syncClasses: [ MouseSync, TouchSync ]
        });
        this.abcSurface.pipe(sync);
        sync.on("update", function(data) {
            var target = document.elementFromPoint(data.ap[0], data.ap[1]);
            if (target.id == undefined || target.id == "") return;
            var index = this.a2zString.indexOf(target.id);
            index = this.a2zIndexArray[index];
            if (index == undefined || index == this.curAbcIndex) return;
            this.curAbcIndex = index;
            this.scrollTo(index);
        }.bind(this));
    }
    SocialView.prototype = Object.create(View.prototype);
    SocialView.prototype.constructor = SocialView;
    SocialView.prototype.loadContacts = function(searchKey) {
        if (searchKey) this.currentCollection = this.collection.searchContact(searchKey.toUpperCase()); else this.currentCollection = this.collection;
        this.firstChar = undefined;
        this.a2zIndexArray = [ 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 ];
        this.currentCollection;
        var sequence = this.currentCollection.map(function(item) {
            return this.getIndex(item);
        }.bind(this));
        while (this.a2zIndexArray.indexOf(-1) != -1) {
            this.a2zIndexArray[this.a2zIndexArray.indexOf(-1)] = this.a2zIndexArray[this.a2zIndexArray.indexOf(-1) - 1];
        }
        // added empty item
        // media access bar messed up the height so add 40
        var lastGroupIndex = _.last(this.a2zIndexArray);
        var extraHeight = this.scrollview.getSize()[1] + 40;
        for (var i = lastGroupIndex; i < sequence.length; i++) {
            extraHeight -= sequence[i].getSize()[1];
        }
        if (extraHeight > 0) {
            var emptySurface = new Surface({
                size: [ undefined, extraHeight ]
            });
            emptySurface.pipe(this._eventOutput);
            sequence.push(emptySurface);
        }
        this.scrollview.sequenceFrom(sequence);
    };
    SocialView.prototype.onAbcTouch = function(e) {
        if (!this.abcButtons) this.abcButtons = $(".abcButton button");
        //            var index = Math.floor(27*(e.y-$('.abcButton').position().top)/(this.abcButtons.length*this.abcButtons.height()));
        var index = this.abcButtons.indexOf(e.target);
        index = this.a2zIndexArray[index];
        if (index == undefined || index == this.curAbcIndex) return;
        this.curAbcIndex = index;
        this.scrollTo(index);
    };
    SocialView.prototype.getIndex = function(item) {
        var isFirst = false;
        if (!/^[a-zA-Z]+$/.test(item.get("lastname")[0])) {
            if (this.firstChar != "#") {
                this.firstChar = "#";
                isFirst = "#";
                this.getCurrentIndex(item);
            }
        } else if (item.get("lastname") && this.firstChar != item.get("lastname")[0].toUpperCase()) {
            this.firstChar = item.get("lastname")[0].toUpperCase();
            isFirst = this.firstChar;
            this.getCurrentIndex(item);
        }
        var surface = new SocialItemView({
            model: item
        }, isFirst);
        surface.pipe(this._eventOutput);
        return surface;
    };
    SocialView.prototype.getCurrentIndex = function(item) {
        var index = this.currentCollection.indexOf(item);
        this.a2zIndexArray[this.a2zString.indexOf(this.firstChar)] = index;
    };
    SocialView.prototype.scrollTo = function(index, position) {
        if (index < 0) return;
        this.scrollview.setVelocity(0);
        this.scrollview.node.index = index;
        if (!position) position = 0;
        this.scrollview.setPosition(position);
    };
    module.exports = SocialView;
}.bind(this));

require.register("app/views/unused-add-favorite-view.js", function(exports, require, module) {
    // Import core Famous dependencies
    var HeaderFooterLayout = require("famous/views/header-footer-layout");
    var Surface = require("famous/surface");
    var EventHandler = require("famous/event-handler");
    var UpDownTransform = require("up-down-transform");
    function AddFavoriteView(options) {
        HeaderFooterLayout.call(this);
        var upDownTransform = new UpDownTransform();
        if (options.inTransform === undefined) this.options.inTransform = upDownTransform.options.inTransform;
        if (options.outTransform === undefined) this.options.outTransform = upDownTransform.options.outTransform;
        if (options.inTransition === undefined) this.options.inTransition = upDownTransform.options.inTransition;
        if (options.outTransition === undefined) this.options.outTransition = upDownTransform.options.outTransition;
        if (options.inOpacity === undefined) this.options.inOpacity = upDownTransform.options.inOpacity;
        if (options.outOpacity === undefined) this.options.outOpacity = upDownTransform.options.outOpacity;
        this.model = options.model;
        // Set up event handlers
        // this.eventInput = new EventHandler();
        // EventHandler.setInputHandler(this, this.eventInput);
        // this.eventOutput = new EventHandler();
        // EventHandler.setOutputHandler(this, this.eventOutput);
        this.header = new Surface({
            classes: [ "header" ],
            size: [ undefined, 50 ],
            properties: {},
            content: '<button class="left close-button cancel-favorite">Cancel</button><div>Add to Favor</div><button class="right close-button done-favorite">Done</button>'
        });
        this.content = new Surface({
            classes: [ "surface", "add-favorite-view" ],
            size: [ undefined, undefined ],
            properties: {
                backgroundColor: "transparent"
            }
        });
        this.id.header.add(this.header);
        this.id.content.add(this.content);
        this.content.on("click", function() {}.bind(this));
        this.template();
        this.content.pipe(this._eventOutput);
        this.header.pipe(this._eventOutput);
        this.header.on("click", function(e) {
            if (target.hasClass("close-button")) this._eventOutput.emit("showApp");
        }.bind(this));
    }
    AddFavoriteView.prototype = Object.create(HeaderFooterLayout.prototype);
    AddFavoriteView.prototype.constructor = AddFavoriteView;
    AddFavoriteView.prototype.template = function() {
        var html = '<form role="form">';
        html += '<div class="form-group small">';
        html += '<input type="text" class="form-control" id="input-first-name" placeholder="First">';
        html += "</div>";
        html += '<div class="form-group small">';
        html += '<input type="text" class="form-control" id="input-last-name" placeholder="Last">';
        html += "</div>";
        html += '<div class="form-group">';
        html += '<input type="email" class="form-control" id="input-email" placeholder="Email">';
        html += "</div>";
        html += "</form>";
        this.content.setContent(html);
    };
    module.exports = AddFavoriteView;
}.bind(this));

require.register("app/main/index.js", function(exports, require, module) {
    require("vendor");
    require("famous/polyfills");
    var MainController = require("main-controller");
    var mainController = new MainController();
}.bind(this));

require.register("app/main/main-controller.js", function(exports, require, module) {
    // import famous dependencies
    var FamousEngine = require("famous/engine");
    var Surface = require("famous/surface");
    var Easing = require("famous/transitions/easing");
    var EventHandler = require("famous/event-handler");
    var Helpers = require("helpers");
    // import custom views
    var LightBox = require("light-box");
    // import models
    var Models = require("models");
    var Contact = Models.Contact;
    var Call = Models.Call;
    //var CallCollection    = Models.CallCollection;
    var RecentsCollection = Models.RecentsCollection;
    var Settings = Models.Settings;
    var ContactCollection = Models.ContactCollection;
    // import views
    var Views = require("views");
    var AlertView = Views.AlertView;
    var CameraView = Views.CameraView;
    var AddContactView = Views.AddContactView;
    var OutgoingCallView = Views.OutgoingCallView;
    var IncomingCallView = Views.IncomingCallView;
    var ConnectedCallView = Views.ConnectedCallView;
    var FavoritesSectionView = Views.FavoritesSectionView;
    var ChatsSectionView = Views.ChatsSectionView;
    var RecentsSectionView = Views.RecentsSectionView;
    var ContactsSectionView = Views.ContactsSectionView;
    var SettingsSectionView = Views.SettingsSectionView;
    // import app
    var config = require("config");
    var App = require("app");
    var defaultIceConfig = {
        iceServers: [ {
            url: "stun:stun.l.google.com:19302"
        } ]
    };
    function MainController() {
        // Set up event handlers
        this._eventInput = new EventHandler();
        EventHandler.setInputHandler(this, this._eventInput);
        this._eventOutput = new EventHandler();
        EventHandler.setOutputHandler(this, this._eventOutput);
        this.loadUser(function(data) {
            if (data.chatroom) {
                this.chatroom = data.chatroom;
                data.objectId = "dcr" + data.chatroom.objectId;
                data.firstname = data.chatroom.calleeFirstName;
                data.lastname = data.chatroom.calleeLastName;
                data.username = data.chatroom.calleeName;
            }
            // Set up models and collections
            this.appSettings = new Settings({
                id: data.objectId
            });
            this.appSettings.fetch();
            this.appSettings.save({
                cid: data.objectId,
                email: data.email || "",
                firstname: data.firstname || data.username || "",
                lastname: data.lastname || "",
                username: data.username || ""
            });
            this.appSettings.me = data;
            this.appSettings = this.appSettings;
            this.contactCollection = new ContactCollection([], {
                firebase: this.appSettings.get("firebaseUrl") + "users/" + this.appSettings.get("cid") + "/contacts"
            });
            this.recentCalls = new RecentsCollection([], {
                firebase: this.appSettings.get("firebaseUrl") + "history/" + this.appSettings.get("cid") + "/calls"
            });
            this.recentChats = new RecentsCollection([], {
                firebase: this.appSettings.get("firebaseUrl") + "history/" + this.appSettings.get("cid") + "/chats"
            });
            this.curCall = new Call();
            // Set up views
            var favoritesSection = new FavoritesSectionView({
                collection: this.contactCollection
            });
            var chatsSection = new ChatsSectionView({
                collection: this.recentChats
            });
            var recentsSection = new RecentsSectionView({
                collection: this.recentCalls
            });
            var contactsSection = new ContactsSectionView({
                collection: this.contactCollection
            });
            var settingsSection = new SettingsSectionView({
                model: this.appSettings
            });
            favoritesSection.pipe(this._eventOutput);
            this._eventInput.pipe(favoritesSection);
            chatsSection.pipe(this._eventOutput);
            this._eventInput.pipe(chatsSection);
            recentsSection.pipe(this._eventOutput);
            this._eventInput.pipe(recentsSection);
            contactsSection.pipe(this._eventOutput);
            this._eventInput.pipe(contactsSection);
            settingsSection.pipe(this._eventOutput);
            // Config and initialize app
            config.sections = [ chatsSection, recentsSection, contactsSection, settingsSection ];
            // create the App from the template
            var myApp = new App(config);
            this.myLightbox = new LightBox({
                overlap: true
            });
            var alertLightbox = new LightBox({
                overlap: true
            });
            var addContactView = new AddContactView({
                collection: this.contactCollection
            });
            myApp.pipe(this._eventOutput);
            addContactView.pipe(this._eventOutput);
            var cameraView = new CameraView({});
            // create a display context and hook in the App
            var mainDisplay = FamousEngine.createContext();
            mainDisplay.add(cameraView);
            mainDisplay.add(this.myLightbox);
            mainDisplay.add(alertLightbox);
            this.myLightbox.show(myApp);
            FamousEngine.pipe(myApp);
            // start on the main section
            myApp.select(myApp.options.sections[2].title);
            this.outgoingCallView = new OutgoingCallView({
                collection: this.recentCalls
            });
            this.incomingCallView = new IncomingCallView({
                collection: this.recentCalls
            });
            this.connectedCallView = new ConnectedCallView({
                collection: this.recentCalls
            });
            this.outgoingCallView.pipe(this._eventOutput);
            this.incomingCallView.pipe(this._eventOutput);
            this.connectedCallView.pipe(this._eventOutput);
            this.pipe(this.connectedCallView._eventInput);
            // events handling
            this._eventOutput.on("callEnd", onCallEnd);
            this._eventOutput.on("incomingCall", onIncomingCall);
            this._eventOutput.on("outgoingCall", onOutgoingCall);
            this._eventOutput.on("connectedCall", onConnectedCall);
            this._eventOutput.on("outGoingCallAccept", onOutGoingCallAccept);
            this._eventOutput.on("editContact", onEditContact);
            this._eventOutput.on("chatContact", _.debounce(onChatContact, 300));
            this._eventOutput.on("showApp", onShowApp);
            this._eventOutput.on("submitContact", onSubmitContact);
            this._eventOutput.on("chatOn", onChatOn);
            this._eventOutput.on("chatOff", onChatOff);
            this._eventOutput.on("chatRead", onChatRead);
            this._eventOutput.on("loadRecent", onLoadRecent);
            this._eventOutput.on("updateRecent", onUpdateRecent);
            this._eventOutput.on("clearRecent", onClearRecent);
            this._eventOutput.on("deleteItem", onDeleteItem);
            this._eventOutput.on("deleteFavorite", onDeleteFavorite);
            this._eventOutput.on("toggleFavorite", onToggleFavorite);
            this._eventOutput.on("onEngineClick", onEngineClick);
            this._eventOutput.on("closeAlert", onCloseAlert);
            this._eventOutput.on("editContactDone", onEditContactDone);
            this._eventOutput.on("addContactDone", onAddContactDone);
            this._eventOutput.on("triggerBackToNoneEditing", onTriggerBackToNoneEditing.bind(this));
            this.buttonOnclickRespond();
            function onDeleteFavorite(model) {
                model.toggleFavorite();
            }
            function onToggleFavorite(model) {
                model.toggleFavorite();
            }
            function onDeleteItem(model) {
                model.collection.remove(model);
            }
            function onEditContactDone(formContact) {}
            function onAddContactDone(formContact) {}
            function onUpdateRecent(e) {
                recentsSection.updateItems();
            }
            function onLoadRecent(e) {
                recentsSection.setMissedOnly(e.target.outerText);
            }
            function onClearRecent(e) {
                recentsSection.clearAll();
            }
            function onShowApp(eventData) {
                var callback;
                if (eventData instanceof Function) {
                    callback = eventData;
                }
                $(".camera").addClass("blur");
                this.myLightbox.show(myApp, true, callback);
            }
            function onOutGoingCallAccept(callee) {
                this.outgoingCallView.accept(callee);
            }
            function onConnectedCall(eventData) {
                var callback;
                var call;
                if (eventData instanceof Function) {
                    callback = eventData;
                } else {
                    call = eventData;
                }
                this.connectedCallView.start(this.appSettings, call);
                this.myLightbox.show(this.connectedCallView, true, callback);
                if (call.get("success")) {
                    if (!this.localStream) {
                        alert("Please allow camera/microphone access for Beepe");
                    } else {
                        this._eventOutput.emit("chatOn");
                    }
                }
            }
            function onOutgoingCall(eventData) {
                this.outgoingCallView.start(eventData, this.appSettings);
                this.myLightbox.show(this.outgoingCallView, true);
            }
            function onIncomingCall(eventData) {
                function onShowNotification() {}
                function onCloseNotification() {
                    parent.focus();
                }
                function onClickNotification() {
                    parent.focus();
                }
                if (this.appSettings.get("notification") && !window.colabeoBody) {
                    this.callNotification = new Notify("Incoming Call From", {
                        icon: "content/ios_icon_x144.png",
                        body: eventData.get("firstname") + " " + eventData.get("lastname"),
                        notifyShow: onShowNotification.bind(this),
                        notifyClose: onCloseNotification.bind(this),
                        notifyClick: onClickNotification.bind(this)
                    });
                    this.callNotification.show();
                }
                var curView = this.myLightbox.curRenderable;
                if (curView instanceof IncomingCallView) return;
                if (curView instanceof OutgoingCallView) {
                    this.outgoingCallView.accept(eventData);
                    this._eventOutput.emit("incomingCallAnswer", eventData);
                } else {
                    this.incomingCallView.start(eventData);
                    this.myLightbox.show(this.incomingCallView, true);
                }
            }
            function onCallEnd(eventData) {
                this._eventOutput.emit("chatOff");
                // ligntbox shown object stop
                // TODO: hack
                var curView = this.myLightbox.curRenderable;
                if (curView instanceof IncomingCallView || curView instanceof ConnectedCallView) {
                    curView.stop(eventData);
                }
                //            if (this.phono && this.phono.phone && this.phono.phone.calls) _.chain(this.phono.phone.calls).values().invoke('hangup');
                if (this.chatroom) {
                    var url = "/login?r=" + this.chatroom.uuid;
                    if (this.chatroom.callerName) {
                        url += "&fn=" + this.chatroom.callerName;
                    }
                    window.location = url;
                }
                if (eventData.chat) this._eventOutput.emit("chatRead", eventData.chat);
            }
            function onEditContact(eventData) {
                if (eventData instanceof Contact || eventData instanceof Call) addContactView.setContact(eventData); else addContactView.setContact(undefined);
                addContactView.renderContact();
                this.myLightbox.show(addContactView, true);
            }
            function onChatContact(eventData) {
                function chatByContact(contact) {
                    contact = new Contact(contact.omit("success"));
                    this._eventOutput.emit("connectedCall", contact);
                }
                if (eventData instanceof Contact || eventData instanceof Call) {
                    if (eventData.get("cid")) {
                        chatByContact.bind(this)(eventData);
                    } else {
                        this.lookup(eventData, chatByContact.bind(this), this.onUserNotFound.bind(this));
                    }
                }
            }
            function onChatOn() {
                cameraView.turnOn();
            }
            function onChatOff() {
                cameraView.turnOff();
            }
            function onChatRead(contact) {
                var chat = _(chatsSection.collection.models).find(function(chat) {
                    return chat.get("cid") == contact.get("cid");
                });
                if (chat) {
                    chat.set({
                        read: true
                    });
                }
            }
            function onSubmitContact(contact) {
                if (contact.get("cid") || contact.get("dcr")) return;
                this.lookup(contact, null, function(contact, query) {
                    this.setupChatroom(contact, query);
                }.bind(this));
            }
            FamousEngine.on("click", onEngineClick.bind(this));
            function onEngineClick(e) {
                switch (e.target.id) {
                  case "clear-button":
                    this._eventOutput.emit("clearRecent");
                    break;

                  case "add-contact":
                    this._eventOutput.emit("editContact");
                    break;

                  case "chats-edit-contact":
                    $("body").toggleClass("editing");
                    this._eventInput.emit("toggleAllChat");
                    break;

                  case "recent-edit-contact":
                    $("body").toggleClass("editing");
                    this._eventInput.emit("toggleAllRecent");
                    break;

                  case "favorite-edit-contact":
                    $("body").toggleClass("editing");
                    this._eventInput.emit("toggleAllFavorite");
                    break;

                  case "contact-edit-contact":
                    $("body").toggleClass("editing");
                    this._eventInput.emit("toggleAllContact");
                    break;

                  case "recent-toggle":
                    this._eventOutput.emit("loadRecent", e);
                    break;

                  case "close-alert":
                    this._eventOutput.emit("closeAlert");
                }
                if (e.target.tagName == "INPUT" || e.target.tagName == "TEXTAREA") {
                    $(e.target).focus();
                    this._input = e.target;
                } else if (e.target.className == "send-text-button") {
                    $(this._input).focus();
                } else {
                    if (this._input) {
                        $(this._input).blur();
                        this._input = null;
                    }
                }
            }
            // fastclick hack
            //        $('body').on('click', 'input', function(e) {
            //            $(e.target).focus();
            //        }.bind(this));
            function onTriggerBackToNoneEditing(e) {
                this._eventInput.emit("backToNoneEditing");
            }
            function onAlert(word, okHidden) {
                var alertView = new AlertView(word, okHidden);
                alertLightbox.show(alertView, true);
            }
            function onCloseAlert() {
                alertLightbox.hide();
            }
            window.alert = onAlert;
            if (this.chatroom) alert("Please allow Beepe to use your camera/microphone for phone calls.", true);
            this.init();
            //        if (Helpers.isDev()){
            window.colabeo = this;
            colabeo.chatsSection = chatsSection;
            colabeo.recentsSection = recentsSection;
            colabeo.contactsSection = contactsSection;
            colabeo.favoritesSection = favoritesSection;
            colabeo.cameraView = cameraView;
            colabeo.addContactView = addContactView;
            colabeo.app = myApp;
            colabeo.engine = FamousEngine;
            colabeo.social = {};
            //        }
            window._cola_g = {};
            _cola_g.cid = this.appSettings.get("cid");
        }.bind(this));
    }
    MainController.prototype.init = function() {
        //    this.phono = $.phono({
        //        apiKey: "233f5673a7329a4cb7a5a2d0e5b6696e9ec245f8f7410e0631f4938c4395ca3163db86f7a9eda9d42633a308",
        //        onReady: function() {
        //
        //        }
        //    });
        this.iceServerConfig = defaultIceConfig;
        // get Xirsys ice config
        this.getXirsys();
        this.disableNow = false;
        var userId = this.appSettings.get("cid");
        var userFullName = this.appSettings.get("firstname") + " " + this.appSettings.get("lastname");
        this.listenRef = new Firebase(this.appSettings.get("firebaseUrl") + "calls/" + userId);
        // remove zombie call after disconnect
        this.listenRef.onDisconnect().remove();
        if (Helpers.isMobile()) {
            window._disableResize = true;
            $("body").addClass("mobile");
            if (this.appSettings.get("blur") == undefined) this.appSettings.set("blur", false);
        } else {
            if (this.appSettings.get("blur") == undefined) this.appSettings.set("blur", true);
        }
        this.setupCallListener();
        this.setupVideo();
        this.setupSettingsListener();
        this.loadConnected(function(data) {
            if (!data || !Array.isArray(data)) return;
            var linkAccounts = {};
            data.map(function(item) {
                linkAccounts[item.provider] = true;
            });
            this.appSettings.save({
                linkAccounts: linkAccounts
            });
        }.bind(this));
        // TODO: hack for android chrome DATAconnection
        util.supports.sctp = false;
        sendMessage("event", {
            data: {
                action: "syncID",
                id: userId,
                name: userFullName
            }
        });
        //        window.addEventListener("message", onMessage.bind(this), false);
        if (window.colabeoBody) window.colabeoBody.addEventListener("FromExtension", onExtensionMessage.bind(this));
    };
    MainController.prototype.setupSettingsListener = function() {
        this._eventOutput.on("outgoingChat", function(evt) {
            this.outgoingChat(evt.content, evt.type);
        }.bind(this));
        this._eventOutput.on("sendChat", this.sendChat.bind(this));
        this._eventOutput.on("setCamera", function() {
            this.setCamera();
        }.bind(this));
        this._eventOutput.on("setVideo", function() {
            this.setVideo();
        }.bind(this));
        this._eventOutput.on("setBlur", function() {
            this.setBlur();
        }.bind(this));
        this._eventOutput.on("setAudio", function() {
            this.setAudio();
        }.bind(this));
        this._eventOutput.on("onSocialLink", function(source) {
            var url;
            if (source == "facebook") {
                url = "/connect/facebook/email";
            } else if (source == "google") {
                url = "/connect/google/profile%20email%20https%3A%2F%2Fwww.googleapis.com%2Fauth%2Fplus.login%20https%3A%2F%2Fwww.googleapis.com%2Fauth%2Fplus.me";
            }
            if (url) {
                //                if (Helpers.isMobile()) {
                //                    window.location = url;
                //                } else {
                $.oauthpopup({
                    path: url,
                    callback: function(e) {
                        setTimeout(function() {
                            $("div.import-contact#" + source + ":not(.done)").click().addClass("done");
                        }.bind(this), 300);
                    }
                });
            }
        });
        $("body").on("change", "#audio, #video", function(e) {
            this.appSettings.set($(e.target)[0].id, $(e.target).prop("checked"));
        }.bind(this));
    };
    //MainController.prototype.callByPhono = function(contact) {
    //    var number = contact.get('email');
    //    this.phono.phone.dial("app:9990036398", {
    //        headers: [
    //            {
    //                name:"x-numbertodial",
    //                value: number
    //            }
    //        ],
    //        onRing: function() {
    //            console.log("*******Ringing");
    //        }.bind(this),
    //        onAnswer: function() {
    //            console.log("*******Answered");
    //            contact = new Contact(contact.omit('success'));
    //            contact.set({
    //                success: true
    //            });
    //            this._eventOutput.emit('outGoingCallAccept', contact);
    //            this._eventOutput.emit('connectedCall', contact);
    //        }.bind(this),
    //        onHangup: function() {
    //            console.log("*******Hungup");
    //            this._eventOutput.emit('callEnd', {exit: true});
    //        }.bind(this)
    //    });
    //};
    MainController.prototype.setupCallListener = function() {
        this.listenRef.on("child_added", onAdd.bind(this));
        this.listenRef.on("child_changed", onChanged.bind(this));
        this.listenRef.on("child_removed", onRemove.bind(this));
        this._eventOutput.on("outgoingCallEnd", onOutgoingCallEnd.bind(this));
        this._eventOutput.on("incomingCallEnd", onIncomingCallEnd.bind(this));
        this._eventOutput.on("incomingCallAnswer", onIncomingCallAnswer.bind(this));
        this._eventOutput.on("outgoingCall", onOutgoingCall.bind(this));
        this._eventOutput.on("sync", onSync.bind(this));
        function onAdd(snapshot) {
            var f = snapshot.val().firstname || snapshot.val().person.split(" ")[0];
            var l = snapshot.val().lastname || snapshot.val().person.split(" ")[1];
            var e = snapshot.val().email;
            var p = snapshot.val().pictureUrl || false;
            var c = snapshot.val()["name"] == "unknown" ? "" : snapshot.val()["name"];
            var r = snapshot.name();
            var call = new Call({
                firstname: f,
                lastname: l,
                email: e,
                pictureUrl: p,
                roomId: r,
                caller: c
            });
            this._eventOutput.emit("incomingCall", call);
        }
        function onChanged(snapshot) {
            // this solves multiple beepe incoming call problem
            var refCallState = snapshot.val()["state"];
            if (refCallState == "answered") {
                var curView = this.myLightbox.curRenderable;
                if (curView instanceof IncomingCallView) curView.stop();
            }
        }
        function onRemove(snapshot) {
            this._eventOutput.emit("callEnd", {
                exit: false
            });
            this.exitRoom();
        }
        function onOutgoingCallEnd(call) {
            if (this.callRef) this.callRef.remove();
            this.exitRoom();
        }
        function onIncomingCallEnd(call) {
            if (this.listenRef) this.listenRef.remove();
            this.exitRoom();
            if (this.callNotification && this.callNotification.myNotify) this.callNotification.myNotify.close();
        }
        function onIncomingCallAnswer(call) {
            if (call instanceof Call) {
                var caller = call.get("caller");
                var callee = this.appSettings.get("cid");
                var roomId = call.get("roomId");
                if (roomId) {
                    this.listenRef.child(roomId).update({
                        state: "answered"
                    });
                    this.joinRoom(caller, callee, roomId);
                }
            }
            if (this.callNotification && this.callNotification.myNotify) this.callNotification.myNotify.close();
        }
        function onOutgoingCall(contact) {
            if (!this.localStream) {
                alert("Please allow camera/microphone access for Beepe");
                return;
            }
            //        if (!isNaN(contact.get('email')) && contact.get('email').length==11) {
            //            this.callByPhono(contact);
            //        }
            //        else
            if (contact.get("cid")) {
                callByContact.bind(this)(contact);
            } else {
                this.lookup(contact, callByContact.bind(this), this.onUserNotFound.bind(this));
            }
            function callByContact(contact) {
                var id = contact.get("cid");
                var provider = contact.get("provider");
                if (!id) return;
                var recentsRef = new Firebase(this.appSettings.get("firebaseUrl") + "history/" + id + "/calls");
                var newCall = {
                    firstname: this.appSettings.get("firstname"),
                    lastname: this.appSettings.get("lastname"),
                    email: this.appSettings.get("email"),
                    pictureUrl: false,
                    type: "incoming",
                    time: Firebase.ServerValue.TIMESTAMP,
                    cid: this.appSettings.get("cid")
                };
                recentsRef.push(newCall);
                // TODO: delete hack
                //    delete recentsRef;
                this.callRef = new Firebase(this.appSettings.get("firebaseUrl") + "calls/" + id);
                // remove zombie call after disconnect
                this.callRef.onDisconnect().remove();
                var callerFullName = this.appSettings.get("firstname") + " " + this.appSettings.get("lastname");
                var callObj = {
                    name: this.appSettings.get("cid"),
                    person: callerFullName,
                    firstname: this.appSettings.get("firstname"),
                    lastname: this.appSettings.get("lastname"),
                    state: "calling"
                };
                if (this.appSettings.get("email")) callObj.email = this.appSettings.get("email");
                if (this.appSettings.get("username")) callObj.username = this.appSettings.get("username");
                this.callRef.once("value", function(snapshot) {
                    if (snapshot.val() == null) {
                        this.callRef.push(callObj);
                        this.callRef.once("child_changed", onChanged.bind(this));
                        this.callRef.once("child_removed", onRemove.bind(this));
                    } else {}
                }.bind(this));
                function onChanged(snapshot) {
                    var refCallState = snapshot.val()["state"];
                    if (refCallState == "answered") {
                        var caller = this.appSettings.get("cid");
                        var callee = id;
                        var roomId = snapshot.name();
                        this.startRoom(caller, callee, roomId);
                        this._eventOutput.emit("outGoingCallAccept", callee);
                    }
                }
                function onRemove(snapshot) {
                    this._eventOutput.emit("callEnd", {
                        exit: false
                    });
                    this.exitRoom();
                }
            }
        }
        function onSync() {
            this.onSyncButton();
        }
    };
    /* start of peer call */
    MainController.prototype.setupVideo = function() {
        // Compatibility shim
        navigator.getUserMedia = navigator.getUserMedia || navigator.webkitGetUserMedia || navigator.mozGetUserMedia;
        //        this.startRoom();
        if (navigator.getUserMedia) this.setCamera();
    };
    MainController.prototype.initLocalMedia = function(options) {
        var options = _.extend({
            audio: true,
            video: true
        }, options);
        // Get audio/video stream
        navigator.getUserMedia(options, function(stream) {
            // Set your video displays
            $(".local-video video").prop("src", URL.createObjectURL(stream));
            this.localStream = stream;
            this.cleanRoom();
            this.setBlur();
            this.setAudio();
            if (options.video) $(".camera").removeClass("off"); else $(".camera").addClass("off");
            this._eventOutput.emit("closeAlert");
            if (this.chatroom) {
                var call = new Call({
                    firstname: this.chatroom.callerFirstName || this.chatroom.callerName || "",
                    lastname: this.chatroom.callerLastName || "",
                    email: this.chatroom.callerAccountId || "",
                    cid: this.chatroom.caller || "",
                    provider: this.chatroom.calleeAccountProvider || ""
                });
                this._eventOutput.emit("outgoingCall", call);
            }
        }.bind(this), function() {
            //                alert("Please allow camera access for Beepe");
            $(".camera").addClass("off");
        }.bind(this));
    };
    MainController.prototype.initRemoteMedia = function(call) {
        // Hang up on an existing call if present
        if (this.existingCall) {
            this.existingCall.close();
        }
        // Wait for stream on the call, then set peer video display
        call.on("stream", function(stream) {
            $(".remote-video video").prop("src", URL.createObjectURL(stream));
        }.bind(this));
        // UI stuff
        this.existingCall = call;
        call.on("close", this.cleanRoom.bind(this));
    };
    MainController.prototype.startRoom = function(caller, callee, roomId) {
        if (roomId) roomId = "A" + roomId + "Z";
        // PeerJS object
        this.peer = new Peer(roomId, {
            //            debug: 0,
            host: this.appSettings.get("pHost"),
            port: this.appSettings.get("pPort"),
            secure: this.appSettings.get("pSecure"),
            config: this.iceServerConfig
        });
        this.peer.on("open", function() {}.bind(this));
        // Receiving a call
        this.peer.on("call", function(call) {
            call.answer(this.localStream);
            this.initRemoteMedia(call);
            sendMessage("event", {
                data: {
                    action: "setProperty",
                    roomId: roomId
                }
            });
        }.bind(this));
        // Receiving data
        this.peer.on("connection", function(conn) {
            this.setupPeerConn(conn);
        }.bind(this));
        this.peer.on("error", function(err) {}.bind(this));
    };
    MainController.prototype.joinRoom = function(caller, callee, roomId) {
        if (roomId) roomId = "A" + roomId + "Z";
        // PeerJS object
        this.peer = new Peer({
            host: this.appSettings.get("pHost"),
            port: this.appSettings.get("pPort"),
            secure: this.appSettings.get("pSecure"),
            config: this.iceServerConfig
        });
        setTimeout(function() {
            // Initiate a call!
            var call = this.peer.call(roomId, this.localStream);
            this.initRemoteMedia(call);
            sendMessage("event", {
                data: {
                    action: "setProperty",
                    roomId: roomId
                }
            });
            var conn = this.peer.connect(roomId, {
                label: "chat",
                reliable: false
            });
            this.setupPeerConn(conn);
        }.bind(this), 1e3);
    };
    MainController.prototype.getXirsys = function(callback) {
        $.post("https://api.xirsys.com/getIceServers", {
            domain: "dashboard.colabeo.com",
            room: "default",
            application: "default",
            ident: "chapman",
            secret: "02f0e22c-764e-4939-8042-4ea028e9b8e0",
            secure: 0
        }, function(data, status) {
            if (data) {
                var xirsys = JSON.parse(data);
                var iceServerXIR = xirsys.d;
                if (iceServerXIR) {
                    this.iceServerConfig = {
                        iceServers: defaultIceConfig.iceServers.concat(iceServerXIR.iceServers)
                    };
                }
            }
            if (callback) callback(iceServer);
        }.bind(this));
    };
    MainController.prototype.setupPeerConn = function(conn) {
        this.conn = conn;
        this.conn.on("open", function() {
            // Receive messages
            this.conn.on("data", onMessage.bind(this));
        }.bind(this));
    };
    MainController.prototype.exitRoom = function() {
        if (this.existingCall) {
            this.existingCall.close();
        }
        sendMessage("event", {
            data: {
                action: "setProperty",
                roomId: null
            }
        });
        sendMessage("event", {
            data: {
                action: "endCall"
            }
        });
        this.cleanRoom();
    };
    MainController.prototype.cleanRoom = function() {
        if (this.peer) this.peer.destroy();
        if (this.conn) this.conn.close();
    };
    /* end of peer call */
    MainController.prototype.setCamera = function() {
        this.initLocalMedia({
            video: this.appSettings.get("camera"),
            audio: true
        });
    };
    MainController.prototype.setBlur = function() {
        var on = this.appSettings.get("blur");
        if (on) $(".camera").removeClass("fakeblur"); else $(".camera").addClass("fakeblur");
    };
    MainController.prototype.setAudio = function() {
        var audio = this.appSettings.get("audio");
        if (this.localStream) {
            var audioTracks = this.localStream.getAudioTracks();
            for (var i = 0, l = audioTracks.length; i < l; i++) {
                audioTracks[i].enabled = audio;
            }
        }
    };
    MainController.prototype.setVideo = function() {
        var video = this.appSettings.get("video");
        var camera = this.appSettings.get("camera");
        if (this.localStream && camera) {
            var videoTracks = this.localStream.getVideoTracks();
            for (var i = 0, l = videoTracks.length; i < l; i++) {
                videoTracks[i].enabled = video;
            }
            if (video) $(".camera").removeClass("off"); else $(".camera").addClass("off");
        }
    };
    MainController.prototype.lookup = function(data, callback, onFailure) {
        var query = [];
        // TODO: add more providers here in the future
        [ "email", "facebook", "google", "linkedin", "github", "yammer" ].map(function(provider) {
            if (data.get(provider)) {
                query.push({
                    provider: provider,
                    eid: data.get(provider).id || data.get(provider)
                });
            }
        });
        if (query.length) {
            multipleLookup(query, function(result) {
                if (result.length) {
                    var callee = _.last(result);
                    var cid;
                    if (callee.user && callee.user.objectId) cid = callee.user.objectId; else if (callee.objectId) cid = callee.objectId;
                    // This might not be good if the user's cid changes in the future
                    console.log(data);
                    data.set({
                        cid: cid
                    });
                    if (callback) callback(data);
                } else {
                    if (onFailure) onFailure(data, query);
                }
            }.bind(this));
        } else {
            alert("This contact is empty.");
        }
    };
    MainController.prototype.sendChat = function(chat) {
        var message = chat.message;
        var id = chat.contact.get("cid");
        if (!id) return;
        var userId = this.appSettings.get("cid");
        var toRef = new Firebase(this.appSettings.get("firebaseUrl") + "chats/" + id + "/" + userId);
        var fromRef = new Firebase(this.appSettings.get("firebaseUrl") + "chats/" + userId + "/" + id);
        var chatObj = {
            content: message,
            type: "text",
            from: userId,
            time: Firebase.ServerValue.TIMESTAMP
        };
        toRef.push(chatObj);
        fromRef.push(chatObj);
        var recentsRef = new Firebase(this.appSettings.get("firebaseUrl") + "history/" + id + "/chats/" + userId);
        var newChat = {
            firstname: this.appSettings.get("firstname"),
            lastname: this.appSettings.get("lastname"),
            email: this.appSettings.get("email"),
            pictureUrl: false,
            time: Firebase.ServerValue.TIMESTAMP,
            cid: this.appSettings.get("cid"),
            content: message,
            type: "text",
            read: false
        };
        recentsRef.set(newChat);
        var chatsRef = new Firebase(this.appSettings.get("firebaseUrl") + "history/" + userId + "/chats/" + id);
        var newChat = {
            firstname: chat.contact.get("firstname"),
            lastname: chat.contact.get("lastname"),
            email: chat.contact.get("email"),
            pictureUrl: false,
            time: Firebase.ServerValue.TIMESTAMP,
            cid: id,
            content: message,
            type: "text",
            read: true
        };
        chatsRef.set(newChat);
    };
    MainController.prototype.loadUser = function(done) {
        if (location.pathname == "/call" || location.pathname.match("/dcr/")) {
            var params = parseQueryString();
            var room = params["r"] ? params["r"][0] : location.pathname.split("/")[2];
            if (room) {
                $.ajax({
                    url: "/chatroom?id=" + room,
                    type: "get",
                    dataType: "json",
                    success: function(data) {
                        if (done) done({
                            chatroom: data
                        });
                    },
                    error: function() {
                        console.log("error");
                        // TODO: temp dev user
                        if (done) done({});
                    }
                });
            }
        } else {
            $.ajax({
                url: "/me",
                type: "get",
                dataType: "json",
                success: function(data) {
                    if (done) done(data);
                },
                error: function() {
                    console.log("error");
                    // TODO: temp dev user
                    if (done) done({});
                }
            });
        }
        function parseQueryString() {
            var query = (window.location.search || "?").substr(1), map = {};
            query.replace(/([^&=]+)=?([^&]*)(?:&+|$)/g, function(match, key, value) {
                (map[key] = map[key] || []).push(value);
            });
            return map;
        }
    };
    MainController.prototype.loadConnected = function(done) {
        $.ajax({
            url: "/connected",
            type: "get",
            dataType: "json",
            success: function(data) {
                if (done) done(data);
            },
            error: function() {
                console.log("error");
                // TODO: temp dev user
                if (done) done({});
            }
        });
    };
    MainController.prototype.loadContact = function(source, done) {
        $.ajax({
            url: "/contact/" + source,
            type: "get",
            dataType: "json",
            success: function(data) {
                if (done) done(data);
            },
            error: function() {
                console.log("error");
                // TODO: temp dev user
                if (done) done({});
            }
        });
    };
    MainController.prototype.setupChatroom = function(contact, eids, callback) {
        for (var i = 0; i < eids.length; i++) {
            var c = eids[i];
            if (c) {
                var callee = {
                    provider: c.provider,
                    eid: c.eid,
                    name: contact.get("firstname") + " " + contact.get("lastname"),
                    firstname: contact.get("firstname"),
                    lastname: contact.get("lastname"),
                    email: contact.get("email")
                };
                $.ajax({
                    url: "/chatroom",
                    type: "post",
                    data: {
                        callee: JSON.stringify(callee),
                        // 0: do nothing 1: chatroom invite 2: missed call
                        e: 1,
                        d: 0
                    },
                    success: function(data) {
                        contact.set({
                            dcr: data.chatid
                        });
                        if (callback) callback(contact);
                    },
                    error: function() {}
                });
            }
        }
    };
    MainController.prototype.onSyncButton = function() {
        sendMessage("event", {
            data: {
                action: "sync"
            }
        });
    };
    MainController.prototype.outgoingChat = function(message, type) {
        if (!type) type = "text";
        if (this.conn) this.conn.send({
            content: message,
            type: type,
            action: "chat"
        });
    };
    function userLookup(externalId, provider, done) {
        $.ajax({
            url: "/finduser",
            type: "get",
            dataType: "json",
            data: {
                provider: provider,
                externalId: externalId
            },
            success: function(data) {
                done(data);
            },
            error: function() {
                console.log("error");
                // TODO: show default call for now
                done(new Call());
            }
        });
    }
    function multipleLookup(query, done) {
        query = JSON.stringify(query);
        $.ajax({
            url: "/findusers",
            type: "get",
            dataType: "json",
            data: {
                query: query
            },
            success: function(data) {
                done(data);
            },
            error: function() {
                console.log("error");
                // TODO: show default call for now
                done(new Call());
            }
        });
    }
    function sendMessage(type, data) {
        if (Helpers.isMobile()) return;
        if (!window.colabeoBody) return;
        var evt = new CustomEvent("FromKoala", {
            detail: {
                type: type,
                data: data
            }
        });
        window.colabeoBody.dispatchEvent(evt);
    }
    function updateSync() {
        if (this.remoteUrl == this.localUrl) $(".sync-button").removeClass("syncing").addClass("synced"); else $(".sync-button").removeClass("synced syncing");
    }
    function onExtensionMessage(e) {
        if (e.detail.action == "updateUrl") {
            if (e.detail.source == "remote") this.remoteUrl = e.detail.url; else this.localUrl = e.detail.url;
            updateSync.bind(this)();
        }
        if (this.disableNow) return;
        if (e.detail.action == "incoming") {
            var call = new Call({
                firstname: e.detail.firstname,
                lastname: e.detail.lastname,
                email: e.detail.email,
                pictureUrl: null,
                roomId: e.detail.room
            });
            this._eventOutput.emit("incomingCall", call);
        } else if (this.conn) {
            // peer message forward
            this.conn.send(e.detail);
        }
    }
    function onMessage(e) {
        this.disableNow = true;
        setTimeout(function() {
            this.disableNow = false;
        }.bind(this), 1e3);
        var evt = e;
        if (evt.action == "chat") {
            this._eventOutput.emit("incomingChat", evt);
        } else {
            if (Helpers.isMobile() && evt.data && evt.data.url && evt.data.action == "urlChange") {
                window.open(evt.data.url);
            }
            sendMessage("event", evt);
        }
    }
    MainController.prototype.buttonOnclickRespond = function() {
        this.activedButton = undefined;
        this.activedClassList = ".touchable";
        $(document).on("mousedown touchstart", this.activedClassList, function(e) {
            this.activedButton = $(e.currentTarget);
            this.activedButton.addClass("touchable-active");
        }.bind(this));
        $(document).on("mouseout", this.activedClassList, function(e) {
            if (this.activedButton) {
                this.activedButton.removeClass("touchable-active");
                this.activedButton.one("mouseover", function(ee) {
                    this.activedButton.addClass("touchable-active");
                }.bind(this));
            }
        }.bind(this));
        $(document).on("mouseup touchend", function(e) {
            if (this.activedButton) {
                setTimeout(function() {
                    this.activedButton.removeClass("touchable-active");
                    this.activedButton.off();
                    this.activedButton = undefined;
                }.bind(this), 200);
            }
        }.bind(this));
    };
    MainController.prototype.onUserNotFound = function(contact, query) {
        alert("The user you are reaching is not a Beepe user. Please send an invite.");
        if (contact.get("dcr")) {
            this._eventOutput.emit("editContact", contact);
        } else {
            this.setupChatroom(contact, query, function() {
                this._eventOutput.emit("editContact", contact);
            }.bind(this));
        }
        this.outgoingCallView.stopCalltone();
    };
    module.exports = MainController;
}.bind(this));

require.register("app/main/app.js", function(exports, require, module) {
    // import famous dependencies
    var View = require("famous/view");
    var EventHandler = require("famous/event-handler");
    var RenderNode = require("famous/render-node");
    var Utility = require("famous/utilities/utility");
    var Matrix = require("famous/transform");
    var HeaderFooterLayout = require("famous/views/header-footer-layout");
    var EdgeSwapper = require("famous/views/edge-swapper");
    var TabBar = require("famous/widgets/tab-bar");
    //var TitleBar           = require('famous/widgets/title-bar');
    var Templates = require("templates");
    var RowView = require("row-view");
    var HeaderBar = RowView.HeaderBar;
    function App(options) {
        // extend from view
        View.apply(this, arguments);
        // create the layout
        this.layout = new HeaderFooterLayout();
        // create the header
        this.header = new HeaderBar(this.options.header);
        // create the navigation bar
        this.navigation = new TabBar(this.options.navigation);
        // create the content area
        this.contentArea = new EdgeSwapper(this.options.content);
        // link endpoints of layout to widgets
        this.layout.id["header"].add(this.header);
        this.layout.id["footer"].add(Utility.transformInFront).add(this.navigation);
        this.layout.id["content"].add(Utility.transformBehind).add(this.contentArea);
        // assign received events to content area
        this._eventInput.pipe(this.contentArea);
        // navigation events are app events
        EventHandler.setOutputHandler(this, this.navigation);
        this._eventInput = new EventHandler();
        EventHandler.setInputHandler(this, this._eventInput);
        this._eventOutput = new EventHandler();
        EventHandler.setOutputHandler(this, this._eventOutput);
        // declare the render nodes
        this._currentSection = undefined;
        this._sections = {};
        this._sectionTitles = {};
        // Initialize sections if they were passed at instantiation time
        this.options.sections && this.initSections(this.options.sections);
        // respond to the the selection of a different section
        this.navigation.on("select", function(data) {
            this._eventOutput.emit("triggerBackToNoneEditing");
            this._eventOutput.emit("updateRecent");
            $("body").removeClass("editing");
            this._currentSection = data.id;
            this.header.show(this._sectionTitles[data.id]);
            this.contentArea.show(this._sections[data.id].get());
        }.bind(this));
        var recentsChats = options.sections[0].collection;
        recentsChats.on("all", function(e, model) {
            var badge = recentsChats.getUnreadCount() || "";
            var badgeButton = $(this.navigation.buttons[0].options.content);
            badgeButton.find(".badge").text(badge);
            this.navigation.buttons[0].setOptions({
                content: badgeButton[0].outerHTML
            });
        }.bind(this));
        // assign the layout to this view
        this._add(this.layout);
    }
    App.prototype = Object.create(View.prototype);
    App.prototype.constructor = App;
    App.DEFAULT_OPTIONS = {
        header: {
            size: [ undefined, 50 ],
            inTransition: true,
            outTransition: true,
            look: {
                size: [ undefined, 50 ],
                classes: [ "header" ]
            }
        },
        navigation: {
            size: [ undefined, 50 ],
            direction: Utility.Direction.X,
            buttons: {
                onClasses: [ "navigation", "on" ],
                offClasses: [ "navigation", "off" ],
                inTransition: true,
                outTransition: true
            }
        },
        content: {
            inTransition: true,
            outTransition: true,
            overlap: true
        },
        inTransform: Matrix.identity,
        outTransform: Matrix.identity,
        inOpacity: 0,
        outOpacity: 0,
        inTransition: {
            duration: 500
        },
        outTransition: {
            duration: 200
        }
    };
    App.prototype.getState = function() {
        return this._currentSection;
    };
    App.prototype.section = function(id) {
        // create the section if it doesn't exist
        if (!(id in this._sections)) {
            this._sections[id] = new RenderNode();
            // make it possible to set the section's properties
            this._sections[id].setOptions = function(options) {
                this._sectionTitles[id] = options.title;
                this.navigation.defineSection(id, {
                    content: Templates.navigationButton(options.navigation)
                });
            }.bind(this);
        }
        return this._sections[id];
    };
    App.prototype.select = function(id) {
        this._currentSection = id;
        if (!(id in this._sections)) return false;
        this.navigation.select(id);
        return true;
    };
    // Initialize the sections that were passed in
    App.prototype.initSections = function(sections) {
        _.each(sections, function(item) {
            var id = item.title;
            this.section(id).setOptions({
                title: item.title,
                navigation: item.navigation
            });
            this.section(id).add(item);
            if (item.pipe) {
                item.pipe(this._eventInput);
            }
        }.bind(this));
    };
    App.prototype.onHeaderClick = function(data) {
        this.header._surfaces[data.id].eventHandled = true;
        this.header._surfaces[data.id].on("click", function(e) {
            switch (e.target.id) {
              case "clear-button":
                this._eventOutput.emit("clearRecent");
                break;

              case "add-contact":
                this._eventOutput.emit("editContact");
                break;

              case "edit-contact":
                $("body").toggleClass("editing");
                break;

              case "recent-toggle":
                this._eventOutput.emit("loadRecent", e);
                break;
            }
        }.bind(this));
        this.header._surfaces[data.id].pipe(this._eventOutput);
    };
    module.exports = App;
}.bind(this));

require.register("app/main/config.js", function(exports, require, module) {
    var xDirection = require("famous/utilities/utility").Direction.X;
    module.exports = {
        debug: false,
        header: {
            look: {
                classes: [ "header" ],
                size: [ undefined, 50 ],
                side: "top"
            },
            feel: {
                inTransition: {
                    method: "wall",
                    period: 300,
                    dampingRatio: 0,
                    restitution: .2
                },
                outTransition: {
                    method: "spring",
                    period: 300,
                    dampingRatio: .5,
                    velocity: 0
                },
                overlap: true
            }
        },
        navigation: {
            look: {
                side: "bottom",
                direction: xDirection,
                size: [ undefined, 50 ],
                onClasses: [ "navigation", "on" ],
                offClasses: [ "navigation", "off" ]
            },
            feel: {
                inTransition: {
                    curve: "easeInOut",
                    duration: 150
                },
                outTransition: {
                    curve: "easeInOut",
                    duration: 150
                }
            }
        },
        content: {
            feel: {
                inTransition: {
                    method: "spring",
                    period: 1e3,
                    dampingRatio: .5,
                    velocity: 0
                },
                outTransition: {
                    method: "spring",
                    period: 600,
                    dampingRatio: .5,
                    velocity: 0
                },
                overlap: true
            }
        }
    };
}.bind(this));

require.config({
    map: {
        "famous_modules/famous/polyfills/_git_master/index.js": {
            "./classList.js": "famous_modules/famous/polyfills/_git_master/classList.js",
            "./functionPrototypeBind.js": "famous_modules/famous/polyfills/_git_master/functionPrototypeBind.js",
            "./requestAnimationFrame.js": "famous_modules/famous/polyfills/_git_master/requestAnimationFrame.js"
        },
        "famous_modules/famous/polyfills/_git_master/classList.js": {},
        "famous_modules/famous/polyfills/_git_master/functionPrototypeBind.js": {},
        "famous_modules/famous/polyfills/_git_master/requestAnimationFrame.js": {},
        "famous_modules/famous/transitions/easing/_git_master/index.js": {},
        "famous_modules/famous/event-handler/_git_master/index.js": {},
        "famous_modules/famous/utilities/utility/_git_master/index.js": {},
        "famous_modules/famous/options-manager/_git_master/index.js": {
            "famous/event-handler": "famous_modules/famous/event-handler/_git_master/index.js"
        },
        "famous_modules/famous/transform/_git_master/index.js": {},
        "app/models/call-collection.js": {
            call: "app/models/call.js"
        },
        "app/models/call.js": {},
        "app/models/chat-collection.js": {
            conversation: "app/models/conversation.js"
        },
        "app/models/contact-collection.js": {
            contact: "app/models/contact.js"
        },
        "app/models/contact.js": {},
        "app/models/conversation-collection.js": {
            conversation: "app/models/conversation.js"
        },
        "app/models/conversation.js": {},
        "app/models/index.js": {
            call: "app/models/call.js",
            "recents-collection": "app/models/recents-collection.js",
            contact: "app/models/contact.js",
            "contact-collection": "app/models/contact-collection.js",
            conversation: "app/models/conversation.js",
            "conversation-collection": "app/models/conversation-collection.js",
            "chat-collection": "app/models/chat-collection.js",
            settings: "app/models/settings.js",
            "social-contact-collection": "app/models/social-contact-collection.js"
        },
        "app/models/recents-collection.js": {
            call: "app/models/call.js"
        },
        "app/models/settings.js": {},
        "app/models/social-contact-collection.js": {
            contact: "app/models/contact.js"
        },
        "app/vendor/index.js": {
            zepto: "app/vendor/zepto.js",
            underscore: "app/vendor/underscore.js",
            backbone: "app/vendor/backbone.js",
            handlebars: "app/vendor/handlebars.js",
            "backbone.localStorage": "app/vendor/backbone.localStorage.js",
            firebase: "app/vendor/firebase.js",
            "backbone-firebase": "app/vendor/backbone-firebase.js",
            peer: "app/vendor/peer.js",
            notify: "app/vendor/notify.js",
            oauthpopup: "app/vendor/oauthpopup.js"
        },
        "app/vendor/att.js": {},
        "app/vendor/backbone-firebase.js": {},
        "app/vendor/backbone.js": {
            underscore: "app/vendor/underscore.js"
        },
        "app/vendor/backbone.localStorage.js": {
            underscore: "app/vendor/underscore.js",
            backbone: "app/vendor/backbone.js"
        },
        "app/vendor/firebase.js": {},
        "app/vendor/handlebars.js": {},
        "app/vendor/notify.js": {},
        "app/vendor/oauthpopup.js": {},
        "app/vendor/peer.js": {},
        "app/vendor/underscore.js": {},
        "app/vendor/zepto.js": {},
        "app/custom/helpers/helpers.js": {},
        "app/custom/templates/templates.js": {
            helpers: "app/custom/helpers/helpers.js",
            "famous/utilities/utility": "famous_modules/famous/utilities/utility/_git_master/index.js"
        },
        "famous_modules/famous/entity/_git_master/index.js": {},
        "famous_modules/famous/surface/_git_master/index.js": {
            "famous/entity": "famous_modules/famous/entity/_git_master/index.js",
            "famous/event-handler": "famous_modules/famous/event-handler/_git_master/index.js",
            "famous/transform": "famous_modules/famous/transform/_git_master/index.js"
        },
        "famous_modules/famous/spec-parser/_git_master/index.js": {
            "famous/transform": "famous_modules/famous/transform/_git_master/index.js"
        },
        "famous_modules/famous/render-node/_git_master/index.js": {
            "famous/entity": "famous_modules/famous/entity/_git_master/index.js",
            "famous/spec-parser": "famous_modules/famous/spec-parser/_git_master/index.js"
        },
        "famous_modules/famous/view/_git_master/index.js": {
            "famous/event-handler": "famous_modules/famous/event-handler/_git_master/index.js",
            "famous/options-manager": "famous_modules/famous/options-manager/_git_master/index.js",
            "famous/render-node": "famous_modules/famous/render-node/_git_master/index.js"
        },
        "famous_modules/famous/views/header-footer-layout/_git_master/index.js": {
            "famous/entity": "famous_modules/famous/entity/_git_master/index.js",
            "famous/render-node": "famous_modules/famous/render-node/_git_master/index.js",
            "famous/transform": "famous_modules/famous/transform/_git_master/index.js"
        },
        "famous_modules/famous/element-allocator/_git_master/index.js": {},
        "famous_modules/famous/transitions/multiple-transition/_git_master/index.js": {
            "famous/utilities/utility": "famous_modules/famous/utilities/utility/_git_master/index.js"
        },
        "famous_modules/famous/transitions/tween-transition/_git_master/index.js": {
            "famous/utilities/utility": "famous_modules/famous/utilities/utility/_git_master/index.js"
        },
        "famous_modules/famous/transitions/transitionable/_git_master/index.js": {
            "famous/utilities/utility": "famous_modules/famous/utilities/utility/_git_master/index.js",
            "famous/transitions/multiple-transition": "famous_modules/famous/transitions/multiple-transition/_git_master/index.js",
            "famous/transitions/tween-transition": "famous_modules/famous/transitions/tween-transition/_git_master/index.js"
        },
        "famous_modules/famous/context/_git_master/index.js": {
            "famous/render-node": "famous_modules/famous/render-node/_git_master/index.js",
            "famous/event-handler": "famous_modules/famous/event-handler/_git_master/index.js",
            "famous/spec-parser": "famous_modules/famous/spec-parser/_git_master/index.js",
            "famous/element-allocator": "famous_modules/famous/element-allocator/_git_master/index.js",
            "famous/transform": "famous_modules/famous/transform/_git_master/index.js",
            "famous/transitions/transitionable": "famous_modules/famous/transitions/transitionable/_git_master/index.js"
        },
        "famous_modules/famous/engine/_git_master/index.js": {
            "famous/context": "famous_modules/famous/context/_git_master/index.js",
            "famous/event-handler": "famous_modules/famous/event-handler/_git_master/index.js",
            "famous/options-manager": "famous_modules/famous/options-manager/_git_master/index.js"
        },
        "famous_modules/famous/modifier/_git_master/index.js": {
            "famous/transform": "famous_modules/famous/transform/_git_master/index.js",
            "famous/transitions/transitionable": "famous_modules/famous/transitions/transitionable/_git_master/index.js",
            "famous/utilities/utility": "famous_modules/famous/utilities/utility/_git_master/index.js"
        },
        "app/custom/light-box/light-box.js": {
            "famous/transform": "famous_modules/famous/transform/_git_master/index.js",
            "famous/modifier": "famous_modules/famous/modifier/_git_master/index.js",
            "famous/render-node": "famous_modules/famous/render-node/_git_master/index.js",
            "famous/utilities/utility": "famous_modules/famous/utilities/utility/_git_master/index.js"
        },
        "famous_modules/famous/views/light-box/_git_master/index.js": {
            "famous/transform": "famous_modules/famous/transform/_git_master/index.js",
            "famous/modifier": "famous_modules/famous/modifier/_git_master/index.js",
            "famous/render-node": "famous_modules/famous/render-node/_git_master/index.js",
            "famous/utilities/utility": "famous_modules/famous/utilities/utility/_git_master/index.js"
        },
        "famous_modules/famous/views/edge-swapper/_git_master/index.js": {
            "famous/entity": "famous_modules/famous/entity/_git_master/index.js",
            "famous/event-handler": "famous_modules/famous/event-handler/_git_master/index.js",
            "famous/transform": "famous_modules/famous/transform/_git_master/index.js",
            "famous/views/light-box": "famous_modules/famous/views/light-box/_git_master/index.js"
        },
        "famous_modules/famous/widgets/title-bar/_git_master/index.js": {
            "famous/transform": "famous_modules/famous/transform/_git_master/index.js",
            "famous/surface": "famous_modules/famous/surface/_git_master/index.js",
            "famous/views/light-box": "famous_modules/famous/views/light-box/_git_master/index.js"
        },
        "famous_modules/famous/view-sequence/_git_master/index.js": {},
        "famous_modules/famous/views/grid-layout/_git_master/index.js": {
            "famous/entity": "famous_modules/famous/entity/_git_master/index.js",
            "famous/render-node": "famous_modules/famous/render-node/_git_master/index.js",
            "famous/transform": "famous_modules/famous/transform/_git_master/index.js",
            "famous/view-sequence": "famous_modules/famous/view-sequence/_git_master/index.js",
            "famous/modifier": "famous_modules/famous/modifier/_git_master/index.js",
            "famous/options-manager": "famous_modules/famous/options-manager/_git_master/index.js"
        },
        "famous_modules/famous/views/fader/_git_master/index.js": {
            "famous/transitions/transitionable": "famous_modules/famous/transitions/transitionable/_git_master/index.js"
        },
        "famous_modules/famous/views/image-fader/_git_master/index.js": {
            "famous/render-node": "famous_modules/famous/render-node/_git_master/index.js",
            "famous/views/fader": "famous_modules/famous/views/fader/_git_master/index.js",
            "famous/transform": "famous_modules/famous/transform/_git_master/index.js"
        },
        "famous_modules/famous/widgets/toggle-button/_git_master/index.js": {
            "famous/surface": "famous_modules/famous/surface/_git_master/index.js",
            "famous/event-handler": "famous_modules/famous/event-handler/_git_master/index.js",
            "famous/views/image-fader": "famous_modules/famous/views/image-fader/_git_master/index.js"
        },
        "famous_modules/famous/widgets/tab-bar/_git_master/index.js": {
            "famous/event-handler": "famous_modules/famous/event-handler/_git_master/index.js",
            "famous/utilities/utility": "famous_modules/famous/utilities/utility/_git_master/index.js",
            "famous/view": "famous_modules/famous/view/_git_master/index.js",
            "famous/views/grid-layout": "famous_modules/famous/views/grid-layout/_git_master/index.js",
            "famous/widgets/toggle-button": "famous_modules/famous/widgets/toggle-button/_git_master/index.js"
        },
        "famous_modules/famous/group/_git_master/index.js": {
            "famous/context": "famous_modules/famous/context/_git_master/index.js",
            "famous/transform": "famous_modules/famous/transform/_git_master/index.js",
            "famous/surface": "famous_modules/famous/surface/_git_master/index.js"
        },
        "famous_modules/famous/input/mouse-sync/_git_master/index.js": {
            "famous/event-handler": "famous_modules/famous/event-handler/_git_master/index.js"
        },
        "app/custom/up-down-transform/up-down-transform.js": {
            "famous/transform": "famous_modules/famous/transform/_git_master/index.js",
            "famous/transitions/easing": "famous_modules/famous/transitions/easing/_git_master/index.js"
        },
        "app/custom/conversation-surface/conversation-surface.js": {
            "famous/surface": "famous_modules/famous/surface/_git_master/index.js"
        },
        "app/custom/sound-player/sound-player.js": {
            "buffer-loader": "app/custom/sound-player/buffer-loader.js"
        },
        "app/custom/sound-player/buffer-loader.js": {},
        "famous_modules/famous/input/touch-tracker/_git_master/index.js": {
            "famous/event-handler": "famous_modules/famous/event-handler/_git_master/index.js"
        },
        "famous_modules/famous/input/touch-sync/_git_master/index.js": {
            "famous/input/touch-tracker": "famous_modules/famous/input/touch-tracker/_git_master/index.js",
            "famous/event-handler": "famous_modules/famous/event-handler/_git_master/index.js"
        },
        "app/custom/custom-input-sync/index.js": {
            "touch-sync": "app/custom/custom-input-sync/touch-sync.js",
            "mouse-sync": "app/custom/custom-input-sync/mouse-sync.js"
        },
        "app/custom/custom-input-sync/mouse-sync.js": {
            "famous/event-handler": "famous_modules/famous/event-handler/_git_master/index.js"
        },
        "app/custom/custom-input-sync/touch-sync.js": {
            "famous/input/touch-tracker": "famous_modules/famous/input/touch-tracker/_git_master/index.js",
            "famous/event-handler": "famous_modules/famous/event-handler/_git_master/index.js"
        },
        "famous_modules/famous/input/scroll-sync/_git_master/index.js": {
            "famous/event-handler": "famous_modules/famous/event-handler/_git_master/index.js",
            "famous/engine": "famous_modules/famous/engine/_git_master/index.js"
        },
        "famous_modules/famous/input/generic-sync/_git_master/index.js": {
            "famous/event-handler": "famous_modules/famous/event-handler/_git_master/index.js",
            "famous/input/touch-sync": "famous_modules/famous/input/touch-sync/_git_master/index.js",
            "famous/input/scroll-sync": "famous_modules/famous/input/scroll-sync/_git_master/index.js"
        },
        "famous_modules/famous/math/vector/_git_master/index.js": {},
        "famous_modules/famous/physics/bodies/particle/_git_master/index.js": {
            "famous/render-node": "famous_modules/famous/render-node/_git_master/index.js",
            "famous/math/vector": "famous_modules/famous/math/vector/_git_master/index.js",
            "famous/transform": "famous_modules/famous/transform/_git_master/index.js"
        },
        "famous_modules/famous/physics/forces/force/_git_master/index.js": {
            "famous/math/vector": "famous_modules/famous/math/vector/_git_master/index.js"
        },
        "famous_modules/famous/physics/forces/drag/_git_master/index.js": {
            "famous/physics/forces/force": "famous_modules/famous/physics/forces/force/_git_master/index.js"
        },
        "famous_modules/famous/physics/forces/spring/_git_master/index.js": {
            "famous/physics/forces/force": "famous_modules/famous/physics/forces/force/_git_master/index.js",
            "famous/math/vector": "famous_modules/famous/math/vector/_git_master/index.js",
            "famous/event-handler": "famous_modules/famous/event-handler/_git_master/index.js"
        },
        "famous_modules/famous/physics/constraints/constraint/_git_master/index.js": {},
        "famous_modules/famous/physics/integrator/symplectic-euler/_git_master/index.js": {},
        "famous_modules/famous/math/quaternion/_git_master/index.js": {},
        "famous_modules/famous/physics/bodies/body/_git_master/index.js": {
            "famous/physics/bodies/particle": "famous_modules/famous/physics/bodies/particle/_git_master/index.js",
            "famous/math/vector": "famous_modules/famous/math/vector/_git_master/index.js",
            "famous/math/quaternion": "famous_modules/famous/math/quaternion/_git_master/index.js",
            "famous/transform": "famous_modules/famous/transform/_git_master/index.js"
        },
        "famous_modules/famous/physics/bodies/circle/_git_master/index.js": {
            "famous/physics/bodies/body": "famous_modules/famous/physics/bodies/body/_git_master/index.js"
        },
        "famous_modules/famous/physics/bodies/rectangle/_git_master/index.js": {
            "famous/physics/bodies/body": "famous_modules/famous/physics/bodies/body/_git_master/index.js"
        },
        "famous_modules/famous/physics/engine/_git_master/index.js": {
            "famous/physics/bodies/particle": "famous_modules/famous/physics/bodies/particle/_git_master/index.js",
            "famous/physics/bodies/body": "famous_modules/famous/physics/bodies/body/_git_master/index.js",
            "famous/physics/bodies/circle": "famous_modules/famous/physics/bodies/circle/_git_master/index.js",
            "famous/physics/bodies/rectangle": "famous_modules/famous/physics/bodies/rectangle/_git_master/index.js",
            "famous/physics/forces/force": "famous_modules/famous/physics/forces/force/_git_master/index.js",
            "famous/physics/constraints/constraint": "famous_modules/famous/physics/constraints/constraint/_git_master/index.js",
            "famous/physics/integrator/symplectic-euler": "famous_modules/famous/physics/integrator/symplectic-euler/_git_master/index.js"
        },
        "famous_modules/famous/views/scrollview/_git_master/index.js": {
            "famous/utilities/utility": "famous_modules/famous/utilities/utility/_git_master/index.js",
            "famous/physics/engine": "famous_modules/famous/physics/engine/_git_master/index.js",
            "famous/physics/bodies/particle": "famous_modules/famous/physics/bodies/particle/_git_master/index.js",
            "famous/physics/forces/drag": "famous_modules/famous/physics/forces/drag/_git_master/index.js",
            "famous/physics/forces/spring": "famous_modules/famous/physics/forces/spring/_git_master/index.js",
            "famous/transform": "famous_modules/famous/transform/_git_master/index.js",
            "famous/event-handler": "famous_modules/famous/event-handler/_git_master/index.js",
            "famous/input/generic-sync": "famous_modules/famous/input/generic-sync/_git_master/index.js",
            "famous/view-sequence": "famous_modules/famous/view-sequence/_git_master/index.js",
            "famous/group": "famous_modules/famous/group/_git_master/index.js",
            "famous/entity": "famous_modules/famous/entity/_git_master/index.js"
        },
        "famous_modules/famous/transitions/spring-transition/_git_master/index.js": {
            "famous/physics/engine": "famous_modules/famous/physics/engine/_git_master/index.js",
            "famous/physics/forces/spring": "famous_modules/famous/physics/forces/spring/_git_master/index.js",
            "famous/math/vector": "famous_modules/famous/math/vector/_git_master/index.js"
        },
        "app/custom/vertical-scroll-view/vertical-scroll-view.js": {
            "famous/view": "famous_modules/famous/view/_git_master/index.js",
            "famous/utilities/utility": "famous_modules/famous/utilities/utility/_git_master/index.js",
            "famous/surface": "famous_modules/famous/surface/_git_master/index.js",
            "famous/views/scrollview": "famous_modules/famous/views/scrollview/_git_master/index.js",
            "famous/engine": "famous_modules/famous/engine/_git_master/index.js"
        },
        "famous_modules/famous/physics/constraints/wall/_git_master/index.js": {
            "famous/physics/constraints/constraint": "famous_modules/famous/physics/constraints/constraint/_git_master/index.js",
            "famous/math/vector": "famous_modules/famous/math/vector/_git_master/index.js",
            "famous/event-handler": "famous_modules/famous/event-handler/_git_master/index.js"
        },
        "famous_modules/famous/transitions/wall-transition/_git_master/index.js": {
            "famous/physics/engine": "famous_modules/famous/physics/engine/_git_master/index.js",
            "famous/physics/forces/spring": "famous_modules/famous/physics/forces/spring/_git_master/index.js",
            "famous/physics/constraints/wall": "famous_modules/famous/physics/constraints/wall/_git_master/index.js",
            "famous/math/vector": "famous_modules/famous/math/vector/_git_master/index.js"
        },
        "app/custom/row-view/header-bar.js": {
            "famous/widgets/title-bar": "famous_modules/famous/widgets/title-bar/_git_master/index.js",
            "famous/modifier": "famous_modules/famous/modifier/_git_master/index.js"
        },
        "app/custom/row-view/header-view.js": {
            "famous/surface": "famous_modules/famous/surface/_git_master/index.js",
            "famous/modifier": "famous_modules/famous/modifier/_git_master/index.js",
            "famous/transform": "famous_modules/famous/transform/_git_master/index.js",
            "famous/engine": "famous_modules/famous/engine/_git_master/index.js",
            templates: "app/custom/templates/templates.js",
            "row-view": "app/custom/row-view/row-view.js"
        },
        "app/custom/row-view/index.js": {
            "row-view": "app/custom/row-view/row-view.js",
            "item-view": "app/custom/row-view/item-view.js",
            "header-view": "app/custom/row-view/header-view.js",
            "header-bar": "app/custom/row-view/header-bar.js"
        },
        "app/custom/row-view/item-view.js": {
            "famous/render-node": "famous_modules/famous/render-node/_git_master/index.js",
            "famous/surface": "famous_modules/famous/surface/_git_master/index.js",
            "famous/modifier": "famous_modules/famous/modifier/_git_master/index.js",
            "famous/input/generic-sync": "famous_modules/famous/input/generic-sync/_git_master/index.js",
            "famous/input/mouse-sync": "famous_modules/famous/input/mouse-sync/_git_master/index.js",
            "famous/input/touch-sync": "famous_modules/famous/input/touch-sync/_git_master/index.js",
            "famous/transform": "famous_modules/famous/transform/_git_master/index.js",
            "famous/transitions/easing": "famous_modules/famous/transitions/easing/_git_master/index.js",
            "famous/transitions/transitionable": "famous_modules/famous/transitions/transitionable/_git_master/index.js",
            "famous/transitions/wall-transition": "famous_modules/famous/transitions/wall-transition/_git_master/index.js",
            "famous/transitions/spring-transition": "famous_modules/famous/transitions/spring-transition/_git_master/index.js",
            "famous/engine": "famous_modules/famous/engine/_git_master/index.js",
            "famous/utilities/utility": "famous_modules/famous/utilities/utility/_git_master/index.js",
            templates: "app/custom/templates/templates.js",
            "row-view": "app/custom/row-view/row-view.js",
            helpers: "app/custom/helpers/helpers.js"
        },
        "app/custom/row-view/row-view.js": {
            "famous/render-node": "famous_modules/famous/render-node/_git_master/index.js",
            "famous/view": "famous_modules/famous/view/_git_master/index.js",
            "famous/modifier": "famous_modules/famous/modifier/_git_master/index.js"
        },
        "app/views/add-contact-view.js": {
            "famous/views/header-footer-layout": "famous_modules/famous/views/header-footer-layout/_git_master/index.js",
            "famous/surface": "famous_modules/famous/surface/_git_master/index.js",
            "famous/event-handler": "famous_modules/famous/event-handler/_git_master/index.js",
            "famous/view": "famous_modules/famous/view/_git_master/index.js",
            "famous/views/edge-swapper": "famous_modules/famous/views/edge-swapper/_git_master/index.js",
            "up-down-transform": "app/custom/up-down-transform/up-down-transform.js",
            templates: "app/custom/templates/templates.js",
            helpers: "app/custom/helpers/helpers.js",
            models: "app/models/index.js",
            "import-contact-view": "app/views/import-contact-view.js"
        },
        "app/views/alert-view.js": {
            "famous/view": "famous_modules/famous/view/_git_master/index.js",
            "famous/surface": "famous_modules/famous/surface/_git_master/index.js",
            "famous/event-handler": "famous_modules/famous/event-handler/_git_master/index.js",
            "famous/transform": "famous_modules/famous/transform/_git_master/index.js",
            "famous/transitions/easing": "famous_modules/famous/transitions/easing/_git_master/index.js",
            "light-box": "app/custom/light-box/light-box.js"
        },
        "app/views/camera-view.js": {
            "famous/view": "famous_modules/famous/view/_git_master/index.js",
            "famous/surface": "famous_modules/famous/surface/_git_master/index.js",
            "famous/event-handler": "famous_modules/famous/event-handler/_git_master/index.js",
            "famous/modifier": "famous_modules/famous/modifier/_git_master/index.js",
            "famous/transform": "famous_modules/famous/transform/_git_master/index.js"
        },
        "app/views/chat-item-view.js": {
            templates: "app/custom/templates/templates.js",
            "row-view": "app/custom/row-view/index.js"
        },
        "app/views/chats-section-view.js": {
            "famous/view": "famous_modules/famous/view/_git_master/index.js",
            "famous/utilities/utility": "famous_modules/famous/utilities/utility/_git_master/index.js",
            "famous/surface": "famous_modules/famous/surface/_git_master/index.js",
            "vertical-scroll-view": "app/custom/vertical-scroll-view/vertical-scroll-view.js",
            "famous/engine": "famous_modules/famous/engine/_git_master/index.js",
            templates: "app/custom/templates/templates.js",
            "chat-item-view": "app/views/chat-item-view.js"
        },
        "app/views/connected-call-view.js": {
            "famous/view": "famous_modules/famous/view/_git_master/index.js",
            "famous/transform": "famous_modules/famous/transform/_git_master/index.js",
            "famous/surface": "famous_modules/famous/surface/_git_master/index.js",
            "famous/event-handler": "famous_modules/famous/event-handler/_git_master/index.js",
            templates: "app/custom/templates/templates.js",
            models: "app/models/index.js",
            "conversation-view": "app/views/conversation-view.js"
        },
        "app/views/contact-item-view.js": {
            templates: "app/custom/templates/templates.js",
            "row-view": "app/custom/row-view/index.js"
        },
        "app/views/contacts-scroll-view.js": {
            "famous/view": "famous_modules/famous/view/_git_master/index.js",
            "famous/views/header-footer-layout": "famous_modules/famous/views/header-footer-layout/_git_master/index.js",
            "famous/utilities/utility": "famous_modules/famous/utilities/utility/_git_master/index.js",
            "famous/modifier": "famous_modules/famous/modifier/_git_master/index.js",
            "famous/input/generic-sync": "famous_modules/famous/input/generic-sync/_git_master/index.js",
            "famous/surface": "famous_modules/famous/surface/_git_master/index.js",
            "famous/transitions/easing": "famous_modules/famous/transitions/easing/_git_master/index.js",
            "custom-input-sync": "app/custom/custom-input-sync/index.js",
            templates: "app/custom/templates/templates.js",
            "famous/transform": "famous_modules/famous/transform/_git_master/index.js",
            "vertical-scroll-view": "app/custom/vertical-scroll-view/vertical-scroll-view.js",
            "contact-item-view": "app/views/contact-item-view.js",
            "row-view": "app/custom/row-view/index.js"
        },
        "app/views/contacts-section-view.js": {
            "contacts-scroll-view": "app/views/contacts-scroll-view.js"
        },
        "app/views/contacts-section-view2.js": {
            "famous/view": "famous_modules/famous/view/_git_master/index.js",
            "famous/views/header-footer-layout": "famous_modules/famous/views/header-footer-layout/_git_master/index.js",
            "famous/utilities/utility": "famous_modules/famous/utilities/utility/_git_master/index.js",
            "famous/modifier": "famous_modules/famous/modifier/_git_master/index.js",
            "famous/input/generic-sync": "famous_modules/famous/input/generic-sync/_git_master/index.js",
            "famous/surface": "famous_modules/famous/surface/_git_master/index.js",
            "famous/transitions/easing": "famous_modules/famous/transitions/easing/_git_master/index.js",
            "custom-input-sync": "app/custom/custom-input-sync/index.js",
            templates: "app/custom/templates/templates.js",
            "famous/transform": "famous_modules/famous/transform/_git_master/index.js",
            "vertical-scroll-view": "app/custom/vertical-scroll-view/vertical-scroll-view.js",
            "contact-item-view": "app/views/contact-item-view.js",
            "row-view": "app/custom/row-view/index.js"
        },
        "app/views/conversation-item-view.js": {
            "famous/view": "famous_modules/famous/view/_git_master/index.js",
            "famous/event-handler": "famous_modules/famous/event-handler/_git_master/index.js",
            "famous/modifier": "famous_modules/famous/modifier/_git_master/index.js",
            "conversation-surface": "app/custom/conversation-surface/conversation-surface.js",
            helpers: "app/custom/helpers/helpers.js"
        },
        "app/views/conversation-view.js": {
            "famous/view": "famous_modules/famous/view/_git_master/index.js",
            "famous/surface": "famous_modules/famous/surface/_git_master/index.js",
            "famous/modifier": "famous_modules/famous/modifier/_git_master/index.js",
            "famous/transform": "famous_modules/famous/transform/_git_master/index.js",
            "famous/views/scrollview": "famous_modules/famous/views/scrollview/_git_master/index.js",
            "famous/utilities/utility": "famous_modules/famous/utilities/utility/_git_master/index.js",
            "famous/views/header-footer-layout": "famous_modules/famous/views/header-footer-layout/_git_master/index.js",
            "famous/engine": "famous_modules/famous/engine/_git_master/index.js",
            "famous/audio/sound-player": "app/custom/sound-player/sound-player.js",
            "famous/transitions/transitionable": "famous_modules/famous/transitions/transitionable/_git_master/index.js",
            "famous/transitions/wall-transition": "famous_modules/famous/transitions/wall-transition/_git_master/index.js",
            templates: "app/custom/templates/templates.js",
            "vertical-scroll-view": "app/custom/vertical-scroll-view/vertical-scroll-view.js",
            "conversation-item-view": "app/views/conversation-item-view.js",
            models: "app/models/index.js",
            helpers: "app/custom/helpers/helpers.js"
        },
        "app/views/favorite-item-view.js": {
            templates: "app/custom/templates/templates.js",
            "row-view": "app/custom/row-view/index.js"
        },
        "app/views/favorites-section-view.js": {
            "famous/view": "famous_modules/famous/view/_git_master/index.js",
            "famous/utilities/utility": "famous_modules/famous/utilities/utility/_git_master/index.js",
            "famous/surface": "famous_modules/famous/surface/_git_master/index.js",
            "vertical-scroll-view": "app/custom/vertical-scroll-view/vertical-scroll-view.js",
            "famous/engine": "famous_modules/famous/engine/_git_master/index.js",
            templates: "app/custom/templates/templates.js",
            "favorite-item-view": "app/views/favorite-item-view.js"
        },
        "app/views/import-contact-view.js": {
            "famous/views/header-footer-layout": "famous_modules/famous/views/header-footer-layout/_git_master/index.js",
            "famous/surface": "famous_modules/famous/surface/_git_master/index.js",
            "famous/view": "famous_modules/famous/view/_git_master/index.js",
            "social-scroll-view": "app/views/social-scroll-view.js"
        },
        "app/views/incoming-call-view.js": {
            "famous/view": "famous_modules/famous/view/_git_master/index.js",
            "famous/transform": "famous_modules/famous/transform/_git_master/index.js",
            "famous/surface": "famous_modules/famous/surface/_git_master/index.js",
            "famous/event-handler": "famous_modules/famous/event-handler/_git_master/index.js",
            "famous/transitions/easing": "famous_modules/famous/transitions/easing/_git_master/index.js",
            "famous/audio/sound-player": "app/custom/sound-player/sound-player.js",
            "light-box": "app/custom/light-box/light-box.js",
            templates: "app/custom/templates/templates.js",
            models: "app/models/index.js"
        },
        "app/views/index.js": {
            "add-contact-view": "app/views/add-contact-view.js",
            "alert-view": "app/views/alert-view.js",
            "camera-view": "app/views/camera-view.js",
            "connected-call-view": "app/views/connected-call-view.js",
            "contacts-scroll-view": "app/views/contacts-scroll-view.js",
            "contacts-section-view": "app/views/contacts-section-view.js",
            "conversation-view": "app/views/conversation-view.js",
            "favorites-section-view": "app/views/favorites-section-view.js",
            "incoming-call-view": "app/views/incoming-call-view.js",
            "outgoing-call-view": "app/views/outgoing-call-view.js",
            "recents-section-view": "app/views/recents-section-view.js",
            "chats-section-view": "app/views/chats-section-view.js",
            "settings-section-view": "app/views/settings-section-view.js",
            "social-view": "app/views/social-view.js",
            "social-scroll-view": "app/views/social-scroll-view.js"
        },
        "app/views/outgoing-call-view.js": {
            "famous/view": "famous_modules/famous/view/_git_master/index.js",
            "famous/transform": "famous_modules/famous/transform/_git_master/index.js",
            "famous/surface": "famous_modules/famous/surface/_git_master/index.js",
            "famous/event-handler": "famous_modules/famous/event-handler/_git_master/index.js",
            "famous/transitions/easing": "famous_modules/famous/transitions/easing/_git_master/index.js",
            "famous/audio/sound-player": "app/custom/sound-player/sound-player.js",
            "light-box": "app/custom/light-box/light-box.js",
            templates: "app/custom/templates/templates.js",
            models: "app/models/index.js"
        },
        "app/views/recent-item-view.js": {
            templates: "app/custom/templates/templates.js",
            "row-view": "app/custom/row-view/index.js"
        },
        "app/views/recents-section-view.js": {
            "famous/view": "famous_modules/famous/view/_git_master/index.js",
            "famous/utilities/utility": "famous_modules/famous/utilities/utility/_git_master/index.js",
            "famous/surface": "famous_modules/famous/surface/_git_master/index.js",
            "vertical-scroll-view": "app/custom/vertical-scroll-view/vertical-scroll-view.js",
            "famous/engine": "famous_modules/famous/engine/_git_master/index.js",
            templates: "app/custom/templates/templates.js",
            "recent-item-view": "app/views/recent-item-view.js"
        },
        "app/views/settings-section-view.js": {
            "famous/view": "famous_modules/famous/view/_git_master/index.js",
            "famous/utilities/utility": "famous_modules/famous/utilities/utility/_git_master/index.js",
            "famous/surface": "famous_modules/famous/surface/_git_master/index.js",
            "famous/views/scrollview": "famous_modules/famous/views/scrollview/_git_master/index.js",
            templates: "app/custom/templates/templates.js"
        },
        "app/views/social-item-view.js": {
            "famous/input/generic-sync": "famous_modules/famous/input/generic-sync/_git_master/index.js",
            "famous/input/mouse-sync": "famous_modules/famous/input/mouse-sync/_git_master/index.js",
            "famous/input/touch-sync": "famous_modules/famous/input/touch-sync/_git_master/index.js",
            "famous/utilities/utility": "famous_modules/famous/utilities/utility/_git_master/index.js",
            templates: "app/custom/templates/templates.js",
            "row-view": "app/custom/row-view/index.js",
            helpers: "app/custom/helpers/helpers.js"
        },
        "app/views/social-scroll-view.js": {
            "social-item-view": "app/views/social-item-view.js",
            "contacts-scroll-view": "app/views/contacts-scroll-view.js"
        },
        "app/views/social-view.js": {
            "famous/view": "famous_modules/famous/view/_git_master/index.js",
            "famous/utilities/utility": "famous_modules/famous/utilities/utility/_git_master/index.js",
            "famous/views/scrollview": "famous_modules/famous/views/scrollview/_git_master/index.js",
            "famous/views/header-footer-layout": "famous_modules/famous/views/header-footer-layout/_git_master/index.js",
            "famous/event-handler": "famous_modules/famous/event-handler/_git_master/index.js",
            "famous/modifier": "famous_modules/famous/modifier/_git_master/index.js",
            "famous/input/generic-sync": "famous_modules/famous/input/generic-sync/_git_master/index.js",
            "famous/surface": "famous_modules/famous/surface/_git_master/index.js",
            "custom-input-sync": "app/custom/custom-input-sync/index.js",
            "social-item-view": "app/views/social-item-view.js"
        },
        "app/views/unused-add-favorite-view.js": {
            "famous/views/header-footer-layout": "famous_modules/famous/views/header-footer-layout/_git_master/index.js",
            "famous/surface": "famous_modules/famous/surface/_git_master/index.js",
            "famous/event-handler": "famous_modules/famous/event-handler/_git_master/index.js",
            "up-down-transform": "app/custom/up-down-transform/up-down-transform.js"
        },
        "app/main/index.js": {
            vendor: "app/vendor/index.js",
            "famous/polyfills": "famous_modules/famous/polyfills/_git_master/index.js",
            "main-controller": "app/main/main-controller.js"
        },
        "app/main/main-controller.js": {
            "famous/engine": "famous_modules/famous/engine/_git_master/index.js",
            "famous/surface": "famous_modules/famous/surface/_git_master/index.js",
            "famous/transitions/easing": "famous_modules/famous/transitions/easing/_git_master/index.js",
            "famous/event-handler": "famous_modules/famous/event-handler/_git_master/index.js",
            helpers: "app/custom/helpers/helpers.js",
            "light-box": "app/custom/light-box/light-box.js",
            models: "app/models/index.js",
            views: "app/views/index.js",
            config: "app/main/config.js",
            app: "app/main/app.js"
        },
        "app/main/app.js": {
            "famous/view": "famous_modules/famous/view/_git_master/index.js",
            "famous/event-handler": "famous_modules/famous/event-handler/_git_master/index.js",
            "famous/render-node": "famous_modules/famous/render-node/_git_master/index.js",
            "famous/utilities/utility": "famous_modules/famous/utilities/utility/_git_master/index.js",
            "famous/transform": "famous_modules/famous/transform/_git_master/index.js",
            "famous/views/header-footer-layout": "famous_modules/famous/views/header-footer-layout/_git_master/index.js",
            "famous/views/edge-swapper": "famous_modules/famous/views/edge-swapper/_git_master/index.js",
            "famous/widgets/tab-bar": "famous_modules/famous/widgets/tab-bar/_git_master/index.js",
            templates: "app/custom/templates/templates.js",
            "row-view": "app/custom/row-view/index.js"
        },
        "app/main/config.js": {
            "famous/utilities/utility": "famous_modules/famous/utilities/utility/_git_master/index.js"
        }
    }
});
//# sourceMappingURL=build.map.js
